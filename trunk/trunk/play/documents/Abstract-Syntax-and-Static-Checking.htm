<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Abstract Syntax and Static Cheking</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link href="playStyle.css" rel="stylesheet" type="text/css">
</head>

<body>
<h1>Abstract Syntax</h1>
<p>Notation. Identifiers starting with lower case </p>
<h2>Classes</h2>
<p>Each class has a unique name, , and a finite set of field descriptions:</p>
<pre>   Class --&gt; class[Id]( Fd* Method )

[Changed Seq to Method.]</pre>
<p>Each field description is a VarDecl</p>
<pre>   Fd --&gt; VarDecl
</pre>
<p>  [Superclasses?]</p>
<h2>Types</h2>
<p>Types can be primitive, classes, or finite unions of types.</p>
<pre>   Type --&gt; booleanType | stringType | numberType | anyType | nullType | commType | altType( Type+ )
 | ClassType
    ClassType --&gt; classType[Id]</pre>
<p>[Need type for methods]</p>
<h2>Expressions</h2>
<h3>Literal expressions</h3>
<pre>   Exp --&gt; numberLiteral[val]</pre>
<p>val must be a string of one or more digits, possibly preceeded with a + or - sign. The value is a normalized string. For example, if val is 0123 the value is the string &quot;123&quot;. In theory, at least, every number is also a string.</p>
<pre>   Exp --&gt; <strong>true</strong> | <strong>false</strong></pre>
<p>The value is either the string &quot;true&quot; or the string &quot;false&quot;. </p>
<pre>   Exp --&gt; StringLiteral[val]</pre>
<p>The value is the string val.</p>
<pre>
   Exp --&gt; null</pre>
<h3>Variables</h3>
<pre>   Exp --&gt; Var
   Var --&gt; <strong>thisVar</strong>[Id] | <strong>local</strong>Var[Id] | <strong>worldVar</strong>[Id]</pre>
<h3>Dot</h3>
<pre>   Exp --&gt; dot[Id]( Exp) 
</pre>
<p>[Question: Should we have an analog to JavaScript's exp[exp] notation? like this:</p>
<pre>   Exp --&gt; dot2( Exp, Exp )</pre>
<p>  ]</p>
<h3>This</h3>
<pre>   Exp --&gt; <strong>this</strong>
</pre>
<h3>Calls</h3>
<pre>   Exp --&gt; callClosure( Exp0, Exp1, Exp2, ..., Exp<sub>n</sub> )
</pre>
<p>Here Exp0 should be a &quot;bound method&quot; (which is essentially a method value together with an object reference).</p>
<p>Here Exp0 is the recipient. Finally a call to world object has a special syntax</p>
<pre>   Exp --&gt; callWorld[Id]( Exp0, Exp1, Exp2, ..., Exp<sub>n-1</sub> )
</pre>
<p>In this case, the children are all arguments.
</p>
<h3>Allocation</h3>
<pre>   Exp --&gt; <strong>new</strong>( ClassType, Exp1, Exp2, ..., Expn )

[Changed Type to ClassType.]</pre>
<h3>Method literals</h3>
<pre>   Exp --&gt; Method
   Method --&gt; <strong>method</strong>(Params<sub></sub>, OptType, Seq)
   Params --&gt; params(VarDecl* )
</pre>
<p>  The value of a method literal is a closure. Free Variables of the Seq are treated as follows. this[Id] refer to the fields of the current object at the time of the method literals evaluation. When the scope of the method is a class --i.e. when method literal is evaluated as part of object construction-- the current object is considered to be the one that is being contructed. Local variables may include the parameters, but may also include local variables of any containing scopes.</p>
<h3>Control constructs</h3>
<pre>   Seq --&gt; seq( SeqMember, SeqMember, ... ) 
   SeqMember --&gt; Exp | VarDecl

   Exp --&gt; <strong>if(</strong> Exp, <strong></strong>Seq,<strong></strong> Seq)<strong></strong>
   Exp --&gt; <strong>while(</strong> Exp, Seq )<strong></strong>

   VarDecl --&gt; vardecl[Id,c]( OptType, Seq )
(Id is an identifier and c is either &quot;con&quot; or &quot;var&quot;)

[eliminated condelc nodes]
</pre>
<p>OptTypes are optional types. If the type of a VarDecl is noType, then the checker will try to fill in the type.</p>
<pre>   OptType --&gt; noType | Type
</pre>
<h3>Assignment</h3>
<pre>   Exp --&gt; assign( Exp, Exp )
</pre>
<h3>  Place holders</h3>
<p>Place holder expressions are used where expressions are required by the content model, but where there is no obvious candidate for a default value.</p>
<pre>   Exp --&gt; expPlaceHolder</pre>
<h1>Static Checking Overview</h1>
<h2>Pass 0  </h2>
<p>The aim of the first pass of static checking is to determine the types for all fields and methods using  type inference rules that don't depend on any information that can't be determined directly from the syntax or from pass 0 checking that has already happened earlier in the same class. For example if we have</p>
<pre>   <strong>class</strong> Fred <strong>var</strong> a := 1 ()-&gt;{} <strong>end</strong></pre>
<p>Then pass 0 checking will determine that field a has type Number. Likewise in </p>
<pre>   <strong>class</strong> Fred <strong>var</strong> a := 1 <strong>var</strong> b := <strong>this</strong>.a+1 ()-&gt;{} <strong>end</strong></pre>
<p>pass 0 checking will determine a type of Number for field b. However, references to variables other than earlier variables in the same class are not allowed. </p>
<p>It is an error if a field is missing a type and pass 0 fails to determine a type for it.</p>
<h2>Pass 1</h2>
<p>Pass 1 checking assumes that all classes have already undergone pass 0 checking. Therefore each field in each class has a type. Pass 1 is responsible for all further static checks. </p>
<p>By the end of pass 1 checking there should be a warning message generated for each of the following</p>
<ul>
  <li>
    <p>Type errors. E.g. attempting to add two things that may not be numbers.</p>
  </li>
  <li>
    <p>Name errors. E.g. referring to the name of a variable that does not exist.</p>
  </li>
</ul>
<h1>Pass 0 algorithm</h1>
<p>Type atoms. We assume there is a set of type atoms <em>T</em>={Any, Null, String, Number, Boolean, &perp;} &cup; {Class<sub>i</sub>|? <em>i</em> &isin; <em>I</em>} &cup; M where <em>I</em> is the set of all identifiers and M is the set of all structures method(T0, T1, ..., Tn) where Ti are types as defined below. (T0 is the result type.)</p>
<p>The type atom &perp; represents an unknown type; it is used during checking to indicate that the type of an expression in not known. By contrast Any is used to indicate that the type is known to be any type at all.</p>
<p>Type atoms are partially ordered by a subtype relation &lt;:</p>
<blockquote>
  <p>Number &lt;: String</p>
  <p>Boolean &lt;: String</p>
  <p>String &lt;: Any</p>
  <p>Null &lt;: Any</p>
  <p>Class<sub>i</sub> &lt;: Any</p>
  <p>Any &lt;: &perp;</p>
</blockquote>
<p>For two method types with the same number of parameters,</p>
<p class="centre">method(T0, T1, ..., Tn) &lt;: method(S0, S1, ..., Sn)</p>
<p class="centre">iff</p>
<p class="centre">T0&lt;:S0 and S1 &lt;: T1 and ... and Sn &lt;: Tn .</p>
<p>Types are finite sets of type atoms with the property that the set is canonical. A canonical set does not contain two distinct type atoms a and b such that a is a subtype of b. That is a canonical type is a set of type atoms obeying the law canonicalize(S)=S where canonicalize is a function that repeatedly replaces each pair of atoms a and b where  a is a subtype of b with just b. For example</p>
<ul>
  <li> canonicalize( { Number, String, Boolean } ) = {String}</li>
  <li>canonicalize( { Number, Boolean } ) = {Number, Boolean}</li>
  <li>canonicalize( { Any, Null } ) = { Any }	</li>
</ul>
<p>The join of two types T and S is given by</p>
<p class="centre">T &or; S = canonicalize( T &cup; S ) .</p>
<p>The subtype relation can be extended to types:</p>
<p class="centre">T &lt;: S iff T &or; S = S .</p>
<p>Variables come in three kinds. <em>K</em>={this, local, world}. Variable come in two constnesses C = {con, var}.</p>
<p>Pass 0 computes a mapping from AST nodes to types. At the end of pass 0, each varDecl and conDecl node within a class should be mapped to some element of <em>Type</em>.</p>
<p>To keep track of the types of identifiers, we use a symbol table <em>st</em>, which is represents a map from<em> I</em>&times;{this, local, world} to <em>C&times;Type</em>. Operations on symbol table include</p>
<p>st.get(<em>i</em> : <em>I</em>, <em>k</em> : <em>K</em>) : <em>T </em>-- Gives the current value of i. If nothing is found the unknown type &perp; is returned.</p>
<p>st.put(<em>i</em> : <em>I</em>, <em>k</em> : <em>K</em>, c : C, <em>T</em> : <em>Type</em>) -- puts a new value for i in the current frame</p>
<p>st.pushFrame() </p>
<p>st.popFrame() </p>
<pre>checkClass0( n : Node, st : SymTab, map : Map ) is
    match n
    case  class[Id]( fd0 fd1 ... method ) :
            check that all the field names are distinct
            st.pushFrame()
            for each fd_i: 
                let n be the name of fd_i
                let c be the constness of the declaration
                let t be the type node for the declaration
                let T be checkType0( t )
                st.put( n, this, c, T) 
                add (fd_i, (T,c) ) to the map
            for each fd_i in order of declaration
               if fd_i is mapped to  {&perp;},
                   checkField0( fd0, st, map )
            st.popFrame()

checkExp0( n : Node, st : SymTab, map : Map ) is
    match n 
    case numberLiteral: return {number}
    case true: return {boolean}
    case false: return {boolean}
    case stringLiteral[v]: return {string}
    case null: return {Null}
    case thisVar[i]: return st.get(i,this)
    case localVar[i]: return st.get(i,local)
    case worldVar[i]: return st.get(i,world)
    case dot[i]( e ): return {&perp;}
    case this: return the type of the class being checked.
    case callClosure( ... ): return  {&perp;}
    case callWorld( ... ):  return  {&perp;}
    case new( ct, ... ): return the type assocciated with ct
    case method( param[0], ..., param[n], ot, seq ) {
        run checkVar0 on the parameters to get (c[1],T[1]), (c[2],T[2]), ..., (c[n],T[n])
        if any of these are  {&perp;} , return {&perp;}
        if ot is a type, run checkType0( ot ) to get T[0]
        else st.pushFrame()
               for each i, st.put( param[i].name, local, c[i], T[i] )
               run checkSeq0( seq, st, map ) to get T[0]
               st.pop()
        if T[0] is {&perp;} , return {&perp;}
        else return method( T0, T1, ..., Tn )
    case seq( ... )
        return checkSeq0( n, st, map )
    case if( e, s0, s1 )
        T0 := checkSeq0( s0, st, map )
        T1 := checkSeq0( s1, st, map )
         return T0 <span class="centre"> &or; </span>T1
    case while( e, s0 ) 
        return {Null}
    case assign( e0, e1 )
        return {Null}
    case expPlaceHolder
        return {&perp;}
        
checkSeq0( seq( m[0], m[1], ..., m[n] ): Node, st : SymTab, map : Map )
    if n=0 return {Null}
    st.pushFrame() ;
    c := 0
    for each i
        match m[i]
        case vardecl[i, k]( OptType, Seq )
           (c[i],T[i]) := checkVar0( m[i], st, map )
            st.pushFrame()
            c := c+1
            st.put( i, local, c[i], T[i] )
        default
            T[i] := checkExp0( m[i], st, map )
    for each i in {0,..c} st.pop()
    return T[n]     

checkField0( n : Node, st : SymTab, map : Map )
    (c,T) := checkVar0( n, st, map )
    change the value of n in the map to (T, c)

checkVar0( vardecl[i, c]( ot, seq ) : Node, st : SymTab, map : Map )
    if ot is NoType then
        T := checkSeq0( seq , st, map )
    else
        T := checkType0( ot )
    return (c,T)

checkType0( n : Node )
    match n 
    case noType : return {&perp;}
    case booleanType : return {Boolean}
    case stringType: return {String}
    case numberType: return {Number}
    case anyType: return {Any}
    case nullType: return {Null}
    case altType(t[0], t[1], ... t[n]) :
         for i : T[i] := checkType( t[i] )
         return T[0] <span class="centre">&or;</span> T[1] <span class="centre">&or;</span> ... <span class="centre">&or;</span> T[n]
    case classType[i]: return ClassType[i]</pre>
</body>
</html>
