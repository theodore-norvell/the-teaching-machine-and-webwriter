/* Generated By:JavaCC: Do not edit this line. Parser.java */
package tm.cpp.parser ;

import java.io.* ;
import java.util.* ;

import tm.cpp.analysis.* ;
import tm.cpp.ast.* ;
import tm.clc.ast.* ;
import tm.clc.analysis.* ;
import tm.interfaces.SourceCoords ;
import tm.utilities.* ;

public class Parser implements ParserConstants {

  private ParserContext pc ;

  // binary_ops 
  // We need a table to record the precedence of all the binary
  // operations.
  // The following relies on token kinds falling between 0 and UNEXPECTED_CHAR inclusive
  private static int[] binary_ops ;
  private static final int lastToken = UNEXPECTED_CHAR ;

  // right_assoc
  // This table represents the set of all right associative operator
  private static boolean[] right_assoc ;

  private static boolean tables_initialized = false ;

  public static NoExpNode noExp_node = new NoExpNode() ;

  public void init( ParserContext pc, FileMap fileMap ) {
    token_source.set_parser_context( pc ) ;
    token_source.setFileMap( fileMap ) ;
        this.pc = pc ;
        if( ! tables_initialized ) {
            binary_ops = new int[ lastToken+1 ] ;
            right_assoc = new boolean[ lastToken+1 ] ;
            for( int i=0 ; i<lastToken+1 ; ++i ) {
                binary_ops[i] = -1 ;
                right_assoc[i] = false ; }

            binary_ops[COMMA] = 0 ;

            binary_ops[ASSIGN] = 2 ;
            binary_ops[STARASSIGN] = 2 ;
            binary_ops[SLASHASSIGN] = 2 ;
            binary_ops[PERCENTASSIGN] = 2 ;
            binary_ops[PLUSASSIGN] = 2 ;
            binary_ops[MINUSASSIGN] = 2 ;
            binary_ops[SHIFTLEFTASSIGN] = 2 ;
            binary_ops[SHIFTRIGHTASSIGN] = 2 ;
            binary_ops[BITWISEANDASSIGN] = 2 ;
            binary_ops[BITWISEORASSIGN] = 2 ;
            binary_ops[BITWISEXORASSIGN] = 2 ;

            binary_ops[ QUESTIONMARK ] = 3 ;

            binary_ops[ OR ] = 4 ;

            binary_ops[ AND ] = 5 ;

            binary_ops[ BITWISEOR ] = 6 ;

            binary_ops[ BITWISEXOR ] = 7 ;

            binary_ops[ AMPERSAND ] = 8 ;

            binary_ops[ EQUAL ] = 9 ;
            binary_ops[ NOTEQUAL ] = 9 ;

            binary_ops[ LESSTHANOREQUALTO ] = 10 ;
            binary_ops[ GREATERTHANOREQUALTO ] = 10 ;
            binary_ops[ LESSTHAN ] = 10 ;
            binary_ops[ GREATERTHAN ] = 10 ;

            binary_ops[ SHIFTLEFT ] = 11 ;
            binary_ops[ SHIFTRIGHT ] = 11 ;

            binary_ops[ PLUS ] = 12 ;
            binary_ops[ MINUS ] = 12 ;

            binary_ops[ STAR ] = 13 ;
            binary_ops[ SLASH ] = 13 ;
            binary_ops[ PERCENT ] = 13 ;


            binary_ops[ DOTSTAR ] = 14 ;
            binary_ops[ ARROWSTAR ] = 14 ;

            right_assoc[ASSIGN] = true ;
            right_assoc[STARASSIGN] = true ;
            right_assoc[SLASHASSIGN] = true ;
            right_assoc[PERCENTASSIGN] = true ;
            right_assoc[PLUSASSIGN] = true ;
            right_assoc[MINUSASSIGN] = true ;
            right_assoc[SHIFTLEFTASSIGN] = true ;
            right_assoc[SHIFTRIGHTASSIGN] = true ;
            right_assoc[BITWISEANDASSIGN] = true ;
            right_assoc[BITWISEORASSIGN] = true ;
            right_assoc[BITWISEXORASSIGN] = true ;

            tables_initialized = true ; }

  }

  //  Coordinates
  SourceCoords getCoords(int offset ) {
    return pc.line_map.getCoords(getToken(offset).beginLine) ; }

////////////////////////////////////////////////////////////////////
// Lexical analyzer is continued after the context free grammar   //
////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
// Here begins the context free grammar
// This grammar follows the ISO standard grammar to
// the extent possible.
// Deviations are noted.
///////////////////////////////////////////////////////////////////

// translation_unit --> declaration* <EOF>
  final public void translation_unit(String file_name, StatementNodeLink p) throws ParseException {
     pc.start_file_scope( file_name ) ;
     pc.enter_standard_declarations() ;
    try {
      label_1:
      while (true) {
        if (getToken(1).kind != EOF) {
          ;
        } else {
          break label_1;
        }
        // Semantic lookahead above is to suppress syntactic lookahead
                       // on declaration
                       p = declaration(p);
      }
      jj_consume_token(0);
    } catch (TMException e) {
        int rawLineNumber ;
        if( e instanceof ParseException && ((ParseException)e).currentToken != null) {
            rawLineNumber = ((ParseException)e).currentToken.next.beginLine ; }
        else {
            rawLineNumber = getToken(0).beginLine ; }
        SourceCoords coords = pc.line_map.getCoords( rawLineNumber ) ;
        e.setSourceCoords( coords ) ;
        {if (true) throw e ;}
    } catch (RuntimeException e) {
        int rawLineNumber = getToken(0).beginLine ;
        SourceCoords coords = pc.line_map.getCoords( rawLineNumber ) ;
        Debug.getInstance().msg(Debug.COMPILE, "Exception thrown while parsing line "+coords);
        {if (true) throw e ;}
    }
     pc.end_file_scope( ) ;
  }

///////////////////////////////////////////////////////////////////
//  DECLARATIONS
///////////////////////////////////////////////////////////////////

// declaration --> block_declaration_or_function_definition
//               | name_space_definition
//               | linkage_specification
//               | template_declaration
//               | explicit_instantiation
//               | explicit_specialization
  final public StatementNodeLink declaration(StatementNodeLink p) throws ParseException {
  NodeList var_decls ;
    if (jj_2_1(2147483647)) {
      linkage_specification();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EXPORT:
      case TEMPLATE:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case EXPORT:
          jj_consume_token(EXPORT);
          break;
        default:
          jj_la1[0] = jj_gen;
          ;
        }
        jj_consume_token(TEMPLATE);
             pc.sorry_not_implemented( "templates" ) ;
        break;
      case NAMESPACE:
        namespace_definition();
        break;
      default:
        jj_la1[1] = jj_gen;
        if (jj_2_2(1)) {
          block_declaration_or_function_definition(p);
        } else {
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
         {if (true) return p;}
    throw new Error("Missing return statement in function");
  }

// block_declaration_or_function_definition -->
//             | asm_definition
//             | namespace_alias_definition
//             | using_declaration
//             | using_directive
//             | simple_declaration_or_function_definition
// DEVIATION: The ISO spec makes block_declaration and function_definition
// separate syntactic categories.  However, this requires a complex lookahead.
  final public StatementNodeLink block_declaration_or_function_definition(StatementNodeLink p) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ASM:
      asm_definition();
      break;
    default:
      jj_la1[2] = jj_gen;
      if (jj_2_3(2147483647)) {
        using_directive();
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case USING:
          using_declaration();
          break;
        default:
          jj_la1[3] = jj_gen;
          if (jj_2_4(1)) {
            p = simple_declaration_or_function_definition(p);
          } else {
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
      }
    }
     {if (true) return p;}
    throw new Error("Missing return statement in function");
  }

// block_declaration_with_nonopt_decl_spec
//           --> simple_declaration_with_nonopt_decl_spec
//             | asm_definition
//             | namespace_alias_definition
//             | using_declaration
//             | using_directive
// Deviation from ISO grammar.  I'm splitting the ISO's block_declaration
// nonterminal into two special cases: block_declaration and
// block_declaration_with_nonopt_decl_spec.  The reason is the LOOKAHEAD in "statement"
// that is used to distinguish declaration statements from expression statements.
// Suppose that "foo" is not a type name, then "foo();" is syntactically a valid
// "block_definition", although it violates the semantic rule that declarations of
//  constructors, destructors, and type conversions may omit all delc_specifiers.
// Thus the following code for "statement" does not work
//       ...
//       | LOOKAHEAD(block_declaration())
//         block_declaration(p)
//       | expression() ";"
//       ...
// So instead we do the lookahead insisting on at least one declaration specfier.
//       ...
//       | LOOKAHEAD(block_declaration_with_nonopt_decl_spec())
//         block_declaration_with_nonopt_decl_spec(p)
//       | expression() ";"
//       ...
//
// Actually, something I don't understand is why simple_declaration
// allows all the decl_specifiers to be omitted.  Constructors, destructors
// and, I presume, conversions can only be declared within a class specifier,
// and there simple_declaration is not used.
// 
// Maybe a simpler solution is to change simple_declaration
// so that it insists on at least one declaration specifier.
// Then we only need one version of simple_declaration and one
// version of block_declaration.
//
// TSN
  final public StatementNodeLink block_declaration_with_nonopt_decl_spec(StatementNodeLink p) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ASM:
      asm_definition();
      break;
    case NAMESPACE:
      namespace_alias_definition();
      break;
    default:
      jj_la1[4] = jj_gen;
      if (jj_2_5(2147483647)) {
        using_directive();
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case USING:
          using_declaration();
          break;
        default:
          jj_la1[5] = jj_gen;
          if (jj_2_6(1)) {
            p = simple_declaration_with_nonopt_decl_spec(p);
          } else {
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
      }
    }
     {if (true) return p;}
    throw new Error("Missing return statement in function");
  }

// simple_declaration_or_function_definition 
//   --> opt_decl_specifier_seq ( opt_init_declarator_list ";"
//                              | rest_of_function_definition )
// DEVIATION: This nonterminal is not in the ISO spec.
  final public StatementNodeLink simple_declaration_or_function_definition(StatementNodeLink p) throws ParseException {
    Cpp_SpecifierSet spec_set = new Cpp_SpecifierSet () ;
    if (jj_2_9(2147483647)) {
      rest_of_function_definition(spec_set);
    } else if (jj_2_10(1)) {
      opt_decl_specifier_seq(spec_set);
      if (jj_2_7(2147483647)) {
        rest_of_function_definition(spec_set);
      } else if (jj_2_8(2147483647)) {
        p = opt_init_declarator_list(spec_set, p);
        jj_consume_token(SEMICOLON);
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return p ;}
    throw new Error("Missing return statement in function");
  }

// simple_declaration -> opt_decl_specifier_seq opt_init_declarator_list ";"
  final public StatementNodeLink simple_declaration(StatementNodeLink p) throws ParseException {
    Cpp_SpecifierSet spec_set = new Cpp_SpecifierSet () ;
    opt_decl_specifier_seq(spec_set);
    p = opt_init_declarator_list(spec_set, p);
    jj_consume_token(SEMICOLON);
         {if (true) return p ;}
    throw new Error("Missing return statement in function");
  }

// simple_declaration_with_nonopt_decl_spec -> decl_specifier_seq opt_init_declarator_list ";"
//
// See block_declaration_with_nonopt_decl_spec for the reationale behind this
// nonterminal.
  final public StatementNodeLink simple_declaration_with_nonopt_decl_spec(StatementNodeLink p) throws ParseException {
    Cpp_SpecifierSet spec_set = new Cpp_SpecifierSet() ;
    decl_specifier_seq(spec_set);
    p = opt_init_declarator_list(spec_set, p);
    jj_consume_token(SEMICOLON);
         {if (true) return p ;}
    throw new Error("Missing return statement in function");
  }

// opt_decl_specifier_seq --> decl_specifier*
  final public void opt_decl_specifier_seq(Cpp_SpecifierSet spec_set) throws ParseException {
    label_2:
    while (true) {
      if (jj_2_11(1)) {
        ;
      } else {
        break label_2;
      }
      decl_specifier(spec_set);
    }
  }

// decl_specifier_seq --> decl_specifier *
  final public void decl_specifier_seq(Cpp_SpecifierSet spec_set) throws ParseException {
    label_3:
    while (true) {
      decl_specifier(spec_set);
      if (jj_2_12(1)) {
        ;
      } else {
        break label_3;
      }
    }
  }

//  To be done.
//  void decl_specifier_lookahead() :
//  {
//      Cpp_SpecifierSet spec_set = null ;
//  }
//  {
//      storage_class_specifier( spec_set ) 
//  |
//      function_specifier( spec_set )
//  |
//      <FRIEND>
//  |
//      <TYPEDEF>
//  }
  final public void decl_specifier(Cpp_SpecifierSet spec_set) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AUTO:
    case EXTERN:
    case MUTABLE:
    case REGISTER:
    case STATIC:
      storage_class_specifier(spec_set);
      break;
    default:
      jj_la1[6] = jj_gen;
      if (jj_2_13(1)) {
        type_specifier(spec_set);
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case EXPLICIT:
        case INLINE:
        case VIRTUAL:
          function_specifier(spec_set);
          break;
        case FRIEND:
          jj_consume_token(FRIEND);
               spec_set.add( Cpp_Specifiers.SP_FRIEND ) ;
          break;
        case TYPEDEF:
          jj_consume_token(TYPEDEF);
                spec_set.add( Cpp_Specifiers.SP_TYPEDEF ) ;
          break;
        default:
          jj_la1[7] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
  }

  final public void storage_class_specifier(Cpp_SpecifierSet spec_set) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AUTO:
      jj_consume_token(AUTO);
             spec_set.add( Cpp_Specifiers.SP_AUTO ) ;
      break;
    case REGISTER:
      jj_consume_token(REGISTER);
                 spec_set.add( Cpp_Specifiers.SP_REGISTER ) ;
      break;
    case STATIC:
      jj_consume_token(STATIC);
               spec_set.add( Cpp_Specifiers.SP_STATIC ) ;
      break;
    case EXTERN:
      jj_consume_token(EXTERN);
               spec_set.add( Cpp_Specifiers.SP_EXTERN ) ;
      break;
    case MUTABLE:
      jj_consume_token(MUTABLE);
                spec_set.add( Cpp_Specifiers.SP_MUTABLE ) ;
      break;
    default:
      jj_la1[8] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void function_specifier(Cpp_SpecifierSet spec_set) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INLINE:
      jj_consume_token(INLINE);
               spec_set.add( Cpp_Specifiers.SP_INLINE ) ;
      break;
    case VIRTUAL:
      jj_consume_token(VIRTUAL);
                spec_set.add( Cpp_Specifiers.SP_VIRTUAL ) ;
      break;
    case EXPLICIT:
      jj_consume_token(EXPLICIT);
                 spec_set.add( Cpp_Specifiers.SP_EXPLICIT ) ;
      break;
    default:
      jj_la1[9] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void type_specifier(Cpp_SpecifierSet spec_set) throws ParseException {
    if (jj_2_14(1)) {
      simple_type_specifier(spec_set);
    } else if (jj_2_15(2147483647)) {
      class_specifier(spec_set);
    } else if (jj_2_16(2147483647)) {
      enum_specifier(spec_set);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CLASS:
      case ENUM:
      case STRUCT:
      case TYPENAME:
      case UNION:
        elaborated_type_specifier(spec_set);
        break;
      case CONST:
      case VOLATILE:
        cv_qualifier(spec_set);
        break;
      default:
        jj_la1[10] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

  final public void simple_type_specifier(Cpp_SpecifierSet spec_set) throws ParseException {
  ScopedName name ;
    if (pc.lookahead_scoped_type_name_follows(this)) {
      // This semantic lookahead should fail if the identifier is not
              // ultimately a type name.
              // Consider:
              //     foo (f) ;
              // Case (0): Neither foo nor f is a type name.
              // A syntactic lookahead on block_declaration_with_nonopt_decl_spec
              // of simple_declaration_with_nonopt_decl_spec (the important examples
              // are in "statement" and "more_for"), will ultimately
              // fail because the above semantic lookahead fails on foo.
              // Therefore foo(f) is a function call.
              //
              // Case (1): foo is a type name, then we have
              //      simple_declaration_with_nonopt_decl_spec
              //  =>* decl_specifier opt_init_declarator_list ;
              //  =>* simple_type_specifier opt_init_declarator_list ;
              // etc. So we have a declaration of a variable f.  (Even if
              // f is a type name.)
              //
              // Case (2): foo is not a type name, but f is.
              // We get
              //      simple_declaration_with_nonopt_decl_spec
              //   =>* decl_specifier_list opt_init_declarator_list ;
              //  =>* simple_type_specifier opt_init_declarator_list ;
              // since the above LOOKAHEAD fails, the whole LOOKAHEAD on
              // simple_declaration_with_nonopt_decl_spec and the phrase
              // is parsed as an expresion.
              // 
              // Remaining problems. 
              // (1) Need to stop consuming decl_specifiers at the right time.
              // Consider 
              //    X Y ;
              // where  X and Y are type names.  This should declare a variable Y.
              // So we must break out of the decl_specifier loop after the X.
              // Similary 
              //    int X ;
              // where X is a type name.  Again we need to break out of the loop
              // at the right time.  At the same time
              //    short int x ;
              // and
              //    int const short x ;
              // are valid, so you can't just restrict the sequence of
              // declaration specifiers to only have 1 type specifier.
          name = scoped_type_name();
          spec_set.add_type_name( name ) ;
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CHAR:
        jj_consume_token(CHAR);
             spec_set.add( Cpp_Specifiers.SP_CHAR ) ;
        break;
      case WCHAR_T:
        jj_consume_token(WCHAR_T);
                spec_set.add( Cpp_Specifiers.SP_WCHAR_T ) ;
        break;
      case BOOL:
        jj_consume_token(BOOL);
             spec_set.add( Cpp_Specifiers.SP_BOOL ) ;
        break;
      case SHORT:
        jj_consume_token(SHORT);
              spec_set.add( Cpp_Specifiers.SP_SHORT ) ;
        break;
      case INT:
        jj_consume_token(INT);
            spec_set.add( Cpp_Specifiers.SP_INT ) ;
        break;
      case LONG:
        jj_consume_token(LONG);
             spec_set.add( Cpp_Specifiers.SP_LONG ) ;
        break;
      case SIGNED:
        jj_consume_token(SIGNED);
               spec_set.add( Cpp_Specifiers.SP_SIGNED ) ;
        break;
      case UNSIGNED:
        jj_consume_token(UNSIGNED);
                 spec_set.add( Cpp_Specifiers.SP_UNSIGNED ) ;
        break;
      case FLOAT:
        jj_consume_token(FLOAT);
              spec_set.add( Cpp_Specifiers.SP_FLOAT ) ;
        break;
      case DOUBLE:
        jj_consume_token(DOUBLE);
               spec_set.add( Cpp_Specifiers.SP_DOUBLE ) ;
        break;
      case VOID:
        jj_consume_token(VOID);
             spec_set.add( Cpp_Specifiers.SP_VOID ) ;
        break;
      default:
        jj_la1[11] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

  final public void elaborated_type_specifier(Cpp_SpecifierSet spec_set) throws ParseException {
    ScopedName name ;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CLASS:
      jj_consume_token(CLASS);
      name = scoped_identifier();
            pc.declare_class( name, getCoords(0) ) ;
            spec_set.add( Cpp_Specifiers.SP_CLASS ) ;
            spec_set.add_type_name( name ) ;
      break;
    case STRUCT:
      jj_consume_token(STRUCT);
      name = scoped_identifier();
            pc.declare_class( name, getCoords(0) ) ;
            spec_set.add( Cpp_Specifiers.SP_STRUCT ) ;
            spec_set.add_type_name( name ) ;
      break;
    case UNION:
      jj_consume_token(UNION);
      name = scoped_identifier();
            pc.sorry_not_implemented( "union" ) ;
      break;
    case ENUM:
      jj_consume_token(ENUM);
      name = scoped_identifier();
            pc.sorry_not_implemented( "enum" ) ;
      break;
    case TYPENAME:
      jj_consume_token(TYPENAME);
          pc.sorry_not_implemented( "typename" ) ;
      break;
    default:
      jj_la1[12] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void enum_specifier(Cpp_SpecifierSet spec_set) throws ParseException {
    String id ;
    jj_consume_token(ENUM);
    id = identifier();
    jj_consume_token(OPEN_BRACE);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ID:
      enumerator_list();
      break;
    default:
      jj_la1[13] = jj_gen;
      ;
    }
    jj_consume_token(CLOSE_BRACE);
          pc.sorry_not_implemented( "enum" ) ;
  }

  final public void enumerator_list() throws ParseException {
    enumerator_definition();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COMMA:
      jj_consume_token(COMMA);
      enumerator_list();
      break;
    default:
      jj_la1[14] = jj_gen;
      ;
    }
  }

  final public void enumerator_definition() throws ParseException {
    identifier();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ASSIGN:
      jj_consume_token(ASSIGN);
      constant_expression();
      break;
    default:
      jj_la1[15] = jj_gen;
      ;
    }
  }

  final public void namespace_definition() throws ParseException {
    jj_consume_token(NAMESPACE);
      pc.sorry_not_implemented( "namespace" ) ;
  }

  final public void namespace_alias_definition() throws ParseException {
    jj_consume_token(NAMESPACE);
      pc.sorry_not_implemented( "namespace" ) ;
  }

  final public void using_declaration() throws ParseException {
    ScopedName name = new Cpp_ScopedName() ;
    jj_consume_token(USING);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TYPENAME:
      jj_consume_token(TYPENAME);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SCOPE:
        jj_consume_token(SCOPE);
        break;
      default:
        jj_la1[16] = jj_gen;
        ;
      }
      nested_name_specifier(name);
      break;
    case SCOPE:
      jj_consume_token(SCOPE);
      if (jj_2_17(2147483647)) {
        nested_name_specifier(name);
      } else {
        ;
      }
      break;
    case ID:
      nested_name_specifier(name);
      break;
    default:
      jj_la1[17] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    unqualified_id();
    jj_consume_token(SEMICOLON);
      pc.sorry_not_implemented( "\u005c"using\u005c" declaration" ) ;
  }

  final public void using_directive() throws ParseException {
   ScopedName name = new Cpp_ScopedName() ;
    jj_consume_token(USING);
    jj_consume_token(NAMESPACE);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SCOPE:
      jj_consume_token(SCOPE);
      break;
    default:
      jj_la1[18] = jj_gen;
      ;
    }
    if (jj_2_18(2147483647)) {
      nested_name_specifier(name);
    } else {
      ;
    }
    identifier();
    jj_consume_token(SEMICOLON);
  }

  final public void asm_definition() throws ParseException {
    jj_consume_token(ASM);
    jj_consume_token(OPEN_PAREN);
    jj_consume_token(STRING);
    jj_consume_token(CLOSE_PAREN);
    jj_consume_token(SEMICOLON);
      pc.sorry_not_implemented( "asm" ) ;
  }

  final public void linkage_specification() throws ParseException {
    jj_consume_token(EXTERN);
    jj_consume_token(STRING);
      pc.sorry_not_implemented( "linkage specifications" ) ;
  }

/////////////////////////
////// DECLARATORS //////
/////////////////////////

// opt_init_declarator_list --> ( init_declarator (, init_declarator) )*
  final public StatementNodeLink opt_init_declarator_list(Cpp_SpecifierSet spec_set, StatementNodeLink p) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPEN_PAREN:
    case SCOPE:
    case AMPERSAND:
    case STAR:
    case TILDE:
    case OPERATOR:
    case ID:
      p = init_declarator(spec_set, p);
      label_4:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[19] = jj_gen;
          break label_4;
        }
        jj_consume_token(COMMA);
        p = init_declarator(spec_set, p);
      }
      break;
    default:
      jj_la1[20] = jj_gen;
      ;
    }
         {if (true) return p;}
    throw new Error("Missing return statement in function");
  }

// init_declarator --> declarator [initializer]
  final public StatementNodeLink init_declarator(Cpp_SpecifierSet spec_set, StatementNodeLink p) throws ParseException {
  TypeNodeLink type_link = new TypeNodeLink() ;
  TypeNode base_type ;
  Initializer i ;
  ScopedName name ;
  SourceCoords coords = getCoords(0) ;
    name = declarator(type_link);
          base_type = pc.extract_type(spec_set) ;
          type_link.addToEnd( base_type ) ;
          p = pc.simple_declaration( p, coords, name, spec_set, type_link.get() ) ;
          pc.start_initializer( name ) ;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPEN_PAREN:
    case ASSIGN:
      i = initializer();
      break;
    default:
      jj_la1[21] = jj_gen;
              i = new Initializer( Initializer.NONE ) ;
    }
          p = pc.end_initializer( i, p ) ;
         {if (true) return p ;}
    throw new Error("Missing return statement in function");
  }

  final public ScopedName declarator(TypeNodeLink type_link) throws ParseException {
  ScopedName name ;
  Cpp_SpecifierSet spec_set ;
  int k ;
    if (jj_2_21(2147483647)) {
              spec_set = new Cpp_SpecifierSet() ;
      k = ptr_operator(spec_set);
      name = declarator(type_link);
              if( k == STAR ) {
                type_link.addToEnd( new TyPointer( spec_set ) ) ; }
              else if( k == AMPERSAND ) {
                type_link.addToEnd( new TyRef( ) ) ; }
              else {
                Assert.check( false ) ; }
          {if (true) return name ;}
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPEN_PAREN:
        jj_consume_token(OPEN_PAREN);
        name = declarator(type_link);
        jj_consume_token(CLOSE_PAREN);
        if (jj_2_19(2147483647)) {
          declarator_prime(type_link);
        } else {
          ;
        }
          {if (true) return name ;}
        break;
      case SCOPE:
      case TILDE:
      case OPERATOR:
      case ID:
        name = declarator_id();
        if (jj_2_20(2147483647)) {
          declarator_prime(type_link);
        } else {
          ;
        }
          {if (true) return name ;}
        break;
      default:
        jj_la1[22] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

// ptr_operator --> "*" cv_qualifier* | & | [::] nested_name_specifier "*" cv_qualifier*
  final public int ptr_operator(Cpp_SpecifierSet spec_set) throws ParseException {
    ScopedName name ;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case STAR:
      jj_consume_token(STAR);
      label_5:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CONST:
        case VOLATILE:
          ;
          break;
        default:
          jj_la1[23] = jj_gen;
          break label_5;
        }
        cv_qualifier(spec_set);
      }
         {if (true) return STAR ;}
      break;
    case AMPERSAND:
      jj_consume_token(AMPERSAND);
         {if (true) return AMPERSAND;}
      break;
    case SCOPE:
    case ID:
          name = new Cpp_ScopedName() ;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SCOPE:
        jj_consume_token(SCOPE);
               name.set_absolute();
        break;
      default:
        jj_la1[24] = jj_gen;
        ;
      }
      nested_name_specifier(name);
      jj_consume_token(STAR);
      label_6:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CONST:
        case VOLATILE:
          ;
          break;
        default:
          jj_la1[25] = jj_gen;
          break label_6;
        }
        cv_qualifier(spec_set);
      }
          pc.sorry_not_implemented( "pointers to members" ) ;
          {if (true) return 0 ;}
      break;
    default:
      jj_la1[26] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

// declarator_prime --> see declarator for comments.
  final public void declarator_prime(TypeNodeLink type_link) throws ParseException {
  Vector param_types ;
  boolean [] ends_with_ellipsis ;
  ExpressionNode e ;
  Cpp_SpecifierSet spec_set ;
    label_7:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPEN_BRACKET:
        jj_consume_token(OPEN_BRACKET);
        if (jj_2_22(1)) {
          e = constant_expression();
                  int elCount = (int) e.get_integral_constant_value() ;
                  TyArray arrayType = new TyArray( ) ;
                  arrayType.setNumberOfElements( elCount ) ;
                  type_link.addToEnd( arrayType ) ;
        } else {
              TyArray arrayType = new TyArray( ) ;
              arrayType.setNumberOfElements( -1 ) ;
              type_link.addToEnd( arrayType ) ;
        }
        jj_consume_token(CLOSE_BRACKET);
        break;
      case OPEN_PAREN:
        jj_consume_token(OPEN_PAREN);
                  pc.start_prototype_scope() ;
                  param_types = new Vector() ;
                  ends_with_ellipsis = new boolean[1] ;
        parameter_declaration_clause(param_types, ends_with_ellipsis);
              spec_set = new Cpp_SpecifierSet() ;
        jj_consume_token(CLOSE_PAREN);
                                             pc.end_prototype_scope() ;
        label_8:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case CONST:
          case VOLATILE:
            ;
            break;
          default:
            jj_la1[27] = jj_gen;
            break label_8;
          }
          cv_qualifier(spec_set);
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case THROW:
          exception_specification();
          break;
        default:
          jj_la1[28] = jj_gen;
          ;
        }
              TypeNode funType = new TyFun( param_types, ends_with_ellipsis[0] ) ;
              type_link.addToEnd( funType ) ;
        break;
      default:
        jj_la1[29] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      if (jj_2_23(2147483647)) {
        ;
      } else {
        break label_7;
      }
    }
  }

  final public void cv_qualifier(Cpp_SpecifierSet spec_set) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CONST:
      jj_consume_token(CONST);
                spec_set.add( Cpp_Specifiers.SP_CONST ) ;
      break;
    case VOLATILE:
      jj_consume_token(VOLATILE);
                 spec_set.add( Cpp_Specifiers.SP_VOLATILE ) ;
      break;
    default:
      jj_la1[30] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

// declarator_id --> id_expression
//                 | [ :: ] [ nested_name_specifier ] type_name
  final public ScopedName declarator_id() throws ParseException {
    ScopedName name ;
    ScopedName nm ;
    if (jj_2_25(2147483647)) {
          name = new Cpp_ScopedName() ;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SCOPE:
        jj_consume_token(SCOPE);
           name.set_absolute();
        break;
      default:
        jj_la1[31] = jj_gen;
        ;
      }
      if (jj_2_24(2147483647)) {
        nested_name_specifier(name);
      } else {
        ;
      }
      nm = type_name();
          name.append( nm ) ;
         {if (true) return name ;}
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SCOPE:
      case TILDE:
      case OPERATOR:
      case ID:
        name = id_exp();
         {if (true) return name ;}
        break;
      default:
        jj_la1[32] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

// type_id --> ( type_specifier )+ [ abstract_declarator ]
  final public TypeNode type_id() throws ParseException {
    Cpp_SpecifierSet spec_set = new Cpp_SpecifierSet() ;
    TypeNodeLink type_link = new TypeNodeLink() ;
    TypeNode base_type ;
    label_9:
    while (true) {
      type_specifier(spec_set);
      if (jj_2_26(1)) {
        ;
      } else {
        break label_9;
      }
    }
          base_type =  pc.extract_type(spec_set) ;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPEN_BRACKET:
    case OPEN_PAREN:
    case SCOPE:
    case AMPERSAND:
    case STAR:
    case ID:
      abstract_declarator(type_link);
              type_link.addToEnd( base_type ) ;
              {if (true) return type_link.get() ;}
      break;
    default:
      jj_la1[33] = jj_gen;
              {if (true) return base_type ;}
    }
    throw new Error("Missing return statement in function");
  }

  final public void abstract_declarator(TypeNodeLink type_link) throws ParseException {
  Cpp_SpecifierSet spec_set ;
  int k ;
  ScopedName name ;
    if (jj_2_27(2147483647)) {
              spec_set = new Cpp_SpecifierSet() ;
      k = ptr_operator(spec_set);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPEN_BRACKET:
      case OPEN_PAREN:
      case SCOPE:
      case AMPERSAND:
      case STAR:
      case ID:
        abstract_declarator(type_link);
        break;
      default:
        jj_la1[34] = jj_gen;
        ;
      }
              if( k == STAR ) {
                type_link.addToEnd( new TyPointer( spec_set ) ) ; }
              else if( k == AMPERSAND ) {
                type_link.addToEnd( new TyRef( ) ) ; }
              else {
                Assert.check( false ) ; }
    } else if (jj_2_28(2147483647)) {
      jj_consume_token(OPEN_PAREN);
      abstract_declarator(type_link);
      jj_consume_token(CLOSE_PAREN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPEN_BRACKET:
      case OPEN_PAREN:
        declarator_prime(type_link);
        break;
      default:
        jj_la1[35] = jj_gen;
        ;
      }
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPEN_BRACKET:
      case OPEN_PAREN:
        declarator_prime(type_link);
        break;
      default:
        jj_la1[36] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

// parameter_declaration_clause --> parameter_declaration parameter_declaration_clause_prime
//                                | ...
//                                | nothing
  final public void parameter_declaration_clause(Vector param_types, boolean[] ends_with_ellipsis) throws ParseException {
    TypeNode param_type ;
    if (jj_2_29(1)) {
      param_type = parameter_declaration();
          param_types.addElement( param_type ) ;
      parameter_declaration_clause_prime(param_types, ends_with_ellipsis);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ELLIPSIS:
        jj_consume_token(ELLIPSIS);
          ends_with_ellipsis[0] = true ;
        break;
      default:
        jj_la1[37] = jj_gen;

      }
    }
  }

// parameter_declaration_clause_prime --> "..." | "," "..." | empty
//                                     |  "," parameter_declaration parameter_declaration_clause_prime
  final public void parameter_declaration_clause_prime(Vector param_types, boolean[] ends_with_ellipsis) throws ParseException {
  TypeNode param_type ;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COMMA:
      jj_consume_token(COMMA);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ELLIPSIS:
        jj_consume_token(ELLIPSIS);
          ends_with_ellipsis[0] = true ;
        break;
      default:
        jj_la1[38] = jj_gen;
        if (jj_2_30(1)) {
          param_type = parameter_declaration();
              param_types.addElement( param_type ) ;
          parameter_declaration_clause_prime(param_types, ends_with_ellipsis);
        } else {
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      break;
    case ELLIPSIS:
      jj_consume_token(ELLIPSIS);
          ends_with_ellipsis[0] = true ;
      break;
    default:
      jj_la1[39] = jj_gen;

    }
  }

// parameter_declaration --> decl_specifier_seq [declarator | abstract_declarator] (= exp(1))?
  final public TypeNode parameter_declaration() throws ParseException {
  TypeNode base_type ;
  TypeNodeLink type_link = new TypeNodeLink();
  TypeNode type ;
  ScopedName name ;
  Cpp_SpecifierSet spec_set = new Cpp_SpecifierSet() ;
    decl_specifier_seq(spec_set);
              base_type =  pc.extract_type(spec_set) ;
    if (jj_2_31(2147483647)) {
      // This LOOKAHEAD used to be
                  //   "LOOKAHEAD( declarator() (<ASSIGN> | <COMMA> | <ELLIPSIS> | <CLOSE_PAREN>) )"
                  // I can't see the justification for the second part and it violates
                  // the guideline (see JavaCC FAQ) that lookahead should not extend
                  // past the choice it represents. So I'm eliminating the right concatenend.
                  // The look-ahead on declarator is needed because declarators and abstract
                  // declarators can look the same for arbitrary distance.
                  name = declarator(type_link);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPEN_BRACKET:
      case OPEN_PAREN:
      case SCOPE:
      case AMPERSAND:
      case STAR:
      case ID:
        abstract_declarator(type_link);
                  name = pc.anon_name() ;
        break;
      default:
        jj_la1[40] = jj_gen;
              name = pc.anon_name() ;
      }
    }
          type_link.addToEnd( base_type ) ;
          type = type_link.get() ;
          if( type instanceof TyArray ) {
            TypeNode eltType = ((TyArray)type).getElementType() ;
            type = new TyPointer() ;
            type.addToEnd( eltType ) ; }
          //else if( type instanceof TyFun ) {
          //  TypeNode temp = type ;
          //  type = new TyPointer() ;
          //  type.addToEnd( temp ) ; }

    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ASSIGN:
      jj_consume_token(ASSIGN);
      exp(1);
                  pc.sorry_not_implemented( "default parameter values" ) ;
      break;
    default:
      jj_la1[41] = jj_gen;
                  // Tell the parser context about the parameter declaration.
                  // This will be in prototype scope.
                  pc.parameter_declaration(getCoords(0), name, spec_set, type) ;
                  {if (true) return type ;}
    }
    throw new Error("Missing return statement in function");
  }

// member_function_definition -->
//     declarator more_function_definition
//  |
//   decl_specifier_seq declarator more_function_definition
// DEVIATION: This nonterminal is not in the ISO
  final public void member_function_definition() throws ParseException {
  ScopedName name ;
  Cpp_SpecifierSet spec_set = new Cpp_SpecifierSet() ;
  TypeNode base_type ;
  TypeNodeLink type_link = new TypeNodeLink() ;
          pc.warning_message("Function declared within a class. Forward references are not yet supported");
    if (jj_2_32(2147483647)) {
                  base_type =  pc.extract_type(spec_set) ;
      // WEIRD. Extract on empty spec_set
                  name = declarator(type_link);
                  type_link.addToEnd( base_type ) ;
      more_function_definition(true, name, type_link);
    } else if (jj_2_33(1)) {
      decl_specifier_seq(spec_set);
                  base_type =  pc.extract_type(spec_set) ;
      // !!! What if there is no type
                  name = declarator(type_link);
                  type_link.addToEnd( base_type ) ;
      more_function_definition(true, name, type_link);
    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void rest_of_function_definition(Cpp_SpecifierSet spec_set) throws ParseException {
  ScopedName name ;
  TypeNode base_type ;
  TypeNodeLink type_link = new TypeNodeLink() ;
          base_type =  pc.extract_type(spec_set) ;
    name = declarator(type_link);
          type_link.addToEnd( base_type ) ;
    more_function_definition(false, name, type_link);
  }

// more_function_definition -->
//    [ ctor_initializer ] compound_statement
// |
//    function_try_block
  final public void more_function_definition(boolean is_declared_within_class,
                               ScopedName name,
                               TypeNodeLink type_link) throws ParseException {
  StatementNodeLink  body_link  ;
  StatementNodeLink last_link ;
  SourceCoords coords ;
  Vector initializer_list = new Vector() ;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPEN_BRACE:
    case COLON:
      body_link = pc.new_function_defn( getCoords(0), name, type_link.get() ) ;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COLON:
        ctor_initializer(initializer_list);
        break;
      default:
        jj_la1[42] = jj_gen;
        ;
      }
      body_link = pc.constructor_initializer( initializer_list, body_link ) ;
      last_link = compound_statement(body_link);
      pc.end_function_defn( last_link, getCoords(0) ) ;
      break;
    case TRY:
      function_try_block();
      break;
    default:
      jj_la1[43] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

// initializer --> "=" initializer_clause | "(" expression_list ")"
  final public Initializer initializer() throws ParseException {
  Initializer i ;
  NodeList es  = new NodeList ();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ASSIGN:
      jj_consume_token(ASSIGN);
      i = initializer_clause();
          {if (true) return i ;}
      break;
    case OPEN_PAREN:
      jj_consume_token(OPEN_PAREN);
      expression_list(es);
      jj_consume_token(CLOSE_PAREN);
          {if (true) return new Initializer( Initializer.DIRECT, es ) ;}
      break;
    default:
      jj_la1[44] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

// initializer_clause --> exp(1) | "{" (initializer_clause ("," initializer_clause)* )? "}"
  final public Initializer initializer_clause() throws ParseException {
    ExpressionNode e ;
    if (jj_2_35(1)) {
      e = exp(1);
      {if (true) return new Initializer( Initializer.COPY, e ) ;}
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPEN_BRACE:
        jj_consume_token(OPEN_BRACE);
        if (jj_2_34(1)) {
          initializer_clause();
          label_10:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case COMMA:
              ;
              break;
            default:
              jj_la1[45] = jj_gen;
              break label_10;
            }
            jj_consume_token(COMMA);
            initializer_clause();
          }
        } else {
          ;
        }
        jj_consume_token(CLOSE_BRACE);
      pc.sorry_not_implemented( "initializer lists" ) ;
        break;
      default:
        jj_la1[46] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

/////////////////////////////////////////////
//             CLASSES                     //
/////////////////////////////////////////////


// class_specifier --> class_head { opt_member_specification }
  final public void class_specifier(Cpp_SpecifierSet spec_set) throws ParseException {
    ClassHead head ;
    StatementNodeLink p ;
    SourceCoords coords ;
      coords = getCoords(0) ;
    head = class_head();
         pc.add_class_declaration(  head ) ;
         pc.start_class_scope() ;
         p = new StatementNodeLink() ;
    jj_consume_token(OPEN_BRACE);
    opt_member_specification(head.get_key(), p);
    jj_consume_token(CLOSE_BRACE);
          coords = getCoords(0) ;
          pc.record_member_declarations(p, coords ) ;
          pc.end_class_scope() ;
          spec_set.add_type_name( head.get_name() ) ;
  }

// class_head --> (class|struct|union)
//                [ identifier
//                | nested_name_specifier identifier
//                | [nested_name_specifier] template_id
//                ]
//                opt_base_clause 
// DEVIATION: template_id is not allowed by the parser.
// DEVIATION: nested_name_specifiers are also not supported.
  final public ClassHead class_head() throws ParseException {
    int key ;
    ScopedName name = null;
    Vector base_specifier_list ;
    String id ;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CLASS:
      jj_consume_token(CLASS);
                 key = ClassHead.CLASS ;
      break;
    case STRUCT:
      jj_consume_token(STRUCT);
                 key = ClassHead.STRUCT ;
      break;
    case UNION:
      jj_consume_token(UNION);
                 key = ClassHead.UNION ;
                 pc.sorry_not_implemented( "union" ) ;
      break;
    default:
      jj_la1[47] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    if (jj_2_36(2147483647)) {
      nested_name_specifier(new Cpp_ScopedName());
      identifier();
         pc.sorry_not_implemented("nested_names_specifier in class head");
         base_specifier_list = null ;
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ID:
        id = identifier();
         name = new Cpp_ScopedName(id) ;
        base_specifier_list = opt_base_clause();
        break;
      default:
        jj_la1[48] = jj_gen;
         name = pc.unique_name() ;
        base_specifier_list = opt_base_clause();
      }
    }
      {if (true) return new ClassHead( key, name, base_specifier_list ) ;}
    throw new Error("Missing return statement in function");
  }

  final public void opt_member_specification(int key, StatementNodeLink p) throws ParseException {
    int access = (key == ClassHead.CLASS ? Cpp_Specifiers.SP_PRIVATE : Cpp_Specifiers.SP_PUBLIC) ;
    label_11:
    while (true) {
      if (jj_2_37(1)) {
        ;
      } else {
        break label_11;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PRIVATE:
        jj_consume_token(PRIVATE);
        jj_consume_token(COLON);
                              access = Cpp_Specifiers.SP_PRIVATE ;
        break;
      case PUBLIC:
        jj_consume_token(PUBLIC);
        jj_consume_token(COLON);
                              access = Cpp_Specifiers.SP_PUBLIC ;
        break;
      case PROTECTED:
        jj_consume_token(PROTECTED);
        jj_consume_token(COLON);
                              access = Cpp_Specifiers.SP_PROTECTED ;
        break;
      default:
        jj_la1[49] = jj_gen;
        if (jj_2_38(1)) {
          p = member_declaration(access, p);
        } else {
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
  }

  final public StatementNodeLink member_declaration(int access, StatementNodeLink p) throws ParseException {
    Cpp_SpecifierSet spec_set = new Cpp_SpecifierSet() ;
    ScopedName name ;
    if (jj_2_40(2147483647)) {
      // Then no decl_specifiers.  This is to avoid a problem with constructors.
                  // Consider a declaration "C();", if we tried to parse an
                  // opt_decl_specifier_seq, then the "C" would be gobbled up as
                  // a decl_specifier.
      
              p = opt_member_declarator_list(spec_set, p);
      jj_consume_token(SEMICOLON);
    } else if (jj_2_41(2147483647)) {
      decl_specifier_seq(spec_set);
              spec_set.add( access );
      p = opt_member_declarator_list(spec_set, p);
      jj_consume_token(SEMICOLON);
    } else if (jj_2_42(2147483647)) {
              pc.sorry_not_implemented( "changing access of parent members" ) ;
              name = new Cpp_ScopedName() ;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SCOPE:
        jj_consume_token(SCOPE);
                   name.set_absolute();
        break;
      default:
        jj_la1[50] = jj_gen;
        ;
      }
      nested_name_specifier(name);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TEMPLATE:
        jj_consume_token(TEMPLATE);
        break;
      default:
        jj_la1[51] = jj_gen;
        ;
      }
      unqualified_id();
      jj_consume_token(SEMICOLON);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case USING:
        using_declaration();
        break;
      case EXPORT:
      case TEMPLATE:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case EXPORT:
          jj_consume_token(EXPORT);
          break;
        default:
          jj_la1[52] = jj_gen;
          ;
        }
        jj_consume_token(TEMPLATE);
                                pc.sorry_not_implemented( "templates" ) ;
        break;
      default:
        jj_la1[53] = jj_gen;
        if (getToken(1).kind != CLOSE_BRACE) {
          member_function_definition();
          if (jj_2_39(2147483647)) {
            jj_consume_token(SEMICOLON);
          } else {
            ;
          }
        } else {
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
     {if (true) return p;}
    throw new Error("Missing return statement in function");
  }

// opt_member_declarator_list --> ( member_declarator (, member_declarator) )*
  final public StatementNodeLink opt_member_declarator_list(Cpp_SpecifierSet spec_set, StatementNodeLink p) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPEN_PAREN:
    case SCOPE:
    case COLON:
    case AMPERSAND:
    case STAR:
    case TILDE:
    case OPERATOR:
    case ID:
      p = member_declarator(spec_set, p);
      label_12:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[54] = jj_gen;
          break label_12;
        }
        jj_consume_token(COMMA);
        p = member_declarator(spec_set, p);
      }
      break;
    default:
      jj_la1[55] = jj_gen;
      ;
    }
          {if (true) return p;}
    throw new Error("Missing return statement in function");
  }

// member_declarator --> declarator [= constant_expression()]
//                     | identifier : constant_expression
// Minor deviation. In ISO [initializer] is [constant
  final public StatementNodeLink member_declarator(Cpp_SpecifierSet spec_set, StatementNodeLink p) throws ParseException {
  TypeNodeLink type_link = new TypeNodeLink() ;
  TypeNode base_type ;
  ExpressionNode e ;
  Initializer i ;
  ScopedName name ;
  StatementNodeLink q ;
  SourceCoords coords ;
    if (jj_2_43(2147483647)) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ID:
        identifier();
        break;
      default:
        jj_la1[56] = jj_gen;
        ;
      }
      jj_consume_token(COLON);
      constant_expression();
             pc.sorry_not_implemented("bit fields") ;
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPEN_PAREN:
      case SCOPE:
      case AMPERSAND:
      case STAR:
      case TILDE:
      case OPERATOR:
      case ID:
         coords = getCoords(0) ;
        name = declarator(type_link);
          base_type =  pc.extract_type(spec_set) ;
          type_link.addToEnd( base_type ) ;
          q = pc.simple_declaration( p, coords, name, spec_set, type_link.get() ) ;
          pc.start_initializer( name ) ;
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ASSIGN:
          jj_consume_token(ASSIGN);
          e = constant_expression();
              i = new Initializer( Initializer.COPY, e ) ;
          break;
        default:
          jj_la1[57] = jj_gen;
              i = new Initializer( Initializer.NONE ) ;
        }
          pc.end_initializer( i ) ;
         {if (true) return q;}
        break;
      default:
        jj_la1[58] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

////////////////////////////////////////
// Derived Classes                    //
////////////////////////////////////////

// opt_base_clause --> [ : base_specifier (, base_specifier)* ]
  final public Vector opt_base_clause() throws ParseException {
    Vector base_specifier_list = new Vector();
    Cpp_SpecifierSet spec_set ;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COLON:
      jj_consume_token(COLON);
      spec_set = base_specifier();
              base_specifier_list.addElement( spec_set ) ;
      label_13:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[59] = jj_gen;
          break label_13;
        }
        jj_consume_token(COMMA);
        spec_set = base_specifier();
                  base_specifier_list.addElement( spec_set ) ;
      }
      break;
    default:
      jj_la1[60] = jj_gen;
      ;
    }
          {if (true) return base_specifier_list ;}
    throw new Error("Missing return statement in function");
  }

// base_specifier --> virtual [access_specifier] scoped_class_name
//                  | [access_specifier] [virtual] scoped_class_name
  final public Cpp_SpecifierSet base_specifier() throws ParseException {
    Cpp_SpecifierSet spec_set = new Cpp_SpecifierSet() ;
    int access = Cpp_Specifiers.SP_PUBLIC ;
    ScopedName name ;
    boolean is_virtual = false ;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case VIRTUAL:
      jj_consume_token(VIRTUAL);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PRIVATE:
      case PROTECTED:
      case PUBLIC:
        access = access_specifier();
        break;
      default:
        jj_la1[61] = jj_gen;
        ;
      }
      name = scoped_class_name();
             is_virtual = true ;
      break;
    case PRIVATE:
    case PROTECTED:
    case PUBLIC:
      access = access_specifier();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case VIRTUAL:
        jj_consume_token(VIRTUAL);
                     is_virtual = true ;
        break;
      default:
        jj_la1[62] = jj_gen;
        ;
      }
      name = scoped_class_name();
      break;
    case SCOPE:
    case ID:
      name = scoped_class_name();
      break;
    default:
      jj_la1[63] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        spec_set.add( access ) ;
        if( is_virtual ) spec_set.add( Cpp_Specifiers.SP_VIRTUAL ) ;
        spec_set.add_type_name( name ) ;
    {if (true) return spec_set;}
    throw new Error("Missing return statement in function");
  }

// access_specifier --> private | public | protected
  final public int access_specifier() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PRIVATE:
      jj_consume_token(PRIVATE);
                 {if (true) return Cpp_Specifiers.SP_PRIVATE;}
      break;
    case PUBLIC:
      jj_consume_token(PUBLIC);
                 {if (true) return Cpp_Specifiers.SP_PUBLIC;}
      break;
    case PROTECTED:
      jj_consume_token(PROTECTED);
                 {if (true) return Cpp_Specifiers.SP_PROTECTED;}
      break;
    default:
      jj_la1[64] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

//  Special Member functions  //
////////////////////////////////

// conversion_function_id --> operator conversion_type_id
  final public ScopedName conversion_function_id() throws ParseException {
    jj_consume_token(OPERATOR);
    conversion_type_id();
          pc.sorry_not_implemented("Conversion function identifiers") ;
          {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

// conversion_type_id --> ( type_specifier )+ (ptr_operator)*
  final public void conversion_type_id() throws ParseException {
  Cpp_SpecifierSet spec_set = new Cpp_SpecifierSet() ;
    label_14:
    while (true) {
      type_specifier(spec_set);
      if (jj_2_44(1)) {
        ;
      } else {
        break label_14;
      }
    }
    label_15:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SCOPE:
      case AMPERSAND:
      case STAR:
      case ID:
        ;
        break;
      default:
        jj_la1[65] = jj_gen;
        break label_15;
      }
      ptr_operator(spec_set);
    }
  }

  final public void ctor_initializer(Vector initializer_list) throws ParseException {
    ConstructorInitializer ctor_init ;
    jj_consume_token(COLON);
    ctor_init = mem_initializer();
                                   initializer_list.addElement( ctor_init ) ;
    label_16:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[66] = jj_gen;
        break label_16;
      }
      jj_consume_token(COMMA);
      ctor_init = mem_initializer();
                                       initializer_list.addElement( ctor_init ) ;
    }
  }

  final public ConstructorInitializer mem_initializer() throws ParseException {
    ScopedName name ;
    Initializer init ;
    NodeList nl = new NodeList ();
    // DEVIATION:  The standard says that a mem_initializer_id is
        //   mem-initializer-id --> scoped_class_name | identifier
        // where scoped_class_name --> [ "::" ] [ nested-name-specifier ] class-name
        // but the first choice includes the second (we don't check that the class-name is
        // a class name).  So we use only the first choice
        name = scoped_class_name();
    jj_consume_token(OPEN_PAREN);
    opt_expression_list(nl);
    jj_consume_token(CLOSE_PAREN);
      init = new Initializer( Initializer.DIRECT, nl ) ;
      {if (true) return new ConstructorInitializer( name, init ) ;}
    throw new Error("Missing return statement in function");
  }

// Overloading //
/////////////////

// operator_function_id --> "operator" operator
  final public ScopedName operator_function_id() throws ParseException {
  int opcode ;
    jj_consume_token(OPERATOR);
    opcode = operator();
         {if (true) return pc.operator_to_name( opcode ) ;}
    throw new Error("Missing return statement in function");
  }

// operator --> many things
  final public int operator() throws ParseException {
    int opcode ;
    Token t ;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NEW:
      jj_consume_token(NEW);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPEN_BRACKET:
        jj_consume_token(OPEN_BRACKET);
        jj_consume_token(CLOSE_BRACKET);
                                                           opcode = -1 ;
        break;
      default:
        jj_la1[67] = jj_gen;
                                              opcode = NEW ;
      }
      break;
    case DELETE:
      jj_consume_token(DELETE);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPEN_BRACKET:
        jj_consume_token(OPEN_BRACKET);
        jj_consume_token(CLOSE_BRACKET);
                                                           opcode = -2 ;
        break;
      default:
        jj_la1[68] = jj_gen;
                                              opcode = DELETE ;
      }
      break;
    case ARROW:
      jj_consume_token(ARROW);
                                              opcode = ARROW ;
      break;
    case OPEN_PAREN:
      jj_consume_token(OPEN_PAREN);
      jj_consume_token(CLOSE_PAREN);
                                                           opcode = OPEN_PAREN ;
      break;
    case OPEN_BRACKET:
      jj_consume_token(OPEN_BRACKET);
      jj_consume_token(CLOSE_BRACKET);
                                                           opcode = OPEN_BRACKET ;
      break;
    default:
      jj_la1[69] = jj_gen;
      if (jj_2_45(2147483647)) {
        // Need lookahead spec since "-" is both binary and unary.
                opcode = unary_op();
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
        case ASSIGN:
        case STARASSIGN:
        case SLASHASSIGN:
        case PERCENTASSIGN:
        case PLUSASSIGN:
        case MINUSASSIGN:
        case SHIFTLEFTASSIGN:
        case SHIFTRIGHTASSIGN:
        case BITWISEANDASSIGN:
        case BITWISEXORASSIGN:
        case BITWISEORASSIGN:
        case OR:
        case AND:
        case BITWISEOR:
        case BITWISEXOR:
        case AMPERSAND:
        case EQUAL:
        case NOTEQUAL:
        case LESSTHAN:
        case GREATERTHAN:
        case LESSTHANOREQUALTO:
        case GREATERTHANOREQUALTO:
        case SHIFTLEFT:
        case SHIFTRIGHT:
        case PLUS:
        case MINUS:
        case STAR:
        case SLASH:
        case PERCENT:
        case DOTSTAR:
        case ARROWSTAR:
          opcode = binary_op();
          break;
        default:
          jj_la1[70] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
      {if (true) return opcode ;}
    throw new Error("Missing return statement in function");
  }

////////////////
//  Templates //
////////////////

// template_declaration --> [export] template < template_parameter ( "," template_parameter)* > declaration
//void template_declaration() :
//{}
//{
//    [ <EXPORT> ] <TEMPLATE>
//    <LESSTHAN> template_parameter() ( "," template_parameter())* <GREATERTHAN> declaration()
//}

// template_id is not used elsewhere in the parser, because you really need a template declaration
// first, in order to recognize the syntax.

// explicit_instantiation --> "template" declaration
// DEVIATION. explicit declarations are not complete
//void explicit_instantiation() :
//{}
//{
//    <TEMPLATE>
//        { pc.sorry_not_implemented( "templates" ) ; }
//    declaration()
//}

// explicit_specialization --> "template" "<" ">" declaration
// DEVIATION. explicit specializations are not complete
//void explicit_specialization() :
//{}
//{
//    <TEMPLATE> <LESSTHAN> <GREATERTHAN>
//    declaration()
//}

////////////////////////
// Exception Handling //
////////////////////////

// function_try_block --> try  [ctor_initializer] function_body handler_seq
// DEVIATION. This is incomplete
  final public void function_try_block() throws ParseException {
    jj_consume_token(TRY);
          pc.sorry_not_implemented( "function try blocks" ) ;
  }

// handler_seq --> (  catch"(" exception_declaration ")" compound_statement )+
  final public void handler_seq() throws ParseException {
    StatementNodeLink p = new StatementNodeLink() ;
    StatementNodeLink q ;
    label_17:
    while (true) {
      jj_consume_token(CATCH);
      jj_consume_token(OPEN_PAREN);
      exception_declaration();
      jj_consume_token(CLOSE_PAREN);
      q = compound_statement(p);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CATCH:
        ;
        break;
      default:
        jj_la1[71] = jj_gen;
        break label_17;
      }
    }
  }

// exception_declaration --> (type_specifier)+ declarator
//                         | (type_specifier)+ abstract_declarator
//                         | (type_specifier)+
//                         | "..."
  final public void exception_declaration() throws ParseException {
    Cpp_SpecifierSet spec_set = new Cpp_SpecifierSet() ;
    TypeNodeLink type_link = new TypeNodeLink() ;
    if (jj_2_48(1)) {
      label_18:
      while (true) {
        type_specifier(spec_set);
        if (jj_2_46(1)) {
          ;
        } else {
          break label_18;
        }
      }
      if (jj_2_47(2147483647)) {
        declarator(type_link);
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case OPEN_BRACKET:
        case OPEN_PAREN:
        case SCOPE:
        case AMPERSAND:
        case STAR:
        case ID:
          abstract_declarator(type_link);
          break;
        default:
          jj_la1[72] = jj_gen;

        }
      }
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ELLIPSIS:
        jj_consume_token(ELLIPSIS);
        break;
      default:
        jj_la1[73] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

// exception_specification --> "throw" "(" [ type_id ( "," type_id )* ] ")"
  final public void exception_specification() throws ParseException {
    jj_consume_token(THROW);
    jj_consume_token(OPEN_PAREN);
    if (jj_2_49(1)) {
      type_id();
      label_19:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[74] = jj_gen;
          break label_19;
        }
        jj_consume_token(COMMA);
        type_id();
      }
    } else {
      ;
    }
    jj_consume_token(CLOSE_PAREN);
  }

//////////////////////////////////////////////////////////////
// Statements
//////////////////////////////////////////////////////////////

// statement --> Many things
  final public StatementNodeLink statement(StatementNodeLink p) throws ParseException {
  StatDo ddo ;
  StatBranch branch ;
  StatJoin looptop ;
  StatJoin exit ;
  StatJoin contin ;
  StatementNodeLink q, r ;
  ExpressionNode e ;
  SourceCoords coords ;
  int varDepth = pc.get_current_var_depth() ;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TRY:
      jj_consume_token(TRY);
      p = compound_statement(p);
      handler_seq();
             pc.sorry_not_implemented( "exceptions");
      break;
    case BREAK:
      jj_consume_token(BREAK);
      jj_consume_token(SEMICOLON);
              coords = getCoords(0) ;
              pc.makeBreak( p, coords, varDepth ) ;
              {if (true) return new StatementNodeLink() ;}
      break;
    case CONTINUE:
      jj_consume_token(CONTINUE);
      jj_consume_token(SEMICOLON);
              coords = getCoords(0) ;
              pc.makeContinue( p, coords, varDepth ) ;
              {if (true) return new StatementNodeLink() ;}
      break;
    case RETURN:
      jj_consume_token(RETURN);
      e = opt_exp();
      jj_consume_token(SEMICOLON);
              coords = getCoords(0) ;
              pc.makeReturn( p, coords, varDepth, e ) ;
              {if (true) return new StatementNodeLink() ;}
      break;
    case GOTO:
      jj_consume_token(GOTO);
      identifier();
      jj_consume_token(SEMICOLON);
              pc.sorry_not_implemented( "goto" ) ;
              {if (true) return p ;}
      break;
    case OPEN_BRACE:
      // COMPOUND Statement
              p = compound_statement(p);
              {if (true) return p;}
      break;
    default:
      jj_la1[76] = jj_gen;
      if (jj_2_50(2147483647)) {
        jj_consume_token(SEMICOLON);
             {if (true) return p ;}
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IF:
          jj_consume_token(IF);
              coords = getCoords(0) ;
              p = pc.start_local_scope(p, coords) ;
          jj_consume_token(OPEN_PAREN);
          e = condition();
          jj_consume_token(CLOSE_PAREN);
              e = pc.coerce_to_bool( e ) ;
              branch = new StatBranch( coords, varDepth, e ) ;
              p.set( branch ) ; p = branch.onTrue() ;
              p = pc.start_local_scope(p, coords) ;
          p = statement(p);
              coords = getCoords(0) ;
              p = pc.end_local_scope(p, coords) ;
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case ELSE:
            jj_consume_token(ELSE);
                      r = pc.start_local_scope( branch.onFalse(), coords ) ;
            r = statement(r);
                      coords = getCoords(0) ;
                      r = pc.end_local_scope(r, coords) ;
                      exit = new StatJoin( coords, varDepth ) ;
                      p.set( exit ) ; r.set( exit ) ;
            break;
          default:
            jj_la1[75] = jj_gen;
                      coords = getCoords(1) ;
                      exit = new StatJoin( coords, varDepth ) ;
                      p.set( exit ) ; branch.onFalse().set( exit ) ;
          }
                {if (true) return pc.end_local_scope(exit.next(), coords) ;}
          break;
        case SWITCH:
          jj_consume_token(SWITCH);
                coords = getCoords(0) ;
                exit = new StatJoin( coords, varDepth ) ;
                p = pc.startBreakRegion( p, coords, varDepth, false ) ;
                pc.setBreakTarget( exit ) ;
                p = pc.start_local_scope(p, coords) ;
          jj_consume_token(OPEN_PAREN);
          e = condition();
          jj_consume_token(CLOSE_PAREN);
                e = pc.coerce_to_integral( e ) ;
                pc.startSwitchStatement( p, coords, varDepth, e, exit ) ;
          p = statement(new StatementNodeLink());
              p = pc.end_local_scope(p, getCoords(0) ) ;
              pc.endSwitchStatement() ;
              p = pc.endBreakRegion( p, coords, varDepth, false ) ;
              p.set( exit ) ;
              {if (true) return exit.next() ;}
          break;
        case CASE:
              coords = getCoords(1) ;
          jj_consume_token(CASE);
          e = constant_expression();
          jj_consume_token(COLON);
              pc.addCaseToSwitch( p, varDepth, e ) ;
          p = statement(p);
              {if (true) return p ;}
          break;
        case KEYWORD_DEFAULT:
              coords = getCoords(1) ;
          jj_consume_token(KEYWORD_DEFAULT);
          jj_consume_token(COLON);
              pc.addDefaultToSwitch( p, varDepth ) ;
          p = statement(p);
              {if (true) return p ;}
          break;
        case WHILE:
          jj_consume_token(WHILE);
                coords = getCoords(0) ;
                looptop = new StatJoin( coords, varDepth ) ;
                p.set( looptop ) ; p = looptop.next() ;

                exit = new StatJoin( coords, varDepth ) ;

                p = pc.startBreakRegion( p, coords, varDepth, true ) ;
                pc.setBreakTarget( exit ) ;
                pc.setContinueTarget( looptop ) ;
                p = pc.start_local_scope(p, coords) ;
          jj_consume_token(OPEN_PAREN);
          e = condition();
          jj_consume_token(CLOSE_PAREN);
                e = pc.coerce_to_bool( e ) ;
                varDepth = pc.get_current_var_depth() ;
                branch = new StatBranch( coords, varDepth, e ) ;
                p.set( branch ) ; p = branch.onTrue() ;

                // On false, execute a break.
                int varDepth1 = pc.get_current_var_depth() ;
                pc.makeBreak( branch.onFalse(), coords, varDepth1 ) ;
          p = statement(p);
                coords = getCoords(0) ;
                p = pc.end_local_scope( p, coords) ;
                p = pc.endBreakRegion( p, coords, varDepth, true ) ;
                p.set( looptop ) ;
                {if (true) return exit.next() ;}
          break;
        case DO:
                coords = getCoords(1) ;
          jj_consume_token(DO);
                looptop = new StatJoin( coords, varDepth ) ;
                exit = new StatJoin( coords, varDepth ) ;
                contin = new StatJoin( coords, varDepth ) ;
                p.set( looptop ) ; p = looptop.next() ;
                p = pc.startBreakRegion( p, coords, varDepth, true ) ;
                pc.setBreakTarget( exit ) ;
                pc.setContinueTarget( contin ) ;
                p = pc.start_local_scope( p, coords ) ;
          p = statement(p);
                coords = getCoords(1) ;
                p = pc.end_local_scope(p, coords) ;
                p = pc.endBreakRegion( p, coords, varDepth, true ) ;
                p.set( contin ) ;
                p = contin.next() ;
          jj_consume_token(WHILE);
          jj_consume_token(OPEN_PAREN);
          e = expression();
          jj_consume_token(CLOSE_PAREN);
          jj_consume_token(SEMICOLON);
                e = pc.coerce_to_bool( e ) ;
                branch = new StatBranch( coords, varDepth, e ) ;
                p.set( branch ) ;
                branch.onTrue().set( looptop ) ;
                branch.onFalse().set( exit ) ;
                {if (true) return exit.next() ;}
          break;
        case FOR:
          jj_consume_token(FOR);
          jj_consume_token(OPEN_PAREN);
          p = more_for(p);
                {if (true) return p ;}
          break;
        default:
          jj_la1[77] = jj_gen;
          if (jj_2_51(2147483647)) {
            identifier();
            jj_consume_token(COLON);
            p = statement(p);
              pc.sorry_not_implemented("goto") ;
          } else if (jj_2_52(2147483647)) {
            p = block_declaration_with_nonopt_decl_spec(p);
              {if (true) return p ;}
          } else if (jj_2_53(1)) {
            // EXPRESSION Statement
                    e = expression();
              coords = getCoords(0) ;
            jj_consume_token(SEMICOLON);
              ddo = new StatDo(coords, varDepth, e) ;
              p.set( ddo ) ;
              {if (true) return ddo.next() ;}
          } else {
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
      }
    }
    throw new Error("Missing return statement in function");
  }

// more_for --> simple_declaration_with_nonopt_decl_spec opt_exp ";" opt_exp ")" statement
//            | opt_exp ";" opt_exp ";" opt_exp ")" statement
  final public StatementNodeLink more_for(StatementNodeLink p) throws ParseException {
  ExpressionNode e0, e1, e2 ;
  StatDo s0, s2;
  StatJoin exit, contin, looptop ;
  StatBranch branch ;
  SourceCoords coords = getCoords(0) ; ;
  NodeList ds ;
  int varDepth ;
          p = pc.start_local_scope(p, coords) ;
          varDepth = pc.get_current_var_depth() ;
    if (jj_2_54(2147483647)) {
                    coords = getCoords(1) ;
      p = simple_declaration_with_nonopt_decl_spec(p);
    } else if (jj_2_55(1)) {
                      coords = getCoords(1) ;
      e0 = opt_exp();
      jj_consume_token(SEMICOLON);
                  s0 = new StatDo( coords, varDepth, e0 ) ;
                  p.set( s0 ) ;
                  p = s0.next() ;
    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
          varDepth = pc.get_current_var_depth() ;
          coords = getCoords(1) ;
          looptop = new StatJoin( coords, varDepth ) ;
          p.set( looptop ) ; p = looptop.next() ;

          exit = new StatJoin( coords, varDepth ) ;
          contin = new StatJoin( coords, varDepth ) ;

          p = pc.startBreakRegion( p, coords, varDepth, true ) ;
          pc.setBreakTarget( exit ) ;
          pc.setContinueTarget( contin ) ;
          p = pc.start_local_scope(p, coords) ;
    e1 = opt_condition();
    jj_consume_token(SEMICOLON);
          e1 = pc.coerce_to_bool( e1 ) ;
          varDepth = pc.get_current_var_depth() ;
          branch = new StatBranch( coords, varDepth, e1 ) ;
          p.set( branch ) ; p = branch.onTrue() ;

          // On false, execute a break.
          int varDepth1 = pc.get_current_var_depth() ;
          pc.makeBreak( branch.onFalse(), coords, varDepth1 ) ;
          coords = getCoords(1) ;
    e2 = opt_exp();
    jj_consume_token(CLOSE_PAREN);
          s2 = new StatDo( coords, varDepth, e2 ) ;
    p = statement(p);
          coords = getCoords(0) ;
          p.set( contin ) ; p = contin.next() ;
          p.set( s2 ) ; p = s2.next() ;
          p = pc.end_local_scope(p, coords) ;
          p = pc.endBreakRegion( p, coords, varDepth, true ) ;
          p.set( looptop ) ; p = exit.next() ;
          // Remember that code generated by next statement goes after exit
          p = pc.end_local_scope(p, coords) ;
          {if (true) return p ;}
    throw new Error("Missing return statement in function");
  }

// opt_condition  --> condition | empty
  final public ExpressionNode opt_condition() throws ParseException {
  ExpressionNode e ;
    if (jj_2_56(1)) {
      e = condition();
          {if (true) return e ;}
    } else {
          {if (true) return noExp_node ;}
    }
    throw new Error("Missing return statement in function");
  }

// condition --> expression | (type_specifier)+  declarator = exp(1)
  final public ExpressionNode condition() throws ParseException {
    Cpp_SpecifierSet spec_set = new Cpp_SpecifierSet() ;
    TypeNodeLink type_link = new TypeNodeLink() ;
    TypeNode base_type ;
    ExpressionNode e ;
    ScopedName name ;
    if (jj_2_58(2147483647)) {
      label_20:
      while (true) {
        type_specifier(spec_set);
        if (jj_2_57(1)) {
          ;
        } else {
          break label_20;
        }
      }
             base_type =  pc.extract_type(spec_set) ;
      name = declarator(type_link);
             type_link.addToEnd( base_type ) ;
      jj_consume_token(ASSIGN);
      e = exp(1);
            {if (true) return new DeclarationExpNd( type_link.get(), name, e ) ;}
    } else if (jj_2_59(1)) {
      e = expression();
          {if (true) return e ;}
    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

// opt_exp  --> expression | empty
  final public ExpressionNode opt_exp() throws ParseException {
  ExpressionNode e ;
    if (jj_2_60(1)) {
      e = expression();
          {if (true) return e ;}
    } else {
          {if (true) return noExp_node ;}
    }
    throw new Error("Missing return statement in function");
  }

// compound_statement --> "{" statement_list "}"
  final public StatementNodeLink compound_statement(StatementNodeLink p) throws ParseException {
    jj_consume_token(OPEN_BRACE);
                                        p = pc.start_local_scope(p, getCoords(0)) ;
    label_21:
    while (true) {
      if (jj_2_61(1)) {
        ;
      } else {
        break label_21;
      }
      p = statement(p);
    }
    jj_consume_token(CLOSE_BRACE);
                                        p = pc.end_local_scope(p, getCoords(0)) ;
                                        {if (true) return p ;}
    throw new Error("Missing return statement in function");
  }

//////////////////////////////////////////////////////////////
// Expressions
//////////////////////////////////////////////////////////////

// The algorithm for expressions is an efficient, compact, and flexible method.
//   I first saw this method described by Keith Clarke of Imperial College.
//
//   See http://www.engr.mun.ca/~theo/Misc#ExpParse for a more detailed description.
//
//   The idea is to parse expressions in a loop using recursion only
//   as necessary.  For example in parsing
//      a * b - c * d - e/f <<  g + h
//       --- ---     ---   ----
//   the underlined operators are parsed at the top level.
//   The sub expressions a, b, c*d, e/f, and g+h are parsed with
//   recursive calls.
//
//   To make this work we use a subroutine exp(p) that parses expressions that
//   have no exposed operators of precedence lower than p. If a lower precedence
//   operator is found, then the subroutine just returns.
//
//   The right argument of each operator (binary or unary) is parsed
//   by exp(p+1) where p is the precedence of the operator. (Or exp(p)
//   for right associative binary operators)
  final public ExpressionNode constant_expression() throws ParseException {
  ExpressionNode x ;
    x = exp(0);
            x = pc.coerce_to_integral( x ) ;
            Assert.apology( x.is_integral_constant(), "Integral constant required." ) ;
            if( Debug.getInstance().isOn() ) {
                Debug.getInstance().msg(Debug.COMPILE, "Constant expression vvvvvvvvvvvvvv") ;
                Debug.getInstance().msg(Debug.COMPILE, x.ppToString(3, 80) ) ;
                Debug.getInstance().msg(Debug.COMPILE, "^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^") ; }
            {if (true) return x ;}
    throw new Error("Missing return statement in function");
  }

  final public ExpressionNode expression() throws ParseException {
  ExpressionNode x ;
    x = exp(0);
            if( Debug.getInstance().isOn() ) {
                Debug.getInstance().msg(Debug.COMPILE, "Expression vvvvvvvvvvvvvv") ;
                Debug.getInstance().msg(Debug.COMPILE, x.ppToString(3, 80) ) ;
                Debug.getInstance().msg(Debug.COMPILE, "^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^") ; }
         {if (true) return x ;}
    throw new Error("Missing return statement in function");
  }

//   exp --> unary ( binary_op exp | "?" exp ":" exp )*
  final public ExpressionNode exp(int minPrec) throws ParseException {
  int prec ;
  int op ;
  ExpressionNode x, y, z ;
    x = cast_exp();
    label_22:
    while (true) {
      if (binary_ops[ getToken(1).kind ] >= minPrec) {
        ;
      } else {
        break label_22;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
      case ASSIGN:
      case STARASSIGN:
      case SLASHASSIGN:
      case PERCENTASSIGN:
      case PLUSASSIGN:
      case MINUSASSIGN:
      case SHIFTLEFTASSIGN:
      case SHIFTRIGHTASSIGN:
      case BITWISEANDASSIGN:
      case BITWISEXORASSIGN:
      case BITWISEORASSIGN:
      case OR:
      case AND:
      case BITWISEOR:
      case BITWISEXOR:
      case AMPERSAND:
      case EQUAL:
      case NOTEQUAL:
      case LESSTHAN:
      case GREATERTHAN:
      case LESSTHANOREQUALTO:
      case GREATERTHANOREQUALTO:
      case SHIFTLEFT:
      case SHIFTRIGHT:
      case PLUS:
      case MINUS:
      case STAR:
      case SLASH:
      case PERCENT:
      case DOTSTAR:
      case ARROWSTAR:
        op = binary_op();
                          int tableVal = binary_ops[ op ] ;
                          if( right_assoc[ op ] ) {
                                prec = tableVal ; }
                          else {
                                prec = 1 + tableVal ; }
        y = exp(prec);
                          x = pc.make_bin_op(op, x, y) ;
        break;
      case QUESTIONMARK:
        jj_consume_token(QUESTIONMARK);
        y = expression();
        jj_consume_token(COLON);
        z = exp(2);
                          x = pc.make_conditional_exp(x, y, z) ;
        break;
      default:
        jj_la1[78] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
          {if (true) return x ;}
    throw new Error("Missing return statement in function");
  }

// cast_exp --> "(" type_id ")" cast_exp | unary_exp
  final public ExpressionNode cast_exp() throws ParseException {
    ExpressionNode x ;
    TypeNode type ;
    if (jj_2_62(2147483647)) {
      jj_consume_token(OPEN_PAREN);
      type = type_id();
      jj_consume_token(CLOSE_PAREN);
      x = cast_exp();
      {if (true) return pc.make_cast_exp( type, x ) ;}
    } else if (jj_2_63(1)) {
      x = unary_exp();
     {if (true) return x ;}
    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

// unary_exp --> unary_op cast_exp
//             | "sizeof" "(" type_id ")"
//             | "sizeof" unary_exp
//             | new_exp
//             | delete_exp
//             | postfix_exp
  final public ExpressionNode unary_exp() throws ParseException {
  ExpressionNode x ;
  int op ;
  TypeNode type ;
    if (jj_2_66(2147483647)) {
      // This lookahead is only to suppress a
                                      // pointless warning that arises because
                                      // ~classname is technically a postfix expression
                                      // even though is is never semantically allowed.
              op = unary_op();
      x = cast_exp();
          {if (true) return pc.make_unary_op( op, x ) ;}
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SIZEOF:
        jj_consume_token(SIZEOF);
        if (jj_2_64(2147483647)) {
          jj_consume_token(OPEN_PAREN);
          type = type_id();
          jj_consume_token(CLOSE_PAREN);
              {if (true) return pc.make_sizeof_type_exp( type ) ;}
        } else if (jj_2_65(1)) {
          x = unary_exp();
             {if (true) return pc.make_sizeof_value( x ) ;}
        } else {
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[79] = jj_gen;
        if (jj_2_67(2147483647)) {
          x = new_exp();
      {if (true) return x ;}
        } else if (jj_2_68(2147483647)) {
          x = delete_exp();
     {if (true) return x;}
        } else if (jj_2_69(1)) {
          x = postfix_exp();
     {if (true) return x;}
        } else {
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public int unary_op() throws ParseException {
  Token t ;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PLUSPLUS:
      t = jj_consume_token(PLUSPLUS);
      break;
    case MINUSMINUS:
      t = jj_consume_token(MINUSMINUS);
      break;
    case TILDE:
      t = jj_consume_token(TILDE);
      break;
    case BANG:
      t = jj_consume_token(BANG);
      break;
    case MINUS:
      t = jj_consume_token(MINUS);
      break;
    case PLUS:
      t = jj_consume_token(PLUS);
      break;
    case AMPERSAND:
      t = jj_consume_token(AMPERSAND);
      break;
    case STAR:
      t = jj_consume_token(STAR);
      break;
    default:
      jj_la1[80] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
          {if (true) return t.kind;}
    throw new Error("Missing return statement in function");
  }

  final public int binary_op() throws ParseException {
  Token t ;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DOTSTAR:
      t = jj_consume_token(DOTSTAR);
      break;
    case ARROWSTAR:
      t = jj_consume_token(ARROWSTAR);
      break;
    case STAR:
      t = jj_consume_token(STAR);
      break;
    case SLASH:
      t = jj_consume_token(SLASH);
      break;
    case PERCENT:
      t = jj_consume_token(PERCENT);
      break;
    case PLUS:
      t = jj_consume_token(PLUS);
      break;
    case MINUS:
      t = jj_consume_token(MINUS);
      break;
    case SHIFTLEFT:
      t = jj_consume_token(SHIFTLEFT);
      break;
    case SHIFTRIGHT:
      t = jj_consume_token(SHIFTRIGHT);
      break;
    case LESSTHAN:
      t = jj_consume_token(LESSTHAN);
      break;
    case LESSTHANOREQUALTO:
      t = jj_consume_token(LESSTHANOREQUALTO);
      break;
    case GREATERTHAN:
      t = jj_consume_token(GREATERTHAN);
      break;
    case GREATERTHANOREQUALTO:
      t = jj_consume_token(GREATERTHANOREQUALTO);
      break;
    case EQUAL:
      t = jj_consume_token(EQUAL);
      break;
    case NOTEQUAL:
      t = jj_consume_token(NOTEQUAL);
      break;
    case AMPERSAND:
      t = jj_consume_token(AMPERSAND);
      break;
    case BITWISEXOR:
      t = jj_consume_token(BITWISEXOR);
      break;
    case BITWISEOR:
      t = jj_consume_token(BITWISEOR);
      break;
    case AND:
      t = jj_consume_token(AND);
      break;
    case OR:
      t = jj_consume_token(OR);
      break;
    case ASSIGN:
      t = jj_consume_token(ASSIGN);
      break;
    case STARASSIGN:
      t = jj_consume_token(STARASSIGN);
      break;
    case SLASHASSIGN:
      t = jj_consume_token(SLASHASSIGN);
      break;
    case PERCENTASSIGN:
      t = jj_consume_token(PERCENTASSIGN);
      break;
    case PLUSASSIGN:
      t = jj_consume_token(PLUSASSIGN);
      break;
    case MINUSASSIGN:
      t = jj_consume_token(MINUSASSIGN);
      break;
    case SHIFTLEFTASSIGN:
      t = jj_consume_token(SHIFTLEFTASSIGN);
      break;
    case SHIFTRIGHTASSIGN:
      t = jj_consume_token(SHIFTRIGHTASSIGN);
      break;
    case BITWISEANDASSIGN:
      t = jj_consume_token(BITWISEANDASSIGN);
      break;
    case BITWISEORASSIGN:
      t = jj_consume_token(BITWISEORASSIGN);
      break;
    case BITWISEXORASSIGN:
      t = jj_consume_token(BITWISEXORASSIGN);
      break;
    case COMMA:
      t = jj_consume_token(COMMA);
      break;
    default:
      jj_la1[81] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
          {if (true) return t.kind ;}
    throw new Error("Missing return statement in function");
  }

// new_exp -->  (::)? "new" ("(" expression_list ")")? (new_type_id | <OPEN_PAREN> type_id <CLOSE_PAREN>)
//              ("(" opt_expression_list ")" )?
// NOTE: The placement part is recognized, but otherwise ignored.
// until the TM supports exceptions, new will return 0 when out of space regardless of
// the placement specification.
  final public ExpressionNode new_exp() throws ParseException {
  NodeList placement = new NodeList() ;
  NodeList initializer = null ;
  boolean has_initializer = false ;
  TypeNodeLink type_link = new TypeNodeLink() ;
  ExpressionNode flexible_dimension = null;
  TypeNode type = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SCOPE:
      jj_consume_token(SCOPE);
      break;
    default:
      jj_la1[82] = jj_gen;
      ;
    }
    jj_consume_token(NEW);
    if (jj_2_70(2147483647)) {
      jj_consume_token(OPEN_PAREN);
      expression_list(placement);
      jj_consume_token(CLOSE_PAREN);
    } else {
      ;
    }
    if (jj_2_71(1)) {
      flexible_dimension = new_type_id(type_link);
              type = type_link.get() ;
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPEN_PAREN:
        jj_consume_token(OPEN_PAREN);
        type = type_id();
        jj_consume_token(CLOSE_PAREN);
              flexible_dimension = noExp_node ;
        break;
      default:
        jj_la1[83] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPEN_PAREN:
      jj_consume_token(OPEN_PAREN);
              initializer = new NodeList() ;
              has_initializer = true ;
      opt_expression_list(initializer);
      jj_consume_token(CLOSE_PAREN);
      break;
    default:
      jj_la1[84] = jj_gen;

    }
          {if (true) return pc.make_new_exp( type,
                                  flexible_dimension,
                                  placement,
                                  has_initializer,
                                  initializer ) ;}
    throw new Error("Missing return statement in function");
  }

//  new_type_id --> (type_specifier)+ [new_declarator]
// Returns the flexible dimension or a NoExpNd if there is none
  final public ExpressionNode new_type_id(TypeNodeLink type_link) throws ParseException {
    Cpp_SpecifierSet spec_set = new Cpp_SpecifierSet() ;
    TypeNode base_type ;
    ExpressionNode x ;
    label_23:
    while (true) {
      type_specifier(spec_set);
      if (jj_2_72(1)) {
        ;
      } else {
        break label_23;
      }
    }
          base_type = pc.extract_type(spec_set) ;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPEN_BRACKET:
    case SCOPE:
    case AMPERSAND:
    case STAR:
    case ID:
      x = new_declarator(type_link);
              type_link.addToEnd( base_type ) ;
              {if (true) return x ;}
      break;
    default:
      jj_la1[85] = jj_gen;
              type_link.set(base_type) ;
              {if (true) return noExp_node ;}
    }
    throw new Error("Missing return statement in function");
  }

// new_declarator -->  ptr_operator [new_declarator]
//                  |  new_declarator_prime
// Returns the flexible dimension or a NoExpNd if there is none
  final public ExpressionNode new_declarator(TypeNodeLink type_link) throws ParseException {
  Cpp_SpecifierSet spec_set ;
  ExpressionNode x ;
  int k ;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SCOPE:
    case AMPERSAND:
    case STAR:
    case ID:
          spec_set = new Cpp_SpecifierSet() ;
      k = ptr_operator(spec_set);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPEN_BRACKET:
      case SCOPE:
      case AMPERSAND:
      case STAR:
      case ID:
        x = new_declarator(type_link);
        break;
      default:
        jj_la1[86] = jj_gen;
            x = noExp_node;
      }
          if( k == STAR ) {
            type_link.addToEnd( new TyPointer( spec_set ) ) ; }
          else if( k == AMPERSAND ) {
            type_link.addToEnd( new TyRef( ) ) ; }
          else {
            Assert.check( false ) ; }
          {if (true) return x ;}
      break;
    case OPEN_BRACKET:
      x = new_declarator_prime(type_link);
         {if (true) return x;}
      break;
    default:
      jj_la1[87] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

// new_declaractor_prime --> "[" expression "]" ( "[" expression "]" )*
// Returns the flexible dimension or a NoExpNd if there is none
  final public ExpressionNode new_declarator_prime(TypeNodeLink type_link) throws ParseException {
  ExpressionNode flexible_dimension ;
  ExpressionNode inflexible_dimension ;
    jj_consume_token(OPEN_BRACKET);
    flexible_dimension = expression();
    jj_consume_token(CLOSE_BRACKET);
    label_24:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPEN_BRACKET:
        ;
        break;
      default:
        jj_la1[88] = jj_gen;
        break label_24;
      }
      jj_consume_token(OPEN_BRACKET);
      inflexible_dimension = constant_expression();
      jj_consume_token(CLOSE_BRACKET);
                  int elCount = (int) inflexible_dimension.get_integral_constant_value() ;
                  TyArray arrayType = new TyArray(  ) ;
                  arrayType.setNumberOfElements( elCount ) ;
                  type_link.addToEnd( arrayType ) ;
    }
      {if (true) return flexible_dimension ;}
    throw new Error("Missing return statement in function");
  }

  final public ExpressionNode delete_exp() throws ParseException {
    ExpressionNode x ;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SCOPE:
      jj_consume_token(SCOPE);
      break;
    default:
      jj_la1[89] = jj_gen;
      ;
    }
    jj_consume_token(DELETE);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPEN_BRACKET:
      jj_consume_token(OPEN_BRACKET);
      jj_consume_token(CLOSE_BRACKET);
      x = cast_exp();
         {if (true) return pc.make_delete_array_exp( x ) ;}
      break;
    default:
      jj_la1[90] = jj_gen;
      if (jj_2_73(1)) {
        x = cast_exp();
         {if (true) return pc.make_delete_exp( x ) ;}
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public ExpressionNode postfix_exp() throws ParseException {
    ExpressionNode x = null;
    TypeNode type = null;
    ScopedName name ;
    ExpressionNode y ;
    Cpp_SpecifierSet spec_set = null;
    NodeList arg_list ;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TYPENAME:
      jj_consume_token(TYPENAME);
             pc.sorry_not_implemented( "typename" );
      break;
    case DYNAMIC_CAST:
      jj_consume_token(DYNAMIC_CAST);
      jj_consume_token(LESSTHAN);
      type = type_id();
      jj_consume_token(GREATERTHAN);
      jj_consume_token(OPEN_PAREN);
      x = expression();
      jj_consume_token(CLOSE_PAREN);
             x = pc.make_dynamic_cast_exp( type, x ) ;
      break;
    case STATIC_CAST:
      jj_consume_token(STATIC_CAST);
      jj_consume_token(LESSTHAN);
      type = type_id();
      jj_consume_token(GREATERTHAN);
      jj_consume_token(OPEN_PAREN);
      x = expression();
      jj_consume_token(CLOSE_PAREN);
             x = pc.make_static_cast_exp( type, x ) ;
      break;
    case REINTERPRET_CAST:
      jj_consume_token(REINTERPRET_CAST);
      jj_consume_token(LESSTHAN);
      type = type_id();
      jj_consume_token(GREATERTHAN);
      jj_consume_token(OPEN_PAREN);
      x = expression();
      jj_consume_token(CLOSE_PAREN);
             x = pc.make_reinterpret_cast_exp( type, x ) ;
      break;
    case CONST_CAST:
      jj_consume_token(CONST_CAST);
      jj_consume_token(LESSTHAN);
      type = type_id();
      jj_consume_token(GREATERTHAN);
      jj_consume_token(OPEN_PAREN);
      x = expression();
      jj_consume_token(CLOSE_PAREN);
             x = pc.make_const_cast_exp( type, x ) ;
      break;
    case TYPEID:
      jj_consume_token(TYPEID);
      jj_consume_token(TYPENAME);
             pc.sorry_not_implemented( "typeid" );
      break;
    default:
      jj_la1[91] = jj_gen;
      if (jj_2_74(1)) {
              spec_set = new Cpp_SpecifierSet() ;
              arg_list = new NodeList() ;
        simple_type_specifier(spec_set);
        jj_consume_token(OPEN_PAREN);
        opt_expression_list(arg_list);
        jj_consume_token(CLOSE_PAREN);
              type = pc.extract_type(spec_set) ;
              x = pc.make_explicit_conversion( type, arg_list ) ;
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case OPEN_PAREN:
        case SCOPE:
        case TILDE:
        case FALSE:
        case OPERATOR:
        case THIS:
        case TRUE:
        case OCTALINT:
        case DECIMALINT:
        case HEXINT:
        case FLOATCONST:
        case CHARACTER:
        case STRING:
        case ID:
          x = primary_exp();
          break;
        default:
          jj_la1[92] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
    label_25:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPEN_BRACKET:
      case OPEN_PAREN:
      case PLUSPLUS:
      case MINUSMINUS:
      case DOT:
      case ARROW:
        ;
        break;
      default:
        jj_la1[93] = jj_gen;
        break label_25;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUSPLUS:
        jj_consume_token(PLUSPLUS);
                  x = pc.make_postfix_exp( PLUSPLUS, x ) ;
        break;
      case MINUSMINUS:
        jj_consume_token(MINUSMINUS);
                  x = pc.make_postfix_exp( MINUSMINUS, x ) ;
        break;
      case DOT:
        jj_consume_token(DOT);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case TEMPLATE:
          jj_consume_token(TEMPLATE);
                          pc.sorry_not_implemented("templates") ;
          break;
        default:
          jj_la1[94] = jj_gen;
          ;
        }
        // DEVIATION: I am not supporting calls to psuedo destructors
                    name = id_exp();
                  x = pc.make_member_exp(x, name) ;
        break;
      case ARROW:
        jj_consume_token(ARROW);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case TEMPLATE:
          jj_consume_token(TEMPLATE);
                          pc.sorry_not_implemented("templates") ;
          break;
        default:
          jj_la1[95] = jj_gen;
          ;
        }
        // DEVIATION: I am not supporting calls to psuedo destructors
                    name = id_exp();
                  x = pc.make_arrow_exp(x, name) ;
        break;
      case OPEN_BRACKET:
        jj_consume_token(OPEN_BRACKET);
        y = expression();
        jj_consume_token(CLOSE_BRACKET);
                  x = pc.make_bin_op( OPEN_BRACKET, x, y ) ;
        break;
      case OPEN_PAREN:
        jj_consume_token(OPEN_PAREN);
                  arg_list = new NodeList() ;
        opt_expression_list(arg_list);
        jj_consume_token(CLOSE_PAREN);
                  x = pc.make_function_call_exp( x, arg_list ) ;
        break;
      default:
        jj_la1[96] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
      {if (true) return x ;}
    throw new Error("Missing return statement in function");
  }

// opt_expression_list --> ( exp(1) ( "," exp(1) )*
  final public void expression_list(NodeList list) throws ParseException {
  ExpressionNode e ;
    e = exp(1);
               list.addLastChild( e ) ;
    label_26:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[97] = jj_gen;
        break label_26;
      }
      jj_consume_token(COMMA);
      e = exp(1);
                        list.addLastChild( e ) ;
    }
  }

// opt_expression_list --> ( expression_list )?
  final public void opt_expression_list(NodeList list) throws ParseException {
  ExpressionNode e ;
    if (jj_2_75(1)) {
      expression_list(list);
    } else {
      ;
    }
  }

// primary_exp --> "(" expression ")" | "this" | id_exp | literal
  final public ExpressionNode primary_exp() throws ParseException {
  ExpressionNode x ;
  ScopedName name ;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPEN_PAREN:
      jj_consume_token(OPEN_PAREN);
      x = expression();
      jj_consume_token(CLOSE_PAREN);
         {if (true) return pc.make_paren_exp( x ) ;}
      break;
    case THIS:
      jj_consume_token(THIS);
         {if (true) return pc.make_this_exp() ;}
      break;
    case SCOPE:
    case TILDE:
    case OPERATOR:
    case ID:
      name = id_exp();
         {if (true) return pc.make_id_exp( name ) ;}
      break;
    case FALSE:
    case TRUE:
    case OCTALINT:
    case DECIMALINT:
    case HEXINT:
    case FLOATCONST:
    case CHARACTER:
    case STRING:
      x = literal();
          {if (true) return x ;}
      break;
    default:
      jj_la1[98] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

// id_exp --> qualified_id | unqualified_id
  final public ScopedName id_exp() throws ParseException {
    ScopedName name ;
    if (jj_2_76(2147483647)) {
      name = qualified_id();
     {if (true) return name ;}
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TILDE:
      case OPERATOR:
      case ID:
        name = unqualified_id();
     {if (true) return name ;}
        break;
      default:
        jj_la1[99] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

// unqualified_id --> identifier | operator_function_id | conversion_function_id
//                  | "~" class_name | template_id
// DEVIATION. template_id is not recognized by the parser.
  final public ScopedName unqualified_id() throws ParseException {
    ScopedName name ;
    String id ;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ID:
      id = identifier();
          name = new Cpp_ScopedName( id ) ;
          {if (true) return name ;}
      break;
    case TILDE:
      jj_consume_token(TILDE);
      name = class_name();
          pc.name_to_destructor_name( name ) ;
          {if (true) return name ;}
      break;
    default:
      jj_la1[100] = jj_gen;
      if (jj_2_77(2)) {
        name = operator_function_id();
         {if (true) return name ;}
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case OPERATOR:
          name = conversion_function_id();
         {if (true) return name ;}
          break;
        default:
          jj_la1[101] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
    throw new Error("Missing return statement in function");
  }

// qualified_id --> nested_name_specifier ("template")? unqualified_id
//                | :: nested_name_specifier ("template")? unqualified_id
//                | :: identifier
//                | :: operator_function_id
//                | :: template_id
// DEVIATION: template_id is not supported
  final public ScopedName qualified_id() throws ParseException {
    ScopedName nm;
    ScopedName name = new Cpp_ScopedName();
    String id ;
    if (jj_2_80(2147483647)) {
      nested_name_specifier(name);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TEMPLATE:
        jj_consume_token(TEMPLATE);
         pc.sorry_not_implemented( "templates" ) ;
        break;
      default:
        jj_la1[102] = jj_gen;

      }
      nm = unqualified_id();
          name.append( nm ) ;
          {if (true) return name ;}
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SCOPE:
        jj_consume_token(SCOPE);
        if (jj_2_78(2147483647)) {
              name.set_absolute() ;
          nested_name_specifier(name);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case TEMPLATE:
            jj_consume_token(TEMPLATE);
               pc.sorry_not_implemented( "templates" ) ;
            break;
          default:
            jj_la1[103] = jj_gen;

          }
          nm = unqualified_id();
              name.append( nm ) ;
              {if (true) return name ;}
        } else {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case ID:
            id = identifier();
              name = new Cpp_ScopedName( id ) ;
              name.set_absolute() ;
              {if (true) return name ;}
            break;
          default:
            jj_la1[104] = jj_gen;
            if (jj_2_79(2)) {
              name = operator_function_id();
              name.set_absolute() ;
             {if (true) return name ;}
            } else {
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
        }
        break;
      default:
        jj_la1[105] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

// literal --> OCTALINT | DECIMALINT | HEXINT | FLOAT | CHARACTER
//              | STRING |TRUE | FALSE
// DEVIATION. Multiple string constants not supported. E.g. "abc" "def" "ghi"
// (Actually this is not a deviation, since the ISO std defines that catentation
// to be an earlier preprocessing step. But it makes sense to fold it into
// phase 4.)
  final public ExpressionNode literal() throws ParseException {
 Token t ;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OCTALINT:
      t = jj_consume_token(OCTALINT);
             {if (true) return pc.make_octal_const(t.image) ;}
      break;
    case DECIMALINT:
      t = jj_consume_token(DECIMALINT);
             {if (true) return pc.make_decimal_const(t.image) ;}
      break;
    case HEXINT:
      t = jj_consume_token(HEXINT);
             {if (true) return pc.make_hex_const(t.image) ;}
      break;
    case FLOATCONST:
      t = jj_consume_token(FLOATCONST);
             {if (true) return  pc.make_float_const(t.image) ;}
      break;
    case CHARACTER:
      t = jj_consume_token(CHARACTER);
             {if (true) return pc.make_char_const(t.image) ;}
      break;
    case STRING:
      t = jj_consume_token(STRING);
             {if (true) return pc.make_string_const(t.image) ;}
      break;
    case TRUE:
      t = jj_consume_token(TRUE);
             {if (true) return pc.make_bool_const(true) ;}
      break;
    case FALSE:
      t = jj_consume_token(FALSE);
             {if (true) return pc.make_bool_const(false) ;}
      break;
    default:
      jj_la1[106] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public String identifier() throws ParseException {
    Token t ;
    t = jj_consume_token(ID);
          {if (true) return pc.id_table.inter( t.image ) ;}
    throw new Error("Missing return statement in function");
  }

// nested_name_specifier --> class_or_namespace_name :: [template] nested_name_specifier
//                         | class_or_namespace_name :: nested_name_specifier?
  final public void nested_name_specifier(ScopedName name) throws ParseException {
    ScopedName nm ;
    nm = class_or_namespace_name();
          name.append( nm ) ;
    jj_consume_token(SCOPE);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TEMPLATE:
      jj_consume_token(TEMPLATE);
                      pc.sorry_not_implemented( "templates" ) ;
      break;
    default:
      jj_la1[107] = jj_gen;
      if (jj_2_81(2147483647)) {
        nested_name_specifier(name);
      } else {

      }
    }
  }

// class_or_namespace_name --> class_name | namespace_name
// namespace_name --> original_namespace_name |  namespace_alias
// original_namespace_name --> identifier
// namespace_alias --> identifier
// DEVIATION. Since I'm not dealing with namespaces just yet,
// I'm going to assume that we only have class names.
  final public ScopedName class_or_namespace_name() throws ParseException {
    ScopedName name ;
    name = class_name();
         {if (true) return name;}
    throw new Error("Missing return statement in function");
  }

// scoped_class_name --> ("::")? (nested_name_specifier)? class_name
  final public ScopedName scoped_class_name() throws ParseException {
    ScopedName nm ;
    ScopedName name = new Cpp_ScopedName() ;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SCOPE:
      jj_consume_token(SCOPE);
                            name.set_absolute() ;
      break;
    default:
      jj_la1[108] = jj_gen;
      ;
    }
    if (jj_2_82(2147483647)) {
      nested_name_specifier(name);
    } else {
      ;
    }
    nm = class_name();
                            name.append( nm ) ;
     {if (true) return name ;}
    throw new Error("Missing return statement in function");
  }

// scoped_type_name --> ("::")? (nested_name_specifier)? type_name
//                    | ("::")? nested_name_specifier "template" template_id
// DEVIATION. I am not supporting template_ids.
  final public ScopedName scoped_type_name() throws ParseException {
    ScopedName nm ;
    ScopedName name = new Cpp_ScopedName() ;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SCOPE:
      jj_consume_token(SCOPE);
                            name.set_absolute() ;
      break;
    default:
      jj_la1[109] = jj_gen;
      ;
    }
    if (jj_2_83(2147483647)) {
      nested_name_specifier(name);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TEMPLATE:
        jj_consume_token(TEMPLATE);
             pc.sorry_not_implemented( "templates" ) ;
        break;
      case ID:
        nm = type_name();
            name.append( nm ) ;
            {if (true) return name;}
        break;
      default:
        jj_la1[110] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ID:
        nm = type_name();
           name.append( nm ) ;
           {if (true) return name;}
        break;
      default:
        jj_la1[111] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

// scoped_identifier --> ("::")? (nested_name_specifier)? identifier
  final public ScopedName scoped_identifier() throws ParseException {
    String id ;
    ScopedName nm ;
    ScopedName name = new Cpp_ScopedName() ;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SCOPE:
      jj_consume_token(SCOPE);
            name.set_absolute() ;
      break;
    default:
      jj_la1[112] = jj_gen;
      ;
    }
    if (jj_2_84(2147483647)) {
      nested_name_specifier(name);
    } else {
      ;
    }
    id = identifier();
         nm = new Cpp_ScopedName( id ) ;
         name.append( nm ) ;
         {if (true) return name;}
    throw new Error("Missing return statement in function");
  }

  final public ScopedName class_name() throws ParseException {
    String id ;
    // First alternative is omitted, since templates are not supported.
        //LOOKAHEAD( template_id() )
        //template_id()
    //|
        id = identifier();
          {if (true) return new Cpp_ScopedName( id ) ;}
    throw new Error("Missing return statement in function");
  }

  final public ScopedName type_name() throws ParseException {
    String id ;
    id = identifier();
          {if (true) return new Cpp_ScopedName( id ) ;}
    throw new Error("Missing return statement in function");
  }

  private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  private boolean jj_2_5(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_5(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(4, xla); }
  }

  private boolean jj_2_6(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_6(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(5, xla); }
  }

  private boolean jj_2_7(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_7(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(6, xla); }
  }

  private boolean jj_2_8(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_8(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(7, xla); }
  }

  private boolean jj_2_9(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_9(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(8, xla); }
  }

  private boolean jj_2_10(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_10(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(9, xla); }
  }

  private boolean jj_2_11(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_11(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(10, xla); }
  }

  private boolean jj_2_12(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_12(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(11, xla); }
  }

  private boolean jj_2_13(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_13(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(12, xla); }
  }

  private boolean jj_2_14(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_14(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(13, xla); }
  }

  private boolean jj_2_15(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_15(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(14, xla); }
  }

  private boolean jj_2_16(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_16(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(15, xla); }
  }

  private boolean jj_2_17(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_17(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(16, xla); }
  }

  private boolean jj_2_18(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_18(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(17, xla); }
  }

  private boolean jj_2_19(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_19(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(18, xla); }
  }

  private boolean jj_2_20(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_20(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(19, xla); }
  }

  private boolean jj_2_21(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_21(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(20, xla); }
  }

  private boolean jj_2_22(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_22(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(21, xla); }
  }

  private boolean jj_2_23(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_23(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(22, xla); }
  }

  private boolean jj_2_24(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_24(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(23, xla); }
  }

  private boolean jj_2_25(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_25(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(24, xla); }
  }

  private boolean jj_2_26(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_26(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(25, xla); }
  }

  private boolean jj_2_27(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_27(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(26, xla); }
  }

  private boolean jj_2_28(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_28(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(27, xla); }
  }

  private boolean jj_2_29(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_29(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(28, xla); }
  }

  private boolean jj_2_30(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_30(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(29, xla); }
  }

  private boolean jj_2_31(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_31(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(30, xla); }
  }

  private boolean jj_2_32(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_32(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(31, xla); }
  }

  private boolean jj_2_33(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_33(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(32, xla); }
  }

  private boolean jj_2_34(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_34(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(33, xla); }
  }

  private boolean jj_2_35(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_35(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(34, xla); }
  }

  private boolean jj_2_36(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_36(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(35, xla); }
  }

  private boolean jj_2_37(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_37(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(36, xla); }
  }

  private boolean jj_2_38(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_38(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(37, xla); }
  }

  private boolean jj_2_39(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_39(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(38, xla); }
  }

  private boolean jj_2_40(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_40(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(39, xla); }
  }

  private boolean jj_2_41(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_41(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(40, xla); }
  }

  private boolean jj_2_42(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_42(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(41, xla); }
  }

  private boolean jj_2_43(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_43(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(42, xla); }
  }

  private boolean jj_2_44(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_44(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(43, xla); }
  }

  private boolean jj_2_45(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_45(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(44, xla); }
  }

  private boolean jj_2_46(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_46(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(45, xla); }
  }

  private boolean jj_2_47(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_47(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(46, xla); }
  }

  private boolean jj_2_48(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_48(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(47, xla); }
  }

  private boolean jj_2_49(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_49(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(48, xla); }
  }

  private boolean jj_2_50(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_50(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(49, xla); }
  }

  private boolean jj_2_51(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_51(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(50, xla); }
  }

  private boolean jj_2_52(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_52(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(51, xla); }
  }

  private boolean jj_2_53(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_53(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(52, xla); }
  }

  private boolean jj_2_54(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_54(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(53, xla); }
  }

  private boolean jj_2_55(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_55(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(54, xla); }
  }

  private boolean jj_2_56(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_56(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(55, xla); }
  }

  private boolean jj_2_57(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_57(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(56, xla); }
  }

  private boolean jj_2_58(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_58(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(57, xla); }
  }

  private boolean jj_2_59(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_59(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(58, xla); }
  }

  private boolean jj_2_60(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_60(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(59, xla); }
  }

  private boolean jj_2_61(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_61(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(60, xla); }
  }

  private boolean jj_2_62(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_62(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(61, xla); }
  }

  private boolean jj_2_63(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_63(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(62, xla); }
  }

  private boolean jj_2_64(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_64(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(63, xla); }
  }

  private boolean jj_2_65(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_65(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(64, xla); }
  }

  private boolean jj_2_66(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_66(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(65, xla); }
  }

  private boolean jj_2_67(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_67(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(66, xla); }
  }

  private boolean jj_2_68(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_68(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(67, xla); }
  }

  private boolean jj_2_69(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_69(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(68, xla); }
  }

  private boolean jj_2_70(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_70(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(69, xla); }
  }

  private boolean jj_2_71(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_71(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(70, xla); }
  }

  private boolean jj_2_72(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_72(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(71, xla); }
  }

  private boolean jj_2_73(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_73(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(72, xla); }
  }

  private boolean jj_2_74(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_74(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(73, xla); }
  }

  private boolean jj_2_75(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_75(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(74, xla); }
  }

  private boolean jj_2_76(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_76(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(75, xla); }
  }

  private boolean jj_2_77(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_77(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(76, xla); }
  }

  private boolean jj_2_78(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_78(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(77, xla); }
  }

  private boolean jj_2_79(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_79(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(78, xla); }
  }

  private boolean jj_2_80(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_80(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(79, xla); }
  }

  private boolean jj_2_81(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_81(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(80, xla); }
  }

  private boolean jj_2_82(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_82(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(81, xla); }
  }

  private boolean jj_2_83(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_83(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(82, xla); }
  }

  private boolean jj_2_84(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_84(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(83, xla); }
  }

  private boolean jj_3R_162() {
    if (jj_scan_token(SIZEOF)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_307()) {
    jj_scanpos = xsp;
    if (jj_3_65()) return true;
    }
    return false;
  }

  private boolean jj_3_42() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(22)) jj_scanpos = xsp;
    if (jj_3R_53()) return true;
    xsp = jj_scanpos;
    if (jj_scan_token(112)) jj_scanpos = xsp;
    if (jj_3R_59()) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3R_132() {
    if (jj_3R_201()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(24)) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_70() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_161()) {
    jj_scanpos = xsp;
    if (jj_3R_162()) {
    jj_scanpos = xsp;
    if (jj_3R_163()) {
    jj_scanpos = xsp;
    if (jj_3R_164()) {
    jj_scanpos = xsp;
    if (jj_3_69()) return true;
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_161() {
    if (jj_3R_61()) return true;
    if (jj_3R_73()) return true;
    return false;
  }

  private boolean jj_3R_131() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(84)) jj_scanpos = xsp;
    if (jj_scan_token(TEMPLATE)) return true;
    return false;
  }

  private boolean jj_3R_130() {
    if (jj_3R_179()) return true;
    return false;
  }

  private boolean jj_3R_200() {
    if (jj_scan_token(SCOPE)) return true;
    return false;
  }

  private boolean jj_3_41() {
    if (jj_3R_50()) return true;
    if (jj_3R_58()) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3R_129() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_200()) jj_scanpos = xsp;
    if (jj_3R_53()) return true;
    xsp = jj_scanpos;
    if (jj_scan_token(112)) jj_scanpos = xsp;
    if (jj_3R_59()) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3R_39() {
    if (jj_3R_63()) return true;
    return false;
  }

  private boolean jj_3_40() {
    if (jj_3R_58()) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3_62() {
    if (jj_scan_token(OPEN_PAREN)) return true;
    if (jj_3R_62()) return true;
    if (jj_scan_token(CLOSE_PAREN)) return true;
    return false;
  }

  private boolean jj_3R_128() {
    if (jj_3R_50()) return true;
    if (jj_3R_58()) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3_63() {
    if (jj_3R_70()) return true;
    return false;
  }

  private boolean jj_3R_211() {
    if (jj_scan_token(QUESTIONMARK)) return true;
    if (jj_3R_65()) return true;
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_52()) return true;
    return false;
  }

  private boolean jj_3R_37() {
    Token xsp;
    xsp = jj_scanpos;
    jj_lookingAhead = true;
    jj_semLA = pc.lookahead_scoped_type_name_follows(this);
    jj_lookingAhead = false;
    if (!jj_semLA || jj_3R_95()) {
    jj_scanpos = xsp;
    if (jj_3R_96()) {
    jj_scanpos = xsp;
    if (jj_3R_97()) {
    jj_scanpos = xsp;
    if (jj_3R_98()) {
    jj_scanpos = xsp;
    if (jj_3R_99()) {
    jj_scanpos = xsp;
    if (jj_3R_100()) {
    jj_scanpos = xsp;
    if (jj_3R_101()) {
    jj_scanpos = xsp;
    if (jj_3R_102()) {
    jj_scanpos = xsp;
    if (jj_3R_103()) {
    jj_scanpos = xsp;
    if (jj_3R_104()) {
    jj_scanpos = xsp;
    if (jj_3R_105()) {
    jj_scanpos = xsp;
    if (jj_3R_106()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_95() {
    if (jj_3R_192()) return true;
    return false;
  }

  private boolean jj_3_16() {
    if (jj_scan_token(ENUM)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_39()) jj_scanpos = xsp;
    if (jj_scan_token(OPEN_BRACE)) return true;
    return false;
  }

  private boolean jj_3R_127() {
    if (jj_3R_58()) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3R_73() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_173()) {
    jj_scanpos = xsp;
    if (jj_3_63()) return true;
    }
    return false;
  }

  private boolean jj_3R_173() {
    if (jj_scan_token(OPEN_PAREN)) return true;
    if (jj_3R_62()) return true;
    if (jj_scan_token(CLOSE_PAREN)) return true;
    if (jj_3R_73()) return true;
    return false;
  }

  private boolean jj_3R_94() {
    if (jj_3R_191()) return true;
    return false;
  }

  private boolean jj_3_15() {
    if (jj_3R_38()) return true;
    if (jj_scan_token(OPEN_BRACE)) return true;
    return false;
  }

  private boolean jj_3R_93() {
    if (jj_3R_190()) return true;
    return false;
  }

  private boolean jj_3R_57() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_127()) {
    jj_scanpos = xsp;
    if (jj_3R_128()) {
    jj_scanpos = xsp;
    if (jj_3R_129()) {
    jj_scanpos = xsp;
    if (jj_3R_130()) {
    jj_scanpos = xsp;
    if (jj_3R_131()) {
    jj_scanpos = xsp;
    jj_lookingAhead = true;
    jj_semLA = getToken(1).kind != CLOSE_BRACE;
    jj_lookingAhead = false;
    if (!jj_semLA || jj_3R_132()) return true;
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_210() {
    if (jj_3R_264()) return true;
    if (jj_3R_52()) return true;
    return false;
  }

  private boolean jj_3R_92() {
    if (jj_3R_189()) return true;
    return false;
  }

  private boolean jj_3_38() {
    if (jj_3R_57()) return true;
    return false;
  }

  private boolean jj_3R_56() {
    if (jj_scan_token(PROTECTED)) return true;
    if (jj_scan_token(COLON)) return true;
    return false;
  }

  private boolean jj_3R_55() {
    if (jj_scan_token(PUBLIC)) return true;
    if (jj_scan_token(COLON)) return true;
    return false;
  }

  private boolean jj_3R_91() {
    if (jj_3R_188()) return true;
    return false;
  }

  private boolean jj_3R_54() {
    if (jj_scan_token(PRIVATE)) return true;
    if (jj_scan_token(COLON)) return true;
    return false;
  }

  private boolean jj_3_37() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_54()) {
    jj_scanpos = xsp;
    if (jj_3R_55()) {
    jj_scanpos = xsp;
    if (jj_3R_56()) {
    jj_scanpos = xsp;
    if (jj_3_38()) return true;
    }
    }
    }
    return false;
  }

  private boolean jj_3R_36() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_14()) {
    jj_scanpos = xsp;
    if (jj_3R_91()) {
    jj_scanpos = xsp;
    if (jj_3R_92()) {
    jj_scanpos = xsp;
    if (jj_3R_93()) {
    jj_scanpos = xsp;
    if (jj_3R_94()) return true;
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3_14() {
    if (jj_3R_37()) return true;
    return false;
  }

  private boolean jj_3R_172() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_210()) {
    jj_scanpos = xsp;
    if (jj_3R_211()) return true;
    }
    return false;
  }

  private boolean jj_3R_281() {
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_37()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_233() {
    if (jj_scan_token(EXPLICIT)) return true;
    return false;
  }

  private boolean jj_3R_232() {
    if (jj_scan_token(VIRTUAL)) return true;
    return false;
  }

  private boolean jj_3R_112() {
    if (jj_3R_193()) return true;
    return false;
  }

  private boolean jj_3R_231() {
    if (jj_scan_token(INLINE)) return true;
    return false;
  }

  private boolean jj_3R_187() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_231()) {
    jj_scanpos = xsp;
    if (jj_3R_232()) {
    jj_scanpos = xsp;
    if (jj_3R_233()) return true;
    }
    }
    return false;
  }

  private boolean jj_3_36() {
    if (jj_3R_53()) return true;
    return false;
  }

  private boolean jj_3R_52() {
    if (jj_3R_73()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_172()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_111() {
    if (jj_3R_63()) return true;
    if (jj_3R_193()) return true;
    return false;
  }

  private boolean jj_3R_230() {
    if (jj_scan_token(MUTABLE)) return true;
    return false;
  }

  private boolean jj_3R_229() {
    if (jj_scan_token(EXTERN)) return true;
    return false;
  }

  private boolean jj_3R_228() {
    if (jj_scan_token(STATIC)) return true;
    return false;
  }

  private boolean jj_3R_227() {
    if (jj_scan_token(REGISTER)) return true;
    return false;
  }

  private boolean jj_3R_110() {
    if (jj_3R_53()) return true;
    if (jj_3R_63()) return true;
    return false;
  }

  private boolean jj_3R_186() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_226()) {
    jj_scanpos = xsp;
    if (jj_3R_227()) {
    jj_scanpos = xsp;
    if (jj_3R_228()) {
    jj_scanpos = xsp;
    if (jj_3R_229()) {
    jj_scanpos = xsp;
    if (jj_3R_230()) return true;
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_226() {
    if (jj_scan_token(AUTO)) return true;
    return false;
  }

  private boolean jj_3R_109() {
    if (jj_scan_token(UNION)) return true;
    return false;
  }

  private boolean jj_3R_108() {
    if (jj_scan_token(STRUCT)) return true;
    return false;
  }

  private boolean jj_3R_90() {
    if (jj_scan_token(TYPEDEF)) return true;
    return false;
  }

  private boolean jj_3R_107() {
    if (jj_scan_token(CLASS)) return true;
    return false;
  }

  private boolean jj_3R_65() {
    if (jj_3R_52()) return true;
    return false;
  }

  private boolean jj_3R_89() {
    if (jj_scan_token(FRIEND)) return true;
    return false;
  }

  private boolean jj_3R_38() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_107()) {
    jj_scanpos = xsp;
    if (jj_3R_108()) {
    jj_scanpos = xsp;
    if (jj_3R_109()) return true;
    }
    }
    xsp = jj_scanpos;
    if (jj_3R_110()) {
    jj_scanpos = xsp;
    if (jj_3R_111()) {
    jj_scanpos = xsp;
    if (jj_3R_112()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_88() {
    if (jj_3R_187()) return true;
    return false;
  }

  private boolean jj_3_13() {
    if (jj_3R_36()) return true;
    return false;
  }

  private boolean jj_3R_35() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_87()) {
    jj_scanpos = xsp;
    if (jj_3_13()) {
    jj_scanpos = xsp;
    if (jj_3R_88()) {
    jj_scanpos = xsp;
    if (jj_3R_89()) {
    jj_scanpos = xsp;
    if (jj_3R_90()) return true;
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_87() {
    if (jj_3R_186()) return true;
    return false;
  }

  private boolean jj_3R_342() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_51()) return true;
    return false;
  }

  private boolean jj_3R_44() {
    if (jj_3R_52()) return true;
    return false;
  }

  private boolean jj_3_12() {
    if (jj_3R_35()) return true;
    return false;
  }

  private boolean jj_3R_50() {
    Token xsp;
    if (jj_3_12()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_12()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_188() {
    if (jj_3R_38()) return true;
    if (jj_scan_token(OPEN_BRACE)) return true;
    if (jj_3R_281()) return true;
    if (jj_scan_token(CLOSE_BRACE)) return true;
    return false;
  }

  private boolean jj_3_34() {
    if (jj_3R_51()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_342()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3_11() {
    if (jj_3R_35()) return true;
    return false;
  }

  private boolean jj_3R_32() {
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_11()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_29() {
    if (jj_3R_50()) return true;
    if (jj_3R_86()) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3_61() {
    if (jj_3R_69()) return true;
    return false;
  }

  private boolean jj_3R_31() {
    if (jj_3R_84()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(25)) {
    jj_scanpos = xsp;
    if (jj_scan_token(24)) return true;
    }
    return false;
  }

  private boolean jj_3R_123() {
    if (jj_scan_token(OPEN_BRACE)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_34()) jj_scanpos = xsp;
    if (jj_scan_token(CLOSE_BRACE)) return true;
    return false;
  }

  private boolean jj_3R_206() {
    if (jj_scan_token(OPEN_BRACE)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_61()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(CLOSE_BRACE)) return true;
    return false;
  }

  private boolean jj_3R_51() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_35()) {
    jj_scanpos = xsp;
    if (jj_3R_123()) return true;
    }
    return false;
  }

  private boolean jj_3_35() {
    if (jj_3R_52()) return true;
    return false;
  }

  private boolean jj_3R_271() {
    if (jj_scan_token(OPEN_PAREN)) return true;
    if (jj_3R_74()) return true;
    if (jj_scan_token(CLOSE_PAREN)) return true;
    return false;
  }

  private boolean jj_3R_141() {
    return false;
  }

  private boolean jj_3R_270() {
    if (jj_scan_token(ASSIGN)) return true;
    if (jj_3R_51()) return true;
    return false;
  }

  private boolean jj_3R_225() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_270()) {
    jj_scanpos = xsp;
    if (jj_3R_271()) return true;
    }
    return false;
  }

  private boolean jj_3_7() {
    if (jj_3R_30()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(16)) {
    jj_scanpos = xsp;
    if (jj_scan_token(23)) {
    jj_scanpos = xsp;
    if (jj_scan_token(116)) return true;
    }
    }
    return false;
  }

  private boolean jj_3_8() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(24)) {
    jj_scanpos = xsp;
    if (jj_3R_31()) return true;
    }
    return false;
  }

  private boolean jj_3R_66() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_60()) {
    jj_scanpos = xsp;
    if (jj_3R_141()) return true;
    }
    return false;
  }

  private boolean jj_3_60() {
    if (jj_3R_65()) return true;
    return false;
  }

  private boolean jj_3R_33() {
    if (jj_3R_85()) return true;
    return false;
  }

  private boolean jj_3R_34() {
    if (jj_3R_86()) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3R_360() {
    if (jj_3R_363()) return true;
    return false;
  }

  private boolean jj_3_9() {
    if (jj_3R_30()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(16)) {
    jj_scanpos = xsp;
    if (jj_scan_token(23)) {
    jj_scanpos = xsp;
    if (jj_scan_token(116)) return true;
    }
    }
    return false;
  }

  private boolean jj_3_59() {
    if (jj_3R_65()) return true;
    return false;
  }

  private boolean jj_3R_68() {
    if (jj_3R_36()) return true;
    return false;
  }

  private boolean jj_3_58() {
    Token xsp;
    if (jj_3R_68()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_68()) { jj_scanpos = xsp; break; }
    }
    if (jj_3R_30()) return true;
    if (jj_scan_token(ASSIGN)) return true;
    return false;
  }

  private boolean jj_3R_362() {
    if (jj_3R_364()) return true;
    return false;
  }

  private boolean jj_3_57() {
    if (jj_3R_36()) return true;
    return false;
  }

  private boolean jj_3R_359() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_362()) jj_scanpos = xsp;
    if (jj_3R_206()) return true;
    return false;
  }

  private boolean jj_3R_355() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_359()) {
    jj_scanpos = xsp;
    if (jj_3R_360()) return true;
    }
    return false;
  }

  private boolean jj_3_10() {
    if (jj_3R_32()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_33()) {
    jj_scanpos = xsp;
    if (jj_3R_34()) return true;
    }
    return false;
  }

  private boolean jj_3R_80() {
    if (jj_3R_85()) return true;
    return false;
  }

  private boolean jj_3R_67() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_142()) {
    jj_scanpos = xsp;
    if (jj_3_59()) return true;
    }
    return false;
  }

  private boolean jj_3R_142() {
    Token xsp;
    if (jj_3_57()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_57()) { jj_scanpos = xsp; break; }
    }
    if (jj_3R_30()) return true;
    if (jj_scan_token(ASSIGN)) return true;
    if (jj_3R_52()) return true;
    return false;
  }

  private boolean jj_3R_28() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_80()) {
    jj_scanpos = xsp;
    if (jj_3_10()) return true;
    }
    return false;
  }

  private boolean jj_3_5() {
    if (jj_scan_token(USING)) return true;
    if (jj_scan_token(NAMESPACE)) return true;
    return false;
  }

  private boolean jj_3R_85() {
    if (jj_3R_30()) return true;
    return false;
  }

  private boolean jj_3R_375() {
    return false;
  }

  private boolean jj_3_6() {
    if (jj_3R_29()) return true;
    return false;
  }

  private boolean jj_3R_373() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_56()) {
    jj_scanpos = xsp;
    if (jj_3R_375()) return true;
    }
    return false;
  }

  private boolean jj_3_56() {
    if (jj_3R_67()) return true;
    return false;
  }

  private boolean jj_3R_47() {
    if (jj_3R_63()) return true;
    return false;
  }

  private boolean jj_3R_140() {
    if (jj_3R_179()) return true;
    return false;
  }

  private boolean jj_3R_139() {
    if (jj_3R_178()) return true;
    return false;
  }

  private boolean jj_3R_138() {
    if (jj_3R_205()) return true;
    return false;
  }

  private boolean jj_3_33() {
    if (jj_3R_50()) return true;
    if (jj_3R_30()) return true;
    if (jj_3R_355()) return true;
    return false;
  }

  private boolean jj_3R_137() {
    if (jj_3R_177()) return true;
    return false;
  }

  private boolean jj_3R_113() {
    if (jj_3R_63()) return true;
    return false;
  }

  private boolean jj_3R_64() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_137()) {
    jj_scanpos = xsp;
    if (jj_3R_138()) {
    jj_scanpos = xsp;
    if (jj_3R_139()) {
    jj_scanpos = xsp;
    if (jj_3R_140()) {
    jj_scanpos = xsp;
    if (jj_3_6()) return true;
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3_32() {
    if (jj_3R_30()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(16)) {
    jj_scanpos = xsp;
    if (jj_scan_token(23)) {
    jj_scanpos = xsp;
    if (jj_scan_token(116)) return true;
    }
    }
    return false;
  }

  private boolean jj_3_84() {
    if (jj_3R_40()) return true;
    if (jj_scan_token(SCOPE)) return true;
    return false;
  }

  private boolean jj_3R_319() {
    if (jj_3R_53()) return true;
    return false;
  }

  private boolean jj_3R_251() {
    if (jj_3R_30()) return true;
    if (jj_3R_355()) return true;
    return false;
  }

  private boolean jj_3R_318() {
    if (jj_scan_token(SCOPE)) return true;
    return false;
  }

  private boolean jj_3R_298() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_318()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_319()) jj_scanpos = xsp;
    if (jj_3R_63()) return true;
    return false;
  }

  private boolean jj_3R_201() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_251()) {
    jj_scanpos = xsp;
    if (jj_3_33()) return true;
    }
    return false;
  }

  private boolean jj_3_54() {
    if (jj_3R_29()) return true;
    return false;
  }

  private boolean jj_3_55() {
    if (jj_3R_66()) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3R_243() {
    if (jj_3R_47()) return true;
    return false;
  }

  private boolean jj_3_83() {
    if (jj_3R_40()) return true;
    if (jj_scan_token(SCOPE)) return true;
    return false;
  }

  private boolean jj_3R_249() {
    return false;
  }

  private boolean jj_3R_372() {
    if (jj_3R_29()) return true;
    return false;
  }

  private boolean jj_3R_333() {
    if (jj_3R_47()) return true;
    return false;
  }

  private boolean jj_3_3() {
    if (jj_scan_token(USING)) return true;
    if (jj_scan_token(NAMESPACE)) return true;
    return false;
  }

  private boolean jj_3R_332() {
    if (jj_scan_token(TEMPLATE)) return true;
    return false;
  }

  private boolean jj_3R_248() {
    if (jj_scan_token(ASSIGN)) return true;
    if (jj_3R_52()) return true;
    return false;
  }

  private boolean jj_3_4() {
    if (jj_3R_28()) return true;
    return false;
  }

  private boolean jj_3R_79() {
    if (jj_3R_179()) return true;
    return false;
  }

  private boolean jj_3R_242() {
    if (jj_3R_53()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_332()) {
    jj_scanpos = xsp;
    if (jj_3R_333()) return true;
    }
    return false;
  }

  private boolean jj_3R_370() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_372()) {
    jj_scanpos = xsp;
    if (jj_3_55()) return true;
    }
    if (jj_3R_373()) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    if (jj_3R_66()) return true;
    if (jj_scan_token(CLOSE_PAREN)) return true;
    if (jj_3R_69()) return true;
    return false;
  }

  private boolean jj_3R_241() {
    if (jj_scan_token(SCOPE)) return true;
    return false;
  }

  private boolean jj_3R_78() {
    if (jj_3R_178()) return true;
    return false;
  }

  private boolean jj_3R_192() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_241()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_242()) {
    jj_scanpos = xsp;
    if (jj_3R_243()) return true;
    }
    return false;
  }

  private boolean jj_3R_77() {
    if (jj_3R_177()) return true;
    return false;
  }

  private boolean jj_3_82() {
    if (jj_3R_40()) return true;
    if (jj_scan_token(SCOPE)) return true;
    return false;
  }

  private boolean jj_3R_27() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_77()) {
    jj_scanpos = xsp;
    if (jj_3R_78()) {
    jj_scanpos = xsp;
    if (jj_3R_79()) {
    jj_scanpos = xsp;
    if (jj_3_4()) return true;
    }
    }
    }
    return false;
  }

  private boolean jj_3R_247() {
    return false;
  }

  private boolean jj_3_31() {
    if (jj_3R_30()) return true;
    return false;
  }

  private boolean jj_3R_246() {
    if (jj_3R_48()) return true;
    return false;
  }

  private boolean jj_3_52() {
    if (jj_3R_64()) return true;
    return false;
  }

  private boolean jj_3R_327() {
    if (jj_3R_53()) return true;
    return false;
  }

  private boolean jj_3_51() {
    if (jj_3R_63()) return true;
    if (jj_scan_token(COLON)) return true;
    return false;
  }

  private boolean jj_3_53() {
    if (jj_3R_65()) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3R_326() {
    if (jj_scan_token(SCOPE)) return true;
    return false;
  }

  private boolean jj_3_2() {
    if (jj_3R_27()) return true;
    return false;
  }

  private boolean jj_3_1() {
    if (jj_scan_token(EXTERN)) return true;
    if (jj_scan_token(STRING)) return true;
    return false;
  }

  private boolean jj_3R_310() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_326()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_327()) jj_scanpos = xsp;
    if (jj_3R_113()) return true;
    return false;
  }

  private boolean jj_3R_245() {
    if (jj_3R_30()) return true;
    return false;
  }

  private boolean jj_3R_158() {
    if (jj_3R_64()) return true;
    return false;
  }

  private boolean jj_3R_157() {
    if (jj_3R_63()) return true;
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_69()) return true;
    return false;
  }

  private boolean jj_3R_49() {
    if (jj_3R_50()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_245()) {
    jj_scanpos = xsp;
    if (jj_3R_246()) {
    jj_scanpos = xsp;
    if (jj_3R_247()) return true;
    }
    }
    xsp = jj_scanpos;
    if (jj_3R_248()) {
    jj_scanpos = xsp;
    if (jj_3R_249()) return true;
    }
    return false;
  }

  private boolean jj_3R_156() {
    if (jj_scan_token(FOR)) return true;
    if (jj_scan_token(OPEN_PAREN)) return true;
    if (jj_3R_370()) return true;
    return false;
  }

  private boolean jj_3R_40() {
    if (jj_3R_113()) return true;
    return false;
  }

  private boolean jj_3_81() {
    if (jj_3R_40()) return true;
    if (jj_scan_token(SCOPE)) return true;
    return false;
  }

  private boolean jj_3R_345() {
    return false;
  }

  private boolean jj_3R_126() {
    return false;
  }

  private boolean jj_3R_344() {
    if (jj_scan_token(ELLIPSIS)) return true;
    return false;
  }

  private boolean jj_3R_125() {
    if (jj_3R_53()) return true;
    return false;
  }

  private boolean jj_3_30() {
    if (jj_3R_49()) return true;
    if (jj_3R_331()) return true;
    return false;
  }

  private boolean jj_3R_124() {
    if (jj_scan_token(TEMPLATE)) return true;
    return false;
  }

  private boolean jj_3R_351() {
    if (jj_scan_token(ELLIPSIS)) return true;
    return false;
  }

  private boolean jj_3R_155() {
    if (jj_scan_token(DO)) return true;
    if (jj_3R_69()) return true;
    if (jj_scan_token(WHILE)) return true;
    if (jj_scan_token(OPEN_PAREN)) return true;
    if (jj_3R_65()) return true;
    if (jj_scan_token(CLOSE_PAREN)) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3R_343() {
    if (jj_scan_token(COMMA)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_351()) {
    jj_scanpos = xsp;
    if (jj_3_30()) return true;
    }
    return false;
  }

  private boolean jj_3R_331() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_343()) {
    jj_scanpos = xsp;
    if (jj_3R_344()) {
    jj_scanpos = xsp;
    if (jj_3R_345()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_53() {
    if (jj_3R_40()) return true;
    if (jj_scan_token(SCOPE)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_124()) {
    jj_scanpos = xsp;
    if (jj_3R_125()) {
    jj_scanpos = xsp;
    if (jj_3R_126()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_314() {
    return false;
  }

  private boolean jj_3R_63() {
    if (jj_scan_token(ID)) return true;
    return false;
  }

  private boolean jj_3R_313() {
    if (jj_scan_token(ELLIPSIS)) return true;
    return false;
  }

  private boolean jj_3R_306() {
    if (jj_scan_token(FALSE)) return true;
    return false;
  }

  private boolean jj_3R_290() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_29()) {
    jj_scanpos = xsp;
    if (jj_3R_313()) {
    jj_scanpos = xsp;
    if (jj_3R_314()) return true;
    }
    }
    return false;
  }

  private boolean jj_3_29() {
    if (jj_3R_49()) return true;
    if (jj_3R_331()) return true;
    return false;
  }

  private boolean jj_3R_305() {
    if (jj_scan_token(TRUE)) return true;
    return false;
  }

  private boolean jj_3_28() {
    if (jj_scan_token(OPEN_PAREN)) return true;
    if (jj_3R_48()) return true;
    if (jj_scan_token(CLOSE_PAREN)) return true;
    return false;
  }

  private boolean jj_3R_304() {
    if (jj_scan_token(STRING)) return true;
    return false;
  }

  private boolean jj_3R_303() {
    if (jj_scan_token(CHARACTER)) return true;
    return false;
  }

  private boolean jj_3R_302() {
    if (jj_scan_token(FLOATCONST)) return true;
    return false;
  }

  private boolean jj_3R_122() {
    if (jj_3R_199()) return true;
    return false;
  }

  private boolean jj_3R_198() {
    if (jj_3R_199()) return true;
    return false;
  }

  private boolean jj_3R_301() {
    if (jj_scan_token(HEXINT)) return true;
    return false;
  }

  private boolean jj_3R_300() {
    if (jj_scan_token(DECIMALINT)) return true;
    return false;
  }

  private boolean jj_3R_121() {
    if (jj_scan_token(OPEN_PAREN)) return true;
    if (jj_3R_48()) return true;
    if (jj_scan_token(CLOSE_PAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_198()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_299() {
    if (jj_scan_token(OCTALINT)) return true;
    return false;
  }

  private boolean jj_3R_283() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_299()) {
    jj_scanpos = xsp;
    if (jj_3R_300()) {
    jj_scanpos = xsp;
    if (jj_3R_301()) {
    jj_scanpos = xsp;
    if (jj_3R_302()) {
    jj_scanpos = xsp;
    if (jj_3R_303()) {
    jj_scanpos = xsp;
    if (jj_3R_304()) {
    jj_scanpos = xsp;
    if (jj_3R_305()) {
    jj_scanpos = xsp;
    if (jj_3R_306()) return true;
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_154() {
    if (jj_scan_token(WHILE)) return true;
    if (jj_scan_token(OPEN_PAREN)) return true;
    if (jj_3R_67()) return true;
    if (jj_scan_token(CLOSE_PAREN)) return true;
    if (jj_3R_69()) return true;
    return false;
  }

  private boolean jj_3_27() {
    if (jj_3R_43()) return true;
    return false;
  }

  private boolean jj_3R_153() {
    if (jj_scan_token(KEYWORD_DEFAULT)) return true;
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_69()) return true;
    return false;
  }

  private boolean jj_3R_197() {
    if (jj_3R_48()) return true;
    return false;
  }

  private boolean jj_3R_152() {
    if (jj_scan_token(CASE)) return true;
    if (jj_3R_44()) return true;
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_69()) return true;
    return false;
  }

  private boolean jj_3R_48() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_120()) {
    jj_scanpos = xsp;
    if (jj_3R_121()) {
    jj_scanpos = xsp;
    if (jj_3R_122()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_120() {
    if (jj_3R_43()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_197()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3_79() {
    if (jj_3R_76()) return true;
    return false;
  }

  private boolean jj_3R_215() {
    if (jj_3R_63()) return true;
    return false;
  }

  private boolean jj_3_78() {
    if (jj_3R_40()) return true;
    if (jj_scan_token(SCOPE)) return true;
    return false;
  }

  private boolean jj_3R_266() {
    return false;
  }

  private boolean jj_3R_369() {
    return false;
  }

  private boolean jj_3R_265() {
    if (jj_scan_token(TEMPLATE)) return true;
    return false;
  }

  private boolean jj_3R_160() {
    return false;
  }

  private boolean jj_3R_151() {
    if (jj_scan_token(SWITCH)) return true;
    if (jj_scan_token(OPEN_PAREN)) return true;
    if (jj_3R_67()) return true;
    if (jj_scan_token(CLOSE_PAREN)) return true;
    if (jj_3R_69()) return true;
    return false;
  }

  private boolean jj_3R_214() {
    if (jj_3R_53()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_265()) {
    jj_scanpos = xsp;
    if (jj_3R_266()) return true;
    }
    if (jj_3R_59()) return true;
    return false;
  }

  private boolean jj_3_80() {
    if (jj_3R_40()) return true;
    if (jj_scan_token(SCOPE)) return true;
    return false;
  }

  private boolean jj_3R_175() {
    if (jj_scan_token(SCOPE)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_214()) {
    jj_scanpos = xsp;
    if (jj_3R_215()) {
    jj_scanpos = xsp;
    if (jj_3_79()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_159() {
    if (jj_3R_48()) return true;
    return false;
  }

  private boolean jj_3R_368() {
    if (jj_scan_token(ELSE)) return true;
    if (jj_3R_69()) return true;
    return false;
  }

  private boolean jj_3R_213() {
    return false;
  }

  private boolean jj_3_26() {
    if (jj_3R_36()) return true;
    return false;
  }

  private boolean jj_3R_212() {
    if (jj_scan_token(TEMPLATE)) return true;
    return false;
  }

  private boolean jj_3R_62() {
    Token xsp;
    if (jj_3_26()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_26()) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    if (jj_3R_159()) {
    jj_scanpos = xsp;
    if (jj_3R_160()) return true;
    }
    return false;
  }

  private boolean jj_3R_46() {
    if (jj_3R_40()) return true;
    if (jj_scan_token(SCOPE)) return true;
    return false;
  }

  private boolean jj_3R_75() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_174()) {
    jj_scanpos = xsp;
    if (jj_3R_175()) return true;
    }
    return false;
  }

  private boolean jj_3R_174() {
    if (jj_3R_53()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_212()) {
    jj_scanpos = xsp;
    if (jj_3R_213()) return true;
    }
    if (jj_3R_59()) return true;
    return false;
  }

  private boolean jj_3_24() {
    if (jj_3R_40()) return true;
    if (jj_scan_token(SCOPE)) return true;
    return false;
  }

  private boolean jj_3_50() {
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3R_119() {
    if (jj_3R_49()) return true;
    return false;
  }

  private boolean jj_3R_224() {
    if (jj_3R_269()) return true;
    return false;
  }

  private boolean jj_3_25() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(22)) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_46()) jj_scanpos = xsp;
    if (jj_3R_47()) return true;
    return false;
  }

  private boolean jj_3R_150() {
    if (jj_scan_token(IF)) return true;
    if (jj_scan_token(OPEN_PAREN)) return true;
    if (jj_3R_67()) return true;
    if (jj_scan_token(CLOSE_PAREN)) return true;
    if (jj_3R_69()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_368()) {
    jj_scanpos = xsp;
    if (jj_3R_369()) return true;
    }
    return false;
  }

  private boolean jj_3R_268() {
    if (jj_3R_53()) return true;
    return false;
  }

  private boolean jj_3R_149() {
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3R_267() {
    if (jj_scan_token(SCOPE)) return true;
    return false;
  }

  private boolean jj_3R_136() {
    if (jj_3R_204()) return true;
    return false;
  }

  private boolean jj_3R_148() {
    if (jj_3R_206()) return true;
    return false;
  }

  private boolean jj_3R_181() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_223()) {
    jj_scanpos = xsp;
    if (jj_3R_224()) return true;
    }
    return false;
  }

  private boolean jj_3R_223() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_267()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_268()) jj_scanpos = xsp;
    if (jj_3R_47()) return true;
    return false;
  }

  private boolean jj_3_77() {
    if (jj_3R_76()) return true;
    return false;
  }

  private boolean jj_3R_147() {
    if (jj_scan_token(GOTO)) return true;
    if (jj_3R_63()) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3R_196() {
    if (jj_3R_191()) return true;
    return false;
  }

  private boolean jj_3R_135() {
    if (jj_scan_token(TILDE)) return true;
    if (jj_3R_113()) return true;
    return false;
  }

  private boolean jj_3R_146() {
    if (jj_scan_token(RETURN)) return true;
    if (jj_3R_66()) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3R_59() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_134()) {
    jj_scanpos = xsp;
    if (jj_3R_135()) {
    jj_scanpos = xsp;
    if (jj_3_77()) {
    jj_scanpos = xsp;
    if (jj_3R_136()) return true;
    }
    }
    }
    return false;
  }

  private boolean jj_3R_134() {
    if (jj_3R_63()) return true;
    return false;
  }

  private boolean jj_3R_240() {
    if (jj_scan_token(VOLATILE)) return true;
    return false;
  }

  private boolean jj_3R_239() {
    if (jj_scan_token(CONST)) return true;
    return false;
  }

  private boolean jj_3R_191() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_239()) {
    jj_scanpos = xsp;
    if (jj_3R_240()) return true;
    }
    return false;
  }

  private boolean jj_3R_145() {
    if (jj_scan_token(CONTINUE)) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3R_115() {
    if (jj_3R_49()) return true;
    return false;
  }

  private boolean jj_3R_292() {
    if (jj_3R_315()) return true;
    return false;
  }

  private boolean jj_3_76() {
    if (jj_3R_75()) return true;
    return false;
  }

  private boolean jj_3R_291() {
    if (jj_3R_191()) return true;
    return false;
  }

  private boolean jj_3R_144() {
    if (jj_scan_token(BREAK)) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3R_346() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_62()) return true;
    return false;
  }

  private boolean jj_3R_285() {
    if (jj_3R_59()) return true;
    return false;
  }

  private boolean jj_3R_69() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_143()) {
    jj_scanpos = xsp;
    if (jj_3R_144()) {
    jj_scanpos = xsp;
    if (jj_3R_145()) {
    jj_scanpos = xsp;
    if (jj_3R_146()) {
    jj_scanpos = xsp;
    if (jj_3R_147()) {
    jj_scanpos = xsp;
    if (jj_3R_148()) {
    jj_scanpos = xsp;
    if (jj_3R_149()) {
    jj_scanpos = xsp;
    if (jj_3R_150()) {
    jj_scanpos = xsp;
    if (jj_3R_151()) {
    jj_scanpos = xsp;
    if (jj_3R_152()) {
    jj_scanpos = xsp;
    if (jj_3R_153()) {
    jj_scanpos = xsp;
    if (jj_3R_154()) {
    jj_scanpos = xsp;
    if (jj_3R_155()) {
    jj_scanpos = xsp;
    if (jj_3R_156()) {
    jj_scanpos = xsp;
    if (jj_3R_157()) {
    jj_scanpos = xsp;
    if (jj_3R_158()) {
    jj_scanpos = xsp;
    if (jj_3_53()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_143() {
    if (jj_scan_token(TRY)) return true;
    if (jj_3R_206()) return true;
    if (jj_3R_367()) return true;
    return false;
  }

  private boolean jj_3R_284() {
    if (jj_3R_75()) return true;
    return false;
  }

  private boolean jj_3R_275() {
    if (jj_scan_token(OPEN_PAREN)) return true;
    if (jj_3R_290()) return true;
    if (jj_scan_token(CLOSE_PAREN)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_291()) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    if (jj_3R_292()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_269() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_284()) {
    jj_scanpos = xsp;
    if (jj_3R_285()) return true;
    }
    return false;
  }

  private boolean jj_3R_114() {
    if (jj_3R_49()) return true;
    return false;
  }

  private boolean jj_3R_45() {
    if (jj_scan_token(OPEN_PAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(21)) {
    jj_scanpos = xsp;
    if (jj_scan_token(27)) {
    jj_scanpos = xsp;
    if (jj_3R_119()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_289() {
    return false;
  }

  private boolean jj_3R_263() {
    if (jj_3R_283()) return true;
    return false;
  }

  private boolean jj_3_49() {
    if (jj_3R_62()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_346()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_262() {
    if (jj_3R_269()) return true;
    return false;
  }

  private boolean jj_3R_261() {
    if (jj_scan_token(THIS)) return true;
    return false;
  }

  private boolean jj_3_22() {
    if (jj_3R_44()) return true;
    return false;
  }

  private boolean jj_3R_274() {
    if (jj_scan_token(OPEN_BRACKET)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_22()) {
    jj_scanpos = xsp;
    if (jj_3R_289()) return true;
    }
    if (jj_scan_token(CLOSE_BRACKET)) return true;
    return false;
  }

  private boolean jj_3R_260() {
    if (jj_scan_token(OPEN_PAREN)) return true;
    if (jj_3R_65()) return true;
    if (jj_scan_token(CLOSE_PAREN)) return true;
    return false;
  }

  private boolean jj_3R_209() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_260()) {
    jj_scanpos = xsp;
    if (jj_3R_261()) {
    jj_scanpos = xsp;
    if (jj_3R_262()) {
    jj_scanpos = xsp;
    if (jj_3R_263()) return true;
    }
    }
    }
    return false;
  }

  private boolean jj_3_23() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(18)) {
    jj_scanpos = xsp;
    if (jj_3R_45()) return true;
    }
    return false;
  }

  private boolean jj_3_75() {
    if (jj_3R_74()) return true;
    return false;
  }

  private boolean jj_3R_335() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_75()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_308() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_52()) return true;
    return false;
  }

  private boolean jj_3R_315() {
    if (jj_scan_token(THROW)) return true;
    if (jj_scan_token(OPEN_PAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_49()) jj_scanpos = xsp;
    if (jj_scan_token(CLOSE_PAREN)) return true;
    return false;
  }

  private boolean jj_3R_250() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_274()) {
    jj_scanpos = xsp;
    if (jj_3R_275()) return true;
    }
    return false;
  }

  private boolean jj_3_47() {
    if (jj_3R_30()) return true;
    return false;
  }

  private boolean jj_3R_42() {
    if (jj_scan_token(OPEN_PAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(21)) {
    jj_scanpos = xsp;
    if (jj_scan_token(27)) {
    jj_scanpos = xsp;
    if (jj_3R_115()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_199() {
    Token xsp;
    if (jj_3R_250()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_250()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_378() {
    return false;
  }

  private boolean jj_3R_74() {
    if (jj_3R_52()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_308()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_377() {
    if (jj_3R_48()) return true;
    return false;
  }

  private boolean jj_3R_376() {
    if (jj_3R_30()) return true;
    return false;
  }

  private boolean jj_3R_341() {
    if (jj_scan_token(OPEN_PAREN)) return true;
    if (jj_3R_335()) return true;
    if (jj_scan_token(CLOSE_PAREN)) return true;
    return false;
  }

  private boolean jj_3R_118() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_195()) jj_scanpos = xsp;
    if (jj_3R_53()) return true;
    if (jj_scan_token(STAR)) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_196()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3_46() {
    if (jj_3R_36()) return true;
    return false;
  }

  private boolean jj_3R_41() {
    if (jj_scan_token(OPEN_PAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(21)) {
    jj_scanpos = xsp;
    if (jj_scan_token(27)) {
    jj_scanpos = xsp;
    if (jj_3R_114()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_195() {
    if (jj_scan_token(SCOPE)) return true;
    return false;
  }

  private boolean jj_3R_340() {
    if (jj_scan_token(OPEN_BRACKET)) return true;
    if (jj_3R_65()) return true;
    if (jj_scan_token(CLOSE_BRACKET)) return true;
    return false;
  }

  private boolean jj_3R_194() {
    if (jj_3R_191()) return true;
    return false;
  }

  private boolean jj_3R_374() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_48()) {
    jj_scanpos = xsp;
    if (jj_scan_token(27)) return true;
    }
    return false;
  }

  private boolean jj_3R_350() {
    if (jj_scan_token(TEMPLATE)) return true;
    return false;
  }

  private boolean jj_3_20() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(18)) {
    jj_scanpos = xsp;
    if (jj_3R_42()) return true;
    }
    return false;
  }

  private boolean jj_3_48() {
    Token xsp;
    if (jj_3_46()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_46()) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    if (jj_3R_376()) {
    jj_scanpos = xsp;
    if (jj_3R_377()) {
    jj_scanpos = xsp;
    if (jj_3R_378()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_339() {
    if (jj_scan_token(ARROW)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_350()) jj_scanpos = xsp;
    if (jj_3R_269()) return true;
    return false;
  }

  private boolean jj_3R_117() {
    if (jj_scan_token(AMPERSAND)) return true;
    return false;
  }

  private boolean jj_3R_349() {
    if (jj_scan_token(TEMPLATE)) return true;
    return false;
  }

  private boolean jj_3R_43() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_116()) {
    jj_scanpos = xsp;
    if (jj_3R_117()) {
    jj_scanpos = xsp;
    if (jj_3R_118()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_116() {
    if (jj_scan_token(STAR)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_194()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_338() {
    if (jj_scan_token(DOT)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_349()) jj_scanpos = xsp;
    if (jj_3R_269()) return true;
    return false;
  }

  private boolean jj_3R_371() {
    if (jj_scan_token(CATCH)) return true;
    if (jj_scan_token(OPEN_PAREN)) return true;
    if (jj_3R_374()) return true;
    if (jj_scan_token(CLOSE_PAREN)) return true;
    if (jj_3R_206()) return true;
    return false;
  }

  private boolean jj_3R_182() {
    if (jj_3R_199()) return true;
    return false;
  }

  private boolean jj_3R_337() {
    if (jj_scan_token(MINUSMINUS)) return true;
    return false;
  }

  private boolean jj_3R_367() {
    Token xsp;
    if (jj_3R_371()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_371()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3_19() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(18)) {
    jj_scanpos = xsp;
    if (jj_3R_41()) return true;
    }
    return false;
  }

  private boolean jj_3R_336() {
    if (jj_scan_token(PLUSPLUS)) return true;
    return false;
  }

  private boolean jj_3R_325() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_336()) {
    jj_scanpos = xsp;
    if (jj_3R_337()) {
    jj_scanpos = xsp;
    if (jj_3R_338()) {
    jj_scanpos = xsp;
    if (jj_3R_339()) {
    jj_scanpos = xsp;
    if (jj_3R_340()) {
    jj_scanpos = xsp;
    if (jj_3R_341()) return true;
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_83() {
    if (jj_3R_181()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_182()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_171() {
    if (jj_3R_209()) return true;
    return false;
  }

  private boolean jj_3R_180() {
    if (jj_3R_199()) return true;
    return false;
  }

  private boolean jj_3R_363() {
    if (jj_scan_token(TRY)) return true;
    return false;
  }

  private boolean jj_3_74() {
    if (jj_3R_37()) return true;
    if (jj_scan_token(OPEN_PAREN)) return true;
    if (jj_3R_335()) return true;
    if (jj_scan_token(CLOSE_PAREN)) return true;
    return false;
  }

  private boolean jj_3R_82() {
    if (jj_scan_token(OPEN_PAREN)) return true;
    if (jj_3R_30()) return true;
    if (jj_scan_token(CLOSE_PAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_180()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3_21() {
    if (jj_3R_43()) return true;
    return false;
  }

  private boolean jj_3R_170() {
    if (jj_scan_token(TYPEID)) return true;
    if (jj_scan_token(TYPENAME)) return true;
    return false;
  }

  private boolean jj_3R_169() {
    if (jj_scan_token(CONST_CAST)) return true;
    if (jj_scan_token(LESSTHAN)) return true;
    if (jj_3R_62()) return true;
    if (jj_scan_token(GREATERTHAN)) return true;
    if (jj_scan_token(OPEN_PAREN)) return true;
    if (jj_3R_65()) return true;
    if (jj_scan_token(CLOSE_PAREN)) return true;
    return false;
  }

  private boolean jj_3R_168() {
    if (jj_scan_token(REINTERPRET_CAST)) return true;
    if (jj_scan_token(LESSTHAN)) return true;
    if (jj_3R_62()) return true;
    if (jj_scan_token(GREATERTHAN)) return true;
    if (jj_scan_token(OPEN_PAREN)) return true;
    if (jj_3R_65()) return true;
    if (jj_scan_token(CLOSE_PAREN)) return true;
    return false;
  }

  private boolean jj_3R_296() {
    return false;
  }

  private boolean jj_3R_167() {
    if (jj_scan_token(STATIC_CAST)) return true;
    if (jj_scan_token(LESSTHAN)) return true;
    if (jj_3R_62()) return true;
    if (jj_scan_token(GREATERTHAN)) return true;
    if (jj_scan_token(OPEN_PAREN)) return true;
    if (jj_3R_65()) return true;
    if (jj_scan_token(CLOSE_PAREN)) return true;
    return false;
  }

  private boolean jj_3R_81() {
    if (jj_3R_43()) return true;
    if (jj_3R_30()) return true;
    return false;
  }

  private boolean jj_3R_30() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_81()) {
    jj_scanpos = xsp;
    if (jj_3R_82()) {
    jj_scanpos = xsp;
    if (jj_3R_83()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_294() {
    return false;
  }

  private boolean jj_3R_166() {
    if (jj_scan_token(DYNAMIC_CAST)) return true;
    if (jj_scan_token(LESSTHAN)) return true;
    if (jj_3R_62()) return true;
    if (jj_scan_token(GREATERTHAN)) return true;
    if (jj_scan_token(OPEN_PAREN)) return true;
    if (jj_3R_65()) return true;
    if (jj_scan_token(CLOSE_PAREN)) return true;
    return false;
  }

  private boolean jj_3R_165() {
    if (jj_scan_token(TYPENAME)) return true;
    return false;
  }

  private boolean jj_3R_71() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_165()) {
    jj_scanpos = xsp;
    if (jj_3R_166()) {
    jj_scanpos = xsp;
    if (jj_3R_167()) {
    jj_scanpos = xsp;
    if (jj_3R_168()) {
    jj_scanpos = xsp;
    if (jj_3R_169()) {
    jj_scanpos = xsp;
    if (jj_3R_170()) {
    jj_scanpos = xsp;
    if (jj_3_74()) {
    jj_scanpos = xsp;
    if (jj_3R_171()) return true;
    }
    }
    }
    }
    }
    }
    }
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_325()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3_45() {
    if (jj_3R_61()) return true;
    return false;
  }

  private boolean jj_3R_259() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_84()) return true;
    return false;
  }

  private boolean jj_3_73() {
    if (jj_3R_73()) return true;
    return false;
  }

  private boolean jj_3R_295() {
    if (jj_scan_token(OPEN_BRACKET)) return true;
    if (jj_scan_token(CLOSE_BRACKET)) return true;
    return false;
  }

  private boolean jj_3R_324() {
    if (jj_scan_token(OPEN_BRACKET)) return true;
    if (jj_scan_token(CLOSE_BRACKET)) return true;
    if (jj_3R_73()) return true;
    return false;
  }

  private boolean jj_3R_222() {
    if (jj_3R_264()) return true;
    return false;
  }

  private boolean jj_3R_221() {
    if (jj_3R_61()) return true;
    return false;
  }

  private boolean jj_3R_293() {
    if (jj_scan_token(OPEN_BRACKET)) return true;
    if (jj_scan_token(CLOSE_BRACKET)) return true;
    return false;
  }

  private boolean jj_3R_220() {
    if (jj_scan_token(OPEN_BRACKET)) return true;
    if (jj_scan_token(CLOSE_BRACKET)) return true;
    return false;
  }

  private boolean jj_3R_219() {
    if (jj_scan_token(OPEN_PAREN)) return true;
    if (jj_scan_token(CLOSE_PAREN)) return true;
    return false;
  }

  private boolean jj_3R_184() {
    return false;
  }

  private boolean jj_3R_218() {
    if (jj_scan_token(ARROW)) return true;
    return false;
  }

  private boolean jj_3R_208() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(22)) jj_scanpos = xsp;
    if (jj_scan_token(DELETE)) return true;
    xsp = jj_scanpos;
    if (jj_3R_324()) {
    jj_scanpos = xsp;
    if (jj_3_73()) return true;
    }
    return false;
  }

  private boolean jj_3R_183() {
    if (jj_3R_225()) return true;
    return false;
  }

  private boolean jj_3R_217() {
    if (jj_scan_token(DELETE)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_295()) {
    jj_scanpos = xsp;
    if (jj_3R_296()) return true;
    }
    return false;
  }

  private boolean jj_3R_216() {
    if (jj_scan_token(NEW)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_293()) {
    jj_scanpos = xsp;
    if (jj_3R_294()) return true;
    }
    return false;
  }

  private boolean jj_3R_176() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_216()) {
    jj_scanpos = xsp;
    if (jj_3R_217()) {
    jj_scanpos = xsp;
    if (jj_3R_218()) {
    jj_scanpos = xsp;
    if (jj_3R_219()) {
    jj_scanpos = xsp;
    if (jj_3R_220()) {
    jj_scanpos = xsp;
    if (jj_3R_221()) {
    jj_scanpos = xsp;
    if (jj_3R_222()) return true;
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_84() {
    if (jj_3R_30()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_183()) {
    jj_scanpos = xsp;
    if (jj_3R_184()) return true;
    }
    return false;
  }

  private boolean jj_3R_361() {
    if (jj_scan_token(OPEN_BRACKET)) return true;
    if (jj_3R_44()) return true;
    if (jj_scan_token(CLOSE_BRACKET)) return true;
    return false;
  }

  private boolean jj_3R_358() {
    if (jj_scan_token(OPEN_BRACKET)) return true;
    if (jj_3R_65()) return true;
    if (jj_scan_token(CLOSE_BRACKET)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_361()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_76() {
    if (jj_scan_token(OPERATOR)) return true;
    if (jj_3R_176()) return true;
    return false;
  }

  private boolean jj_3R_185() {
    if (jj_3R_84()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_259()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_86() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_185()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_354() {
    if (jj_3R_358()) return true;
    return false;
  }

  private boolean jj_3R_365() {
    if (jj_3R_310()) return true;
    if (jj_scan_token(OPEN_PAREN)) return true;
    if (jj_3R_335()) return true;
    if (jj_scan_token(CLOSE_PAREN)) return true;
    return false;
  }

  private boolean jj_3R_357() {
    return false;
  }

  private boolean jj_3R_356() {
    if (jj_3R_352()) return true;
    return false;
  }

  private boolean jj_3R_353() {
    if (jj_3R_43()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_356()) {
    jj_scanpos = xsp;
    if (jj_3R_357()) return true;
    }
    return false;
  }

  private boolean jj_3R_352() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_353()) {
    jj_scanpos = xsp;
    if (jj_3R_354()) return true;
    }
    return false;
  }

  private boolean jj_3_18() {
    if (jj_3R_40()) return true;
    if (jj_scan_token(SCOPE)) return true;
    return false;
  }

  private boolean jj_3R_366() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_365()) return true;
    return false;
  }

  private boolean jj_3_17() {
    if (jj_3R_40()) return true;
    if (jj_scan_token(SCOPE)) return true;
    return false;
  }

  private boolean jj_3R_177() {
    if (jj_scan_token(ASM)) return true;
    if (jj_scan_token(OPEN_PAREN)) return true;
    if (jj_scan_token(STRING)) return true;
    if (jj_scan_token(CLOSE_PAREN)) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3R_348() {
    return false;
  }

  private boolean jj_3R_364() {
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_365()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_366()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_255() {
    if (jj_3R_53()) return true;
    return false;
  }

  private boolean jj_3R_280() {
    if (jj_3R_53()) return true;
    return false;
  }

  private boolean jj_3R_178() {
    if (jj_scan_token(USING)) return true;
    if (jj_scan_token(NAMESPACE)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(22)) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_255()) jj_scanpos = xsp;
    if (jj_3R_63()) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3R_279() {
    if (jj_3R_43()) return true;
    return false;
  }

  private boolean jj_3R_347() {
    if (jj_3R_352()) return true;
    return false;
  }

  private boolean jj_3R_258() {
    if (jj_3R_53()) return true;
    return false;
  }

  private boolean jj_3_72() {
    if (jj_3R_36()) return true;
    return false;
  }

  private boolean jj_3R_257() {
    if (jj_scan_token(SCOPE)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_280()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_256() {
    if (jj_scan_token(TYPENAME)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(22)) jj_scanpos = xsp;
    if (jj_3R_53()) return true;
    return false;
  }

  private boolean jj_3_44() {
    if (jj_3R_36()) return true;
    return false;
  }

  private boolean jj_3R_72() {
    Token xsp;
    if (jj_3_72()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_72()) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    if (jj_3R_347()) {
    jj_scanpos = xsp;
    if (jj_3R_348()) return true;
    }
    return false;
  }

  private boolean jj_3R_254() {
    Token xsp;
    if (jj_3_44()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_44()) { jj_scanpos = xsp; break; }
    }
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_279()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_179() {
    if (jj_scan_token(USING)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_256()) {
    jj_scanpos = xsp;
    if (jj_3R_257()) {
    jj_scanpos = xsp;
    if (jj_3R_258()) return true;
    }
    }
    if (jj_3R_59()) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3R_282() {
    if (jj_3R_297()) return true;
    return false;
  }

  private boolean jj_3R_323() {
    return false;
  }

  private boolean jj_3R_317() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_297()) return true;
    return false;
  }

  private boolean jj_3R_204() {
    if (jj_scan_token(OPERATOR)) return true;
    if (jj_3R_254()) return true;
    return false;
  }

  private boolean jj_3R_322() {
    if (jj_scan_token(OPEN_PAREN)) return true;
    if (jj_3R_335()) return true;
    if (jj_scan_token(CLOSE_PAREN)) return true;
    return false;
  }

  private boolean jj_3R_205() {
    if (jj_scan_token(NAMESPACE)) return true;
    return false;
  }

  private boolean jj_3R_334() {
    if (jj_scan_token(ASSIGN)) return true;
    if (jj_3R_44()) return true;
    return false;
  }

  private boolean jj_3R_321() {
    if (jj_scan_token(OPEN_PAREN)) return true;
    if (jj_3R_62()) return true;
    if (jj_scan_token(CLOSE_PAREN)) return true;
    return false;
  }

  private boolean jj_3_70() {
    if (jj_scan_token(OPEN_PAREN)) return true;
    if (jj_3R_52()) return true;
    return false;
  }

  private boolean jj_3R_330() {
    if (jj_scan_token(PROTECTED)) return true;
    return false;
  }

  private boolean jj_3R_329() {
    if (jj_scan_token(PUBLIC)) return true;
    return false;
  }

  private boolean jj_3_71() {
    if (jj_3R_72()) return true;
    return false;
  }

  private boolean jj_3R_328() {
    if (jj_scan_token(PRIVATE)) return true;
    return false;
  }

  private boolean jj_3R_311() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_328()) {
    jj_scanpos = xsp;
    if (jj_3R_329()) {
    jj_scanpos = xsp;
    if (jj_3R_330()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_320() {
    if (jj_scan_token(OPEN_PAREN)) return true;
    if (jj_3R_74()) return true;
    if (jj_scan_token(CLOSE_PAREN)) return true;
    return false;
  }

  private boolean jj_3R_316() {
    if (jj_3R_63()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_334()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_207() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(22)) jj_scanpos = xsp;
    if (jj_scan_token(NEW)) return true;
    xsp = jj_scanpos;
    if (jj_3R_320()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3_71()) {
    jj_scanpos = xsp;
    if (jj_3R_321()) return true;
    }
    xsp = jj_scanpos;
    if (jj_3R_322()) {
    jj_scanpos = xsp;
    if (jj_3R_323()) return true;
    }
    return false;
  }

  private boolean jj_3R_297() {
    if (jj_3R_316()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_317()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_288() {
    if (jj_3R_310()) return true;
    return false;
  }

  private boolean jj_3R_312() {
    if (jj_scan_token(VIRTUAL)) return true;
    return false;
  }

  private boolean jj_3R_287() {
    if (jj_3R_311()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_312()) jj_scanpos = xsp;
    if (jj_3R_310()) return true;
    return false;
  }

  private boolean jj_3R_309() {
    if (jj_3R_311()) return true;
    return false;
  }

  private boolean jj_3R_189() {
    if (jj_scan_token(ENUM)) return true;
    if (jj_3R_63()) return true;
    if (jj_scan_token(OPEN_BRACE)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_282()) jj_scanpos = xsp;
    if (jj_scan_token(CLOSE_BRACE)) return true;
    return false;
  }

  private boolean jj_3R_286() {
    if (jj_scan_token(VIRTUAL)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_309()) jj_scanpos = xsp;
    if (jj_3R_310()) return true;
    return false;
  }

  private boolean jj_3R_272() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_286()) {
    jj_scanpos = xsp;
    if (jj_3R_287()) {
    jj_scanpos = xsp;
    if (jj_3R_288()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_238() {
    if (jj_scan_token(TYPENAME)) return true;
    return false;
  }

  private boolean jj_3R_273() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_272()) return true;
    return false;
  }

  private boolean jj_3R_237() {
    if (jj_scan_token(ENUM)) return true;
    if (jj_3R_298()) return true;
    return false;
  }

  private boolean jj_3R_236() {
    if (jj_scan_token(UNION)) return true;
    if (jj_3R_298()) return true;
    return false;
  }

  private boolean jj_3R_244() {
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_272()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_273()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_193() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_244()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_235() {
    if (jj_scan_token(STRUCT)) return true;
    if (jj_3R_298()) return true;
    return false;
  }

  private boolean jj_3R_234() {
    if (jj_scan_token(CLASS)) return true;
    if (jj_3R_298()) return true;
    return false;
  }

  private boolean jj_3R_190() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_234()) {
    jj_scanpos = xsp;
    if (jj_3R_235()) {
    jj_scanpos = xsp;
    if (jj_3R_236()) {
    jj_scanpos = xsp;
    if (jj_3R_237()) {
    jj_scanpos = xsp;
    if (jj_3R_238()) return true;
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_278() {
    return false;
  }

  private boolean jj_3R_203() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_202()) return true;
    return false;
  }

  private boolean jj_3R_277() {
    if (jj_scan_token(ASSIGN)) return true;
    if (jj_3R_44()) return true;
    return false;
  }

  private boolean jj_3_39() {
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3R_264() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(63)) {
    jj_scanpos = xsp;
    if (jj_scan_token(64)) {
    jj_scanpos = xsp;
    if (jj_scan_token(54)) {
    jj_scanpos = xsp;
    if (jj_scan_token(55)) {
    jj_scanpos = xsp;
    if (jj_scan_token(56)) {
    jj_scanpos = xsp;
    if (jj_scan_token(52)) {
    jj_scanpos = xsp;
    if (jj_scan_token(53)) {
    jj_scanpos = xsp;
    if (jj_scan_token(50)) {
    jj_scanpos = xsp;
    if (jj_scan_token(51)) {
    jj_scanpos = xsp;
    if (jj_scan_token(46)) {
    jj_scanpos = xsp;
    if (jj_scan_token(48)) {
    jj_scanpos = xsp;
    if (jj_scan_token(47)) {
    jj_scanpos = xsp;
    if (jj_scan_token(49)) {
    jj_scanpos = xsp;
    if (jj_scan_token(44)) {
    jj_scanpos = xsp;
    if (jj_scan_token(45)) {
    jj_scanpos = xsp;
    if (jj_scan_token(43)) {
    jj_scanpos = xsp;
    if (jj_scan_token(42)) {
    jj_scanpos = xsp;
    if (jj_scan_token(41)) {
    jj_scanpos = xsp;
    if (jj_scan_token(40)) {
    jj_scanpos = xsp;
    if (jj_scan_token(39)) {
    jj_scanpos = xsp;
    if (jj_scan_token(28)) {
    jj_scanpos = xsp;
    if (jj_scan_token(29)) {
    jj_scanpos = xsp;
    if (jj_scan_token(30)) {
    jj_scanpos = xsp;
    if (jj_scan_token(31)) {
    jj_scanpos = xsp;
    if (jj_scan_token(32)) {
    jj_scanpos = xsp;
    if (jj_scan_token(33)) {
    jj_scanpos = xsp;
    if (jj_scan_token(34)) {
    jj_scanpos = xsp;
    if (jj_scan_token(35)) {
    jj_scanpos = xsp;
    if (jj_scan_token(36)) {
    jj_scanpos = xsp;
    if (jj_scan_token(38)) {
    jj_scanpos = xsp;
    if (jj_scan_token(37)) {
    jj_scanpos = xsp;
    if (jj_scan_token(25)) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_106() {
    if (jj_scan_token(VOID)) return true;
    return false;
  }

  private boolean jj_3R_60() {
    if (jj_3R_63()) return true;
    return false;
  }

  private boolean jj_3_43() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_60()) jj_scanpos = xsp;
    if (jj_scan_token(COLON)) return true;
    return false;
  }

  private boolean jj_3R_105() {
    if (jj_scan_token(DOUBLE)) return true;
    return false;
  }

  private boolean jj_3R_104() {
    if (jj_scan_token(FLOAT)) return true;
    return false;
  }

  private boolean jj_3R_103() {
    if (jj_scan_token(UNSIGNED)) return true;
    return false;
  }

  private boolean jj_3R_253() {
    if (jj_3R_30()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_277()) {
    jj_scanpos = xsp;
    if (jj_3R_278()) return true;
    }
    return false;
  }

  private boolean jj_3R_102() {
    if (jj_scan_token(SIGNED)) return true;
    return false;
  }

  private boolean jj_3R_276() {
    if (jj_3R_63()) return true;
    return false;
  }

  private boolean jj_3R_101() {
    if (jj_scan_token(LONG)) return true;
    return false;
  }

  private boolean jj_3R_252() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_276()) jj_scanpos = xsp;
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_44()) return true;
    return false;
  }

  private boolean jj_3R_100() {
    if (jj_scan_token(INT)) return true;
    return false;
  }

  private boolean jj_3R_202() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_252()) {
    jj_scanpos = xsp;
    if (jj_3R_253()) return true;
    }
    return false;
  }

  private boolean jj_3R_61() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(57)) {
    jj_scanpos = xsp;
    if (jj_scan_token(58)) {
    jj_scanpos = xsp;
    if (jj_scan_token(59)) {
    jj_scanpos = xsp;
    if (jj_scan_token(60)) {
    jj_scanpos = xsp;
    if (jj_scan_token(53)) {
    jj_scanpos = xsp;
    if (jj_scan_token(52)) {
    jj_scanpos = xsp;
    if (jj_scan_token(43)) {
    jj_scanpos = xsp;
    if (jj_scan_token(54)) return true;
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_99() {
    if (jj_scan_token(SHORT)) return true;
    return false;
  }

  private boolean jj_3R_98() {
    if (jj_scan_token(BOOL)) return true;
    return false;
  }

  private boolean jj_3_68() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(22)) jj_scanpos = xsp;
    if (jj_scan_token(DELETE)) return true;
    return false;
  }

  private boolean jj_3R_97() {
    if (jj_scan_token(WCHAR_T)) return true;
    return false;
  }

  private boolean jj_3R_96() {
    if (jj_scan_token(CHAR)) return true;
    return false;
  }

  private boolean jj_3_64() {
    if (jj_scan_token(OPEN_PAREN)) return true;
    if (jj_3R_62()) return true;
    if (jj_scan_token(CLOSE_PAREN)) return true;
    return false;
  }

  private boolean jj_3_67() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(22)) jj_scanpos = xsp;
    if (jj_scan_token(NEW)) return true;
    return false;
  }

  private boolean jj_3_69() {
    if (jj_3R_71()) return true;
    return false;
  }

  private boolean jj_3_65() {
    if (jj_3R_70()) return true;
    return false;
  }

  private boolean jj_3R_164() {
    if (jj_3R_208()) return true;
    return false;
  }

  private boolean jj_3R_307() {
    if (jj_scan_token(OPEN_PAREN)) return true;
    if (jj_3R_62()) return true;
    if (jj_scan_token(CLOSE_PAREN)) return true;
    return false;
  }

  private boolean jj_3R_133() {
    if (jj_3R_202()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_203()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_163() {
    if (jj_3R_207()) return true;
    return false;
  }

  private boolean jj_3R_58() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_133()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3_66() {
    if (jj_3R_61()) return true;
    return false;
  }

  /** Generated Token Manager. */
  public ParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  /** Whether we are looking ahead. */
  private boolean jj_lookingAhead = false;
  private boolean jj_semLA;
  private int jj_gen;
  final private int[] jj_la1 = new int[113];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static private int[] jj_la1_3;
  static private int[] jj_la1_4;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
      jj_la1_init_2();
      jj_la1_init_3();
      jj_la1_init_4();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2000000,0x10000000,0x400000,0x400000,0x400000,0x2000000,0x500000,0x10100000,0x500000,0x0,0x400000,0x0,0x400000,0x0,0x0,0x140000,0x0,0x400000,0x400000,0x540000,0x540000,0x140000,0x140000,0x8000000,0x8000000,0xa000000,0x540000,0x10000000,0x800000,0x810000,0x10100000,0x2000000,0x10000,0x0,0x0,0x0,0x400000,0x0,0x0,0x0,0x2000000,0xd00000,0x0,0x10000000,0x500000,0x2000000,0x800000,0x0,0x0,0x400000,0x0,0x400000,0x2000000,0x40000,0x40000,0x140000,0xf2000000,0x0,0x540000,0x8000000,0x2000000,0x0,0x10000,0x0,0xf6000000,0x0,0x0,0xf2000000,0x400000,0x100000,0x100000,0x440000,0x440000,0x440000,0x40000,0x400000,0x40000,0x0,0x500000,0x140000,0x0,0x0,0x140000,0x2000000,0x500000,0x0,0x0,0x0,0x0,0x0,0x0,0x400000,0x0,0x0,0x400000,0x400000,0x0,0x0,0x400000,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8400800,0x0,0x8000000,0x0,0x0,0x0,0x400800,0x0,0x0,0x0,0x0,0x0,0x8000000,0x400800,0x400800,0x0,0x0,0x0,0x0,0x0,0x400800,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8400800,0x0,0x0,0x8400800,0x0,0x0,0x0,0x0,0x0,0x0,0x400800,0x0,0x0,0x0,0x40000000,0x81ffffff,0x0,0x400800,0x0,0x0,0x0,0x0,0x0,0x81ffffff,0x0,0x1e700800,0x81ffffff,0x0,0x0,0x0,0x400800,0x400800,0x400800,0x0,0x0,0x0,0x0,0x8000000,0x66000000,0x0,0x0,0x66000000,0x0,0x8000000,0x8000000,0x8000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_init_2() {
      jj_la1_2 = new int[] {0x100000,0x100000,0x2,0x0,0x2,0x0,0x80200004,0x12080000,0x80200004,0x10080000,0x40300,0x60808088,0x40100,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x200,0x0,0x200,0x0,0x200,0x0,0x0,0x200,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x100,0x0,0x0,0x0,0x0,0x100000,0x100000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2000,0x1,0x40,0x0,0x0,0x0,0x20000,0x4000810,0x9005020,0x1,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10400,0x400000,0x0,0x0,0x0,0x0,0x0,0x400000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x400000,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_init_3() {
      jj_la1_3 = new int[] {0x0,0x10001,0x0,0x4000000,0x1,0x4000000,0x1040,0x8200000,0x1040,0x8000000,0x21804000,0x52000600,0x1804000,0x0,0x0,0x0,0x0,0x800000,0x0,0x0,0x4,0x0,0x4,0x20000000,0x0,0x20000000,0x0,0x20000000,0x40000,0x0,0x20000000,0x0,0x4,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x100000,0x0,0x0,0x0,0x1004000,0x0,0x38,0x0,0x10000,0x0,0x4010000,0x0,0x4,0x0,0x0,0x4,0x0,0x0,0x38,0x8000000,0x8000038,0x38,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0x100100,0x80008000,0x0,0x800,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc02080,0xa0004,0x0,0x10000,0x10000,0x0,0x0,0xa0004,0x4,0x0,0x4,0x10000,0x10000,0x0,0x0,0x80000,0x10000,0x0,0x0,0x10000,0x0,0x0,};
   }
   private static void jj_la1_init_4() {
      jj_la1_4 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10000,0x0,0x0,0x0,0x10000,0x0,0x0,0x10000,0x0,0x10000,0x0,0x0,0x0,0x10000,0x0,0x0,0x0,0x0,0x0,0x10000,0x10000,0x10000,0x0,0x0,0x0,0x0,0x0,0x10000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10000,0x0,0x0,0x0,0x0,0x0,0x0,0x10000,0x10000,0x0,0x10000,0x0,0x0,0x0,0x0,0x10000,0x0,0x10000,0x0,0x0,0x0,0x0,0x0,0x0,0x10000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10000,0x10000,0x10000,0x0,0x0,0x0,0x0,0x10317,0x0,0x0,0x0,0x0,0x0,0x10317,0x10000,0x10000,0x0,0x0,0x0,0x10000,0x0,0x317,0x0,0x0,0x0,0x10000,0x10000,0x0,};
   }
  final private JJCalls[] jj_2_rtns = new JJCalls[84];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  /** Constructor with InputStream. */
  public Parser(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public Parser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new ParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 113; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 113; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public Parser(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new ParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 113; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 113; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public Parser(ParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 113; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(ParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 113; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = jj_lookingAhead ? jj_scanpos : token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      jj_entries_loop: for (java.util.Iterator<?> it = jj_expentries.iterator(); it.hasNext();) {
        int[] oldentry = (int[])(it.next());
        if (oldentry.length == jj_expentry.length) {
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              continue jj_entries_loop;
            }
          }
          jj_expentries.add(jj_expentry);
          break jj_entries_loop;
        }
      }
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[146];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 113; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
          if ((jj_la1_3[i] & (1<<j)) != 0) {
            la1tokens[96+j] = true;
          }
          if ((jj_la1_4[i] & (1<<j)) != 0) {
            la1tokens[128+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 146; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

  private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 84; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
            case 4: jj_3_5(); break;
            case 5: jj_3_6(); break;
            case 6: jj_3_7(); break;
            case 7: jj_3_8(); break;
            case 8: jj_3_9(); break;
            case 9: jj_3_10(); break;
            case 10: jj_3_11(); break;
            case 11: jj_3_12(); break;
            case 12: jj_3_13(); break;
            case 13: jj_3_14(); break;
            case 14: jj_3_15(); break;
            case 15: jj_3_16(); break;
            case 16: jj_3_17(); break;
            case 17: jj_3_18(); break;
            case 18: jj_3_19(); break;
            case 19: jj_3_20(); break;
            case 20: jj_3_21(); break;
            case 21: jj_3_22(); break;
            case 22: jj_3_23(); break;
            case 23: jj_3_24(); break;
            case 24: jj_3_25(); break;
            case 25: jj_3_26(); break;
            case 26: jj_3_27(); break;
            case 27: jj_3_28(); break;
            case 28: jj_3_29(); break;
            case 29: jj_3_30(); break;
            case 30: jj_3_31(); break;
            case 31: jj_3_32(); break;
            case 32: jj_3_33(); break;
            case 33: jj_3_34(); break;
            case 34: jj_3_35(); break;
            case 35: jj_3_36(); break;
            case 36: jj_3_37(); break;
            case 37: jj_3_38(); break;
            case 38: jj_3_39(); break;
            case 39: jj_3_40(); break;
            case 40: jj_3_41(); break;
            case 41: jj_3_42(); break;
            case 42: jj_3_43(); break;
            case 43: jj_3_44(); break;
            case 44: jj_3_45(); break;
            case 45: jj_3_46(); break;
            case 46: jj_3_47(); break;
            case 47: jj_3_48(); break;
            case 48: jj_3_49(); break;
            case 49: jj_3_50(); break;
            case 50: jj_3_51(); break;
            case 51: jj_3_52(); break;
            case 52: jj_3_53(); break;
            case 53: jj_3_54(); break;
            case 54: jj_3_55(); break;
            case 55: jj_3_56(); break;
            case 56: jj_3_57(); break;
            case 57: jj_3_58(); break;
            case 58: jj_3_59(); break;
            case 59: jj_3_60(); break;
            case 60: jj_3_61(); break;
            case 61: jj_3_62(); break;
            case 62: jj_3_63(); break;
            case 63: jj_3_64(); break;
            case 64: jj_3_65(); break;
            case 65: jj_3_66(); break;
            case 66: jj_3_67(); break;
            case 67: jj_3_68(); break;
            case 68: jj_3_69(); break;
            case 69: jj_3_70(); break;
            case 70: jj_3_71(); break;
            case 71: jj_3_72(); break;
            case 72: jj_3_73(); break;
            case 73: jj_3_74(); break;
            case 74: jj_3_75(); break;
            case 75: jj_3_76(); break;
            case 76: jj_3_77(); break;
            case 77: jj_3_78(); break;
            case 78: jj_3_79(); break;
            case 79: jj_3_80(); break;
            case 80: jj_3_81(); break;
            case 81: jj_3_82(); break;
            case 82: jj_3_83(); break;
            case 83: jj_3_84(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
