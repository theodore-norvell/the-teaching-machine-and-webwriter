/* The Teaching Machine - Java Parser
 * JJTree Source
 * 
 * Copyright (C) 2002--2005 Theodore S. Norvell
 * Permission is granted to use this file
 * provided you respect the Sun copyright below
 * and that you understand that there may be
 * errors in this file. 
 * Based on Java1.2-b.jjt (original header follows)
 */

/**
 * Copyright (C) 1996, 1997 Sun Microsystems Inc.
 *
 * Use of this file and the system it is part of is constrained by the
 * file COPYRIGHT in the root directory of this system.  You may, however,
 * make any modifications you wish to this file.
 *
 * Java files generated by running JavaCC on this file (or modified versions
 * of this file) may be used in exactly the same manner as Java files
 * generated from any grammar developed by you.
 *
 * Author: Sriram Sankar
 * Date: 3/5/97
 *
 * This file contains a Java grammar and actions that implement a front-end.
 */


options {
  JAVA_UNICODE_ESCAPE = true;

  STATIC=false;
  MULTI=false;
  VISITOR=true;
  NODE_SCOPE_HOOK=true;
  NODE_USES_PARSER=true;
  COMMON_TOKEN_ACTION = true ;
  //OUTPUT_DIRECTORY = "src/tm/javaLang/parser" ;
  
  //DEBUG_PARSER=true ;
  //DEBUG_TOKEN_MANAGER=true;
}

PARSER_BEGIN(JavaParser)

package tm.javaLang.parser;

import java.util.* ;
import java.io.Reader ;

import tm.clc.analysis.IdTable ;
import tm.clc.analysis.ScopedName ;
import tm.clc.parser.* ;
import tm.javaLang.analysis.Java_SpecifierSet ;
import tm.javaLang.analysis.Java_Specifiers ;
import tm.javaLang.analysis.Java_ScopedName ;
import tm.virtualMachine.CodeStore ;
import tm.interfaces.SourceCoords ;
import tm.utilities.Assert ;
import tm.utilities.Debug ;
import tm.utilities.TMException ;
import tm.utilities.TMFile ;

public class JavaParser { 
        
    IdTable idTable = new IdTable() ;
    
    TMFile file ;
    
    public JavaParser( Reader reader, CodeStore codeStore, TMFile file ) {
        this( reader ) ;
        this.file = file ;
        codeStore.startNewFile( file ) ;
        token_source.setCodeStore( codeStore, file ) ; }
    
    void jjtreeOpenNodeScope(Node n) {
        ((SimpleNode)n).setCoords( new SourceCoords( file, getToken(1).beginLine ) ) ;
    }
    void jjtreeCloseNodeScope(Node n) {
    }
    
    // These flags describe the syntactic context
    // of declarations.
    static final int TOP_LEVEL = 1 ;   
    static final int CONCRETE_CLASS_MEMBER = 2 ;
    static final int ABSTRACT_CLASS_MEMBER = 4 ;
    static final int INTERFACE_MEMBER = 8 ;
    static final int LOCAL = 16 ;

}


PARSER_END(JavaParser)

TOKEN_MGR_DECLS : {
    Colourizer colourizer  ;
    
    void setCodeStore( CodeStore codeStore, TMFile tmFile ) {
        colourizer = new Colourizer( codeStore, tmFile ) ; }
    
    final static int PLAIN = Colourizer.PLAIN,
                     KEYWORD = Colourizer.KEYWORD,
                     COMMENT = Colourizer.COMMENT,
                     CONSTANT = Colourizer.CONSTANT,
                     PREPROCESSOR = Colourizer.PREPROCESSOR,
                     MARKUP = Colourizer.MARKUP ;
    
    private int colourClass = PLAIN ;  // Used to communicate from lex actions
    
    private boolean invisible = false ; // This is true when we are within invisible code. I.e. between /*#I and */
    
    void CommonTokenAction(Token token) {
        colourizer.addToken( token.image, colourClass ) ;
        colourClass = PLAIN ;
    }        
}

////////////
// STATES //
////////////
//       /-------------------------------------------------<-\
//       |                                                   |
//       V        /*#                               */       |
//    DEFAULT -----------> IN_PEDAGOGICAL_COMMENT --------->-+
//    |                                                      |
//    |           //                                 newline |
//    +------------------> IN_SINGLE_LINE_COMMENT --------->-+
//    |                                                      |
//    |      /*                                      */      |
//    +-------------------> IN_MULTI_LINE_COMMENT --------->-+
//    |                                                      |
//    |        /**                                  */       |
//    +--------------------> IN_FORMAL_COMMENT ------------>-+
//    |                                                      |
//    |        /*#I               invisible:=true            |
//    +---------------------------------------------------->-+
//    |                                                      |
//    |   */   if invisible then invisible:=false else error |
//    \---------------------------------------------------->-/


/////////////////
// PRODUCTIONS //
/////////////////

// END OF FILE
<*> TOKEN: // Ensure the file ends with a newline. The colourizer demands this.
{
      < EOF > { matchedToken.image = "\n" ; } : DEFAULT
}

// The following set of productions is duplicated in cplusplusp.jj,
// Except for the first line
<DEFAULT> SPECIAL_TOKEN :
{
//    <PEDAGOGICALMARKUP_DISPLAY_ALL: "/*#D*/" | "/*#/H*/" >
//                        { colourClass = MARKUP ;
//                          colourizer.startAllSelections() ; }
//|   <PEDAGOGICALMARKUP_HIDE_ALL: "/*#H*/"| "/*#/D*/" >
//                        { colourClass = MARKUP ;
//                         colourizer.endAllSelections() ; }
//|
   <PEDAGOGICALMARKUP_DISPLAY_SPECIFIC : "/*#T" (" ")* (["a"-"z","A"-"Z","0"-"9"])+ (" ")* "*/" >
                        { //colourClass = MARKUP ;
                          colourizer.startSelection(
                              CommonParserHelper.extractTagName( matchedToken.image ) ) ; }
|   <PEDAGOGICALMARKUP_HIDE_SPECIFIC: "/*#/T" (" ")* (["a"-"z","A"-"Z","0"-"9"])+ (" ")* "*/" >
                        { //colourClass = MARKUP ;
                          colourizer.endSelection(
                              CommonParserHelper.extractTagName( matchedToken.image ) ) ; }
|   <PEDAGOGICALMARKUP_OTHER: "/*#" >
                        // { colourClass = MARKUP ; }
                        : IN_PEDAGOGICAL_COMMENT
}

<DEFAULT> SKIP  :
{
    <PEDAGOGICALMARKUP_INVISIBLE_ALL: "/*#I" >
    { colourizer.startSelection("s") ;
      invisible = true ; }
}


// Catch the end of an invisible section.
<DEFAULT>SKIP :
{
  "*/" { if( invisible ) { colourizer.endSelection( "s" ) ; invisible = false ; }
         else { throw new ParseException( "Stray */ in code." ) ; } }
}

// Newlines in Pedagogical comments are a bit special. To keep
// The lines in the CodeStore and the lines output by the preprocessor
// synchronized, we send these to the CodeStore.
// This means that pedagogical comments can not be used to hide newlines.
<IN_PEDAGOGICAL_COMMENT> SPECIAL_TOKEN:
{
  "\n"
  {colourClass = PLAIN; CommonTokenAction( matchedToken ) ; } 
}
<IN_PEDAGOGICAL_COMMENT> SKIP : {
   "*/" : DEFAULT
|  < ~[] >
}
/* WHITE SPACE */

<DEFAULT> SPECIAL_TOKEN :
{
  " "   {CommonTokenAction( matchedToken );}
| "\t"  {CommonTokenAction( matchedToken );}
| "\n"  {CommonTokenAction( matchedToken );}
| "\r"  {CommonTokenAction( matchedToken );}
| "\f"  {CommonTokenAction( matchedToken );}
}

/* COMMENTS */

<DEFAULT> MORE :
{
  "//" : IN_SINGLE_LINE_COMMENT
|
  <"/**" ~["/"]> { input_stream.backup(1); } : IN_FORMAL_COMMENT
|
  "/*" : IN_MULTI_LINE_COMMENT
}

<IN_SINGLE_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <SINGLE_LINE_COMMENT: "\n" | "\r" | "\r\n" > 
  {colourClass = COMMENT; CommonTokenAction( matchedToken );}
  : DEFAULT
}

<IN_FORMAL_COMMENT>
SPECIAL_TOKEN :
{
  <FORMAL_COMMENT: "*/" > 
  {colourClass = COMMENT; CommonTokenAction( matchedToken );}
  : DEFAULT
}

<IN_MULTI_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <MULTI_LINE_COMMENT: "*/" >
  {colourClass = COMMENT; CommonTokenAction( matchedToken );}
  : DEFAULT
}

<IN_SINGLE_LINE_COMMENT,IN_FORMAL_COMMENT,IN_MULTI_LINE_COMMENT>
MORE :
{
  < ~[] >
}

/* RESERVED WORDS AND LITERALS */

<DEFAULT> TOKEN :
{
  < ABSTRACT: "abstract" >  { colourClass = KEYWORD ; }
| < ASSERT: "assert" >  { colourClass = KEYWORD ; }
| < BOOLEAN: "boolean" >  { colourClass = KEYWORD ; }
| < BREAK: "break" >  { colourClass = KEYWORD ; }
| < BYTE: "byte" >  { colourClass = KEYWORD ; }
| < CASE: "case" >  { colourClass = KEYWORD ; }
| < CATCH: "catch" >  { colourClass = KEYWORD ; }
| < CHAR: "char" >  { colourClass = KEYWORD ; }
| < CLASS: "class" >  { colourClass = KEYWORD ; }
| < CONST: "const" >  { colourClass = KEYWORD ; }
| < CONTINUE: "continue" >  { colourClass = KEYWORD ; }
| < _DEFAULT: "default" >  { colourClass = KEYWORD ; }
| < DO: "do" >  { colourClass = KEYWORD ; }
| < DOUBLE: "double" >  { colourClass = KEYWORD ; }
| < ELSE: "else" >  { colourClass = KEYWORD ; }
| < EXTENDS: "extends" >  { colourClass = KEYWORD ; }
| < FALSE: "false" >  { colourClass = KEYWORD ; }
| < FINAL: "final" >  { colourClass = KEYWORD ; }
| < FINALLY: "finally" >  { colourClass = KEYWORD ; }
| < FLOAT: "float" >  { colourClass = KEYWORD ; }
| < FOR: "for" >  { colourClass = KEYWORD ; }
| < GOTO: "goto" >  { colourClass = KEYWORD ; }
| < IF: "if" >  { colourClass = KEYWORD ; }
| < IMPLEMENTS: "implements" >  { colourClass = KEYWORD ; }
| < IMPORT: "import" >  { colourClass = KEYWORD ; }
| < INSTANCEOF: "instanceof" >  { colourClass = KEYWORD ; }
| < INT: "int" >  { colourClass = KEYWORD ; }
| < INTERFACE: "interface" >  { colourClass = KEYWORD ; }
| < LONG: "long" >  { colourClass = KEYWORD ; }
| < NATIVE: "native" >  { colourClass = KEYWORD ; }
| < NEW: "new" >  { colourClass = KEYWORD ; }
| < NULL: "null" >  { colourClass = KEYWORD ; }
| < PACKAGE: "package">  { colourClass = KEYWORD ; }
| < PRIVATE: "private" >   { colourClass = KEYWORD ; }
| < PROTECTED: "protected" >  { colourClass = KEYWORD ; }
| < PUBLIC: "public" >  { colourClass = KEYWORD ; }
| < RETURN: "return" >  { colourClass = KEYWORD ; }
| < SHORT: "short" >  { colourClass = KEYWORD ; }
| < STATIC: "static" >  { colourClass = KEYWORD ; }
| < SUPER: "super" >  { colourClass = KEYWORD ; }
| < SWITCH: "switch" >  { colourClass = KEYWORD ; }
| < SYNCHRONIZED: "synchronized" >  { colourClass = KEYWORD ; }
| < THIS: "this" >  { colourClass = KEYWORD ; }
| < THROW: "throw" >  { colourClass = KEYWORD ; }
| < THROWS: "throws" >  { colourClass = KEYWORD ; }
| < TRANSIENT: "transient" >  { colourClass = KEYWORD ; }
| < TRUE: "true" >  { colourClass = KEYWORD ; }
| < TRY: "try" >  { colourClass = KEYWORD ; }
| < VOID: "void" >  { colourClass = KEYWORD ; }
| < VOLATILE: "volatile" >  { colourClass = KEYWORD ; }
| < WHILE: "while" >  { colourClass = KEYWORD ; }
| < STRICTFP: "strictfp" >  { colourClass = KEYWORD ; }
} 

/* LITERALS */

<DEFAULT> TOKEN :
{
  < DECIMAL_LITERAL: (["1"-"9"] (["0"-"9"])* | "0") (["l","L"])? >
  { colourClass = CONSTANT ; } 
|
  < HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ (["l","L"])? >
  { colourClass = CONSTANT ; }
|
  < OCTAL_LITERAL: "0" (["0"-"7"])+ (["l","L"])? >
  { colourClass = CONSTANT ; }
|
  < FLOATING_POINT_LITERAL:
        (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["f","F","d","D"])?
      | "." (["0"-"9"])+ (<EXPONENT>)? (["f","F","d","D"])?
      | (["0"-"9"])+ <EXPONENT> (["f","F","d","D"])?
      | (["0"-"9"])+ (<EXPONENT>)? ["f","F","d","D"]
  >
  { colourClass = CONSTANT ; }
|
  < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
|
  < CHARACTER_LITERAL:
      "'"
      (   (~["'","\\","\n","\r"])
        | <ESCAPESEQ>
      )
      "'"
  >
  { colourClass = CONSTANT ; }
|
  < STRING_LITERAL:
      "\""
      (   (~["\"","\\","\n","\r"])
        | <ESCAPESEQ>
      )*
      "\""
  >
  { colourClass = CONSTANT ; }
|
  < #ESCAPESEQ: "\\" ( ["n","t","b","r","f","\\","'","\""]
                     | ["0"-"7"] ( ["0"-"7"] )?
                     | ["0"-"3"] ["0"-"7"] ["0"-"7"] ) >
}

/* IDENTIFIERS */

<DEFAULT> TOKEN :
{
  < IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>)* >
|
  < #LETTER:
      [
       "\u0024",
       "\u0041"-"\u005a",
       "\u005f",
       "\u0061"-"\u007a",
       "\u00c0"-"\u00d6",
       "\u00d8"-"\u00f6",
       "\u00f8"-"\u00ff",
       "\u0100"-"\u1fff",
       "\u3040"-"\u318f",
       "\u3300"-"\u337f",
       "\u3400"-"\u3d2d",
       "\u4e00"-"\u9fff",
       "\uf900"-"\ufaff"
      ]
  >
|
  < #DIGIT:
      [
       "\u0030"-"\u0039",
       "\u0660"-"\u0669",
       "\u06f0"-"\u06f9",
       "\u0966"-"\u096f",
       "\u09e6"-"\u09ef",
       "\u0a66"-"\u0a6f",
       "\u0ae6"-"\u0aef",
       "\u0b66"-"\u0b6f",
       "\u0be7"-"\u0bef",
       "\u0c66"-"\u0c6f",
       "\u0ce6"-"\u0cef",
       "\u0d66"-"\u0d6f",
       "\u0e50"-"\u0e59",
       "\u0ed0"-"\u0ed9",
       "\u1040"-"\u1049"
      ]
  >
}

/* SEPARATORS */

<DEFAULT> TOKEN :
{
  < LPAREN: "(" >
| < RPAREN: ")" >
| < LBRACE: "{" >
| < RBRACE: "}" >
| < LBRACKET: "[" >
| < RBRACKET: "]" >
| < SEMICOLON: ";" >
| < COMMA: "," >
| < DOT: "." >
}

/* OPERATORS */

<DEFAULT> TOKEN :
{
  < ASSIGN: "=" >
| < GT: ">" >
| < LT: "<" >
| < BANG: "!" >
| < TILDE: "~" >
| < HOOK: "?" >
| < COLON: ":" >
| < EQ: "==" >
| < LE: "<=" >
| < GE: ">=" >
| < NE: "!=" >
| < SC_OR: "||" >
| < SC_AND: "&&" >
| < INCR: "++" >
| < DECR: "--" >
| < PLUS: "+" >
| < MINUS: "-" >
| < STAR: "*" >
| < SLASH: "/" >
| < BIT_AND: "&" >
| < BIT_OR: "|" >
| < XOR: "^" >
| < REM: "%" >
| < LSHIFT: "<<" >
| < RSIGNEDSHIFT: ">>" >
| < RUNSIGNEDSHIFT: ">>>" >
| < PLUSASSIGN: "+=" >
| < MINUSASSIGN: "-=" >
| < STARASSIGN: "*=" >
| < SLASHASSIGN: "/=" >
| < ANDASSIGN: "&=" >
| < ORASSIGN: "|=" >
| < XORASSIGN: "^=" >
| < REMASSIGN: "%=" >
| < LSHIFTASSIGN: "<<=" >
| < RSIGNEDSHIFTASSIGN: ">>=" >
| < RUNSIGNEDSHIFTASSIGN: ">>>=" >
}


/*****************************************
 * THE JAVA LANGUAGE GRAMMAR STARTS HERE *
 *****************************************/

/*
 * Program structuring syntax follows.
 */

SimpleNode CompilationUnit() :
{}
{
  try {
      OptPackageDeclaration()
      ImportDeclarations()
      ( TypeDeclaration() )*
      <EOF>
                    {
                      jjtThis.setString( file.getFileName() ) ;
    		      return jjtThis;
    		    }
  }
  catch( TMException e ) {
        int lineNumber ;
        if( e instanceof ParseException && ((ParseException)e).currentToken != null) {
            lineNumber = ((ParseException)e).currentToken.next.beginLine ; }
        else {
            lineNumber = getToken(0).beginLine ; }
      e.setSourceCoords( new SourceCoords( file, lineNumber ) ) ;
      throw e ; }
  catch( RuntimeException e ) {
       Debug.getInstance().msg(Debug.COMPILE, "Exception thrown while parsing line "+getToken(0).beginLine+" of file "+file.getFileName());
       throw e ; }
  
}

void OptPackageDeclaration() :
{
    ScopedName name ;
}
{
    [
       "package" name = Name() ";"
            { jjtThis.setName( name ) ; }
            { jjtThis.setBoolean( true ) ; }
    ]
}

void ImportDeclarations() :
{}
{
   ( ImportDeclaration() )*
}

void ImportDeclaration() :
{
    ScopedName name ;
}
{
  "import" name = Name()
       { jjtThis.setName( name ) ; }
  [ "." "*" {jjtThis.setBoolean( true );} ] ";"
}

void TypeDeclaration() #void :
{}
{
  LOOKAHEAD( ( "abstract" | "final" | "public" | "strictfp" )* "class" )
  ClassDeclaration(TOP_LEVEL)
|
  InterfaceDeclaration(TOP_LEVEL)
|
  ";"
}


/*
 * Declaration syntax follows.
 */

void ClassDeclaration( int context ) #void :
{
    Java_SpecifierSet specSet = new Java_SpecifierSet() ;
}
{
  ( Static( specSet, context==CONCRETE_CLASS_MEMBER || context==ABSTRACT_CLASS_MEMBER || context==INTERFACE_MEMBER )
  | Abstract( specSet, true )
  | Final( specSet, true )
  | Public( specSet, context==CONCRETE_CLASS_MEMBER || context==ABSTRACT_CLASS_MEMBER || context==INTERFACE_MEMBER || context==TOP_LEVEL ) 
  | Protected( specSet, context==CONCRETE_CLASS_MEMBER || context==ABSTRACT_CLASS_MEMBER ) 
  | Private( specSet, context==CONCRETE_CLASS_MEMBER || context==ABSTRACT_CLASS_MEMBER )
  | Strictfp( specSet, true )
  )*
  { 
    // Add implicit modifiers
    if( context==INTERFACE_MEMBER ) {
        specSet.add( Java_Specifiers.SP_PUBLIC ) ; }
  }
  UnmodifiedClassDeclaration( specSet )
}

void UnmodifiedClassDeclaration( Java_SpecifierSet specSet ) :
{
    ScopedName name ;
}
{
  { jjtThis.setSpecSet( specSet ) ; }
  "class" name=SimpleName()
  { jjtThis.setName( name ) ; }
  OptClassExtendsClause()
  OptImplementsClause()
  ClassBody( specSet.contains( Java_Specifiers.SP_ABSTRACT )
           ? ABSTRACT_CLASS_MEMBER
           : CONCRETE_CLASS_MEMBER )
}

void OptClassExtendsClause() :
{
    ScopedName name ;
}
{
  [ "extends" name=Name() 
    { jjtThis.setName( name ) ; }
    { jjtThis.setBoolean( true ) ; }
  ]
}

void OptImplementsClause() :
{}
{
  [ "implements" NameList()
    { jjtThis.setBoolean( true ) ; }
  ]
}
    

void ClassBody(int context) :
{
  boolean hasConstructor = false ;
  boolean isConstructor ;
}
{
  "{" ( isConstructor = ClassBodyDeclaration(context)
        { hasConstructor = hasConstructor || isConstructor ; }
      )*
  "}"
  { jjtThis.setBoolean( hasConstructor ) ; }
}

boolean ClassBodyDeclaration(int context) #void :
// Returns true iff the declaration is a constructor declaration.
{}
{
  LOOKAHEAD( ["static" ] "{")
  InitializerBlock()
  { return false ; }
|
  LOOKAHEAD( ( "static" | "abstract" | "final" | "public" | "protected" | "private" | "strictfp")* "class" )
  ClassDeclaration( context )
  { return false ; }
|
  LOOKAHEAD( ( "static" | "abstract" | "final" | "public" | "protected" | "private" | "strictfp")* "interface" )
  InterfaceDeclaration(context)
  { return false ; }
|
  LOOKAHEAD( [ "public" | "protected" | "private" ] <IDENTIFIER> "(" )
  ConstructorDeclaration()
  { return true ; }
|
  LOOKAHEAD( MethodDeclarationLookahead() )
  MethodDeclaration( context )
  { return false ; }
|
  FieldDeclaration( context )
  { return false ; }
|
  ";"
  { return false ; }
}

// This production is to determine lookahead only.
void MethodDeclarationLookahead() #void :
{}
{
  ( "public" | "protected" | "private" | "static" | "abstract" | "final" | "native" | "synchronized" | "strictfp")*
  ResultType(null) <IDENTIFIER> "("
}

void InterfaceDeclaration(int context) #void :
{
    Java_SpecifierSet specSet = new Java_SpecifierSet() ;
}
{
  ( Static( specSet, context==CONCRETE_CLASS_MEMBER || context==ABSTRACT_CLASS_MEMBER ||  context==INTERFACE_MEMBER)
  | Abstract( specSet, true )
  | Public( specSet, true )
  | Protected( specSet, context==CONCRETE_CLASS_MEMBER || context==ABSTRACT_CLASS_MEMBER )
  | Private( specSet, context==CONCRETE_CLASS_MEMBER || context==ABSTRACT_CLASS_MEMBER )
  | Strictfp( specSet, true ) )*
  { 
    // Add implicit modifiers
    specSet.add( Java_Specifiers.SP_ABSTRACT ) ;
    if( context==INTERFACE_MEMBER ) {
        specSet.add( Java_Specifiers.SP_PUBLIC ) ; }
  }
  UnmodifiedInterfaceDeclaration( specSet )
}

void UnmodifiedInterfaceDeclaration( Java_SpecifierSet specSet ) :
{
    ScopedName name ;
}
{
  { jjtThis.setSpecSet( specSet ) ; }
  "interface" name=SimpleName()
  { jjtThis.setName( name ) ; }
  OptInterfaceExtendsClause()
  InterfaceBody()
}

void InterfaceBody() :
{}
{
  "{" ( InterfaceMemberDeclaration() )* "}"
}

void OptInterfaceExtendsClause() :
{}
{
  [ "extends" NameList()
    { jjtThis.setBoolean( true ) ; }
  ]
}

void InterfaceMemberDeclaration() # void :
{}
{
  LOOKAHEAD( ( "static" | "abstract" | "final" | "public" | "protected" | "private" | "strictfp")* "class" )
  ClassDeclaration( INTERFACE_MEMBER )
|
  LOOKAHEAD( ( "static" | "abstract" | "final" | "public" | "protected" | "private" | "strictfp")* "interface" )
  InterfaceDeclaration( INTERFACE_MEMBER )
|
  LOOKAHEAD( MethodDeclarationLookahead() )
  MethodDeclaration( INTERFACE_MEMBER )
|
  FieldDeclaration( INTERFACE_MEMBER )
|
  ";"
}

void FieldDeclaration(int context ) #void :
{
    Java_SpecifierSet specSet = new Java_SpecifierSet() ;
}
{
  ( Public( specSet, true )
  | Protected( specSet, context==CONCRETE_CLASS_MEMBER || context==ABSTRACT_CLASS_MEMBER  )
  | Private( specSet, context==CONCRETE_CLASS_MEMBER || context==ABSTRACT_CLASS_MEMBER )
  | Static( specSet, true )
  | Final( specSet, true )
  | Transient( specSet, context==CONCRETE_CLASS_MEMBER || context==ABSTRACT_CLASS_MEMBER )
  | Volatile( specSet, context==CONCRETE_CLASS_MEMBER || context==ABSTRACT_CLASS_MEMBER ) )*
  { 
    // Add implicit modifiers
    if( context==INTERFACE_MEMBER ) {
        specSet.add( Java_Specifiers.SP_PUBLIC ) ;
        specSet.add( Java_Specifiers.SP_FINAL ) ;
        specSet.add( Java_Specifiers.SP_STATIC ) ; }
  }
  Type( specSet ) VariableDeclarator( specSet ) ( "," VariableDeclarator( specSet ) )* ";"
}

void VariableDeclarator( Java_SpecifierSet specSet ) :
{  
    ScopedName name ;
    int arrayDimCount = 0 ; 
}
{
  { jjtThis.setSpecSet( specSet ) ; }
  name = SimpleName()
  { jjtThis.setName( name ) ; }
  ( "[" "]" { arrayDimCount++ ;} )*
  { jjtThis.setInt( arrayDimCount ) ; }
  ( 
    "=" VariableInitializer()
  |
    { if( specSet.contains( Java_Specifiers.SP_FINAL )
       && specSet.contains( Java_Specifiers.SP_STATIC ) ) {
        Assert.error( "static final fields must have initializers" ) ; }
    }
  )
}

void VariableInitializer() :
{}
{
	VariableInitializerVoid()
}

void VariableInitializerVoid() #void :
{}
{
  ArrayInitializer()
|
  Expression()
}

void ArrayInitializer() :
{}
{
  "{" [ VariableInitializerVoid() ( LOOKAHEAD(2) "," VariableInitializerVoid() )* ] [ "," ] "}"
}

void ConstructorDeclaration() :
{
    Java_SpecifierSet specSet = new Java_SpecifierSet() ;
}
{
  [ Public( specSet, true ) | Protected( specSet, true ) | Private( specSet, true ) ]
  ConstructorDeclarator( specSet )
  OptThrowsClause()
  ConstructorBody()
}

void ConstructorDeclarator( Java_SpecifierSet specSet ) :
{ 
    ScopedName name ;
    int arrayDimCount = 0 ; }
{
  { jjtThis.setSpecSet( specSet ) ; }
  name=SimpleName()
  { jjtThis.setName( name ) ; }
  FormalParameters()
}

void OptThrowsClause() :
{}
{
  [ "throws" NameList()
    { jjtThis.setBoolean( true ) ; }
  ]
}   

void MethodDeclaration(int context ) :
{
    Java_SpecifierSet specSet = new Java_SpecifierSet() ;
}
{
  ( Public( specSet, true )
  | Protected( specSet, context==CONCRETE_CLASS_MEMBER || context==ABSTRACT_CLASS_MEMBER )
  | Private( specSet, context==CONCRETE_CLASS_MEMBER || context==ABSTRACT_CLASS_MEMBER )
  | Static( specSet, context==CONCRETE_CLASS_MEMBER || context==ABSTRACT_CLASS_MEMBER )
  | Abstract( specSet, context==ABSTRACT_CLASS_MEMBER || context==INTERFACE_MEMBER )
  | Final( specSet, context==CONCRETE_CLASS_MEMBER || context==ABSTRACT_CLASS_MEMBER )
  | Native( specSet, context==CONCRETE_CLASS_MEMBER || context==ABSTRACT_CLASS_MEMBER )
  | Synchronized( specSet, context==CONCRETE_CLASS_MEMBER || context==ABSTRACT_CLASS_MEMBER )
  | Strictfp( specSet, context==CONCRETE_CLASS_MEMBER || context==ABSTRACT_CLASS_MEMBER )
  )*
  { if(  specSet.contains( Java_Specifiers.SP_ABSTRACT )
      && (  specSet.contains( Java_Specifiers.SP_PRIVATE )
         || specSet.contains( Java_Specifiers.SP_STATIC )
         || specSet.contains( Java_Specifiers.SP_FINAL )
         || specSet.contains( Java_Specifiers.SP_NATIVE )
         || specSet.contains( Java_Specifiers.SP_STRICTFP )
         || specSet.contains( Java_Specifiers.SP_SYNCHRONIZED ) ) ) {
            Assert.error( "abstract method can not be private, static, final, native, strictfp, or synchronized" ) ; }
            
    if(   specSet.contains( Java_Specifiers.SP_NATIVE )
       && specSet.contains( Java_Specifiers.SP_STRICTFP ) ) {
            Assert.error( "native method can not be strictfp" ) ; }
    // Add implicit modifiers
    if( context==INTERFACE_MEMBER ) {
        specSet.add( Java_Specifiers.SP_PUBLIC ) ;
        specSet.add( Java_Specifiers.SP_ABSTRACT ) ; }
  }
  ResultType( specSet )
  MethodDeclarator( specSet )
  OptThrowsClause()
  ( MethodBody()
    { if( specSet.contains( Java_Specifiers.SP_ABSTRACT ) ) {
        Assert.error( "Abstract method has body" ) ; }
      else if( specSet.contains( Java_Specifiers.SP_NATIVE ) ) {
        Assert.error( "Native method has body" ) ; }
    }
  |
    ";"
    { if( ! specSet.contains( Java_Specifiers.SP_NATIVE )
       && ! specSet.contains( Java_Specifiers.SP_ABSTRACT ) ) {
        Assert.error( "Method must have a body unless abstact or native" ) ; }
    }
  )
}

void MethodDeclarator( Java_SpecifierSet specSet ) :
{ 
    ScopedName name ;
    int arrayDimCount = 0 ; }
{
  { jjtThis.setSpecSet( specSet ) ; }
  name=SimpleName()
  { jjtThis.setName( name ) ; }
  FormalParameters()
  ( "[" "]"  {arrayDimCount++;} )*
  { jjtThis.setInt( arrayDimCount ) ; }
}

void FormalParameters() :
{}
{
  "(" [ FormalParameter() ( "," FormalParameter() )* ] ")"
}

void FormalParameter() :
{
    Java_SpecifierSet specSet = new Java_SpecifierSet() ;
    ScopedName name ;
    int arrayDimCount = 0 ;
}
{
  [ Final( specSet, true) ]
  Type( specSet ) 
  { jjtThis.setSpecSet( specSet ) ; }
  name = SimpleName()
  { jjtThis.setName( name ) ; }
  ( "[" "]" { arrayDimCount++ ;} )*
  { jjtThis.setInt( arrayDimCount ) ; }
}

void ConstructorBody() :
{}
{
  "{"
    [ LOOKAHEAD(ExplicitConstructorInvocation()) ExplicitConstructorInvocation() 
      { jjtThis.setBoolean( true ) ; }
    ]
    ( BlockStatement() )*
  "}"
}

void ExplicitConstructorInvocation() #void :
{}
  // TSN 16 Aug 2002.  We could make the two cases easier to distinguish.
{
  LOOKAHEAD("this" Arguments() ";")
  ThisExplicitConstructorInvocation()
|
  SuperExplicitConstructorInvocation()
}

void ThisExplicitConstructorInvocation() :
{}
{
    "this" Arguments() ";"
}

void SuperExplicitConstructorInvocation() :
{}
{
    [ LOOKAHEAD((ExpressionName() | Primary()) ".")  // THINK ABOUT THIS ONE!
      ExpressionNameOrPrimary() "." 
      { jjtThis.setBoolean( true ) ; }
    ] 
    "super" Arguments() ";"
}

void MethodBody() :
{}
{
  "{" ( BlockStatement() )* "}"
}

void InitializerBlock() :
{}
{
  [ "static" {jjtThis.setBoolean( true ) ; } ]
  Block()
}


/*
 * Type, name and expression syntax follows.
 */

void Type( Java_SpecifierSet specSet ) #void :
{
    int arrayDimCount = 0 ;
    ScopedName name ;
}
{
  ( PrimitiveType( specSet )
    | name=Name()  { specSet.add_type_name( name ) ; }
  )
  ( "[" "]" {arrayDimCount++;} )*
  { specSet.setArrayDimCount( arrayDimCount ) ; }
}

void PrimitiveType( Java_SpecifierSet specSet )#void :
{}
  // TSN 16 Aug 2002.  We could note the token.
{
  "boolean"   { specSet.add( Java_Specifiers.SP_BOOLEAN ) ; }
|
  "char"      { specSet.add( Java_Specifiers.SP_CHAR ) ; }
|
  "byte"      { specSet.add( Java_Specifiers.SP_BYTE ) ; }
|
  "short"     { specSet.add( Java_Specifiers.SP_SHORT ) ; }
|
  "int"       { specSet.add( Java_Specifiers.SP_INT ) ; }
|
  "long"      { specSet.add( Java_Specifiers.SP_LONG ) ; }
|
  "float"     { specSet.add( Java_Specifiers.SP_FLOAT ) ; }
|
  "double"    { specSet.add( Java_Specifiers.SP_DOUBLE ) ; }
}

void ResultType( Java_SpecifierSet specSet ) #void :
{}
{
  "void"   { specSet.add( Java_Specifiers.SP_VOID ) ; }
|
  Type( specSet )
}

ScopedName Name() #void :
/*
 * A lookahead of 2 is required below since "Name" can be followed
 * by a ".*" when used in the context of an "ImportDeclaration"
 * and by a .new or .super or .class in expressions
 */
{
    ScopedName name ; 
    String id ;
}
{
  id=Identifier()
  { name = new Java_ScopedName( id ) ; }
  ( LOOKAHEAD(2) "." id=Identifier()
    { name.append( id ) ; }
  )*
  { return name ; }
}

void NameList() #void :
{}
{
  NameNode()
  ( "," NameNode()
  )*
}


void NameNode() :
{
    ScopedName name ;
}
{
    name=Name()
    { jjtThis.setName( name ) ; }
}

/*
 * Expression syntax follows.
 */

void Expression() #void :
/*
 * This expansion has been written this way instead of:
 *   Assignment() | ConditionalExpression()
 * for performance reasons.
 * However, it is a weakening of the grammar for it allows the LHS of
 * assignments to be any conditional expression whereas it can only be
 * a primary expression.  Consider adding a semantic predicate to work
 * around this.
 */
{ Token t ; }
{
  ConditionalExpression()
  [ 
    t=AssignmentOperator()
    Expression()
    {jjtThis.setInt( t.kind ); jjtThis.setString( idTable.inter( t.image ) );} #BinOp(2)
  ] 
}

Token AssignmentOperator() #void :
{ Token t ; }
{
    ( t="=" | t="*=" | t="/=" | t="%=" | t="+=" | t="-=" | t="<<=" | t=">>="
    | t=">>>=" | t="&=" | t="^=" | t="|=" )
    {return t ;}
}

void ConditionalExpression() #void :
{}
{
  (
     ConditionalOrExpression()
     [ "?" Expression() ":" ConditionalExpression() #Conditional( 3 ) ]
  )
}

void ConditionalOrExpression() #void :
{ Token t; }
{
  ConditionalAndExpression()
  ( t="||" ConditionalAndExpression() 
    {jjtThis.setInt( t.kind ); jjtThis.setString( idTable.inter( t.image ) );} #BinOp(2)
  )*
}

void ConditionalAndExpression() #void :
{ Token t; }
{
  InclusiveOrExpression()
  ( t="&&" InclusiveOrExpression()  
    {jjtThis.setInt( t.kind ); jjtThis.setString( idTable.inter( t.image ) );} #BinOp(2)
  )*
}

void InclusiveOrExpression() #void :
{ Token t ; }
{
  ExclusiveOrExpression()
  ( t="|" ExclusiveOrExpression()  
    {jjtThis.setInt( t.kind ); jjtThis.setString( idTable.inter( t.image ) );} #BinOp(2)
  )*
}

void ExclusiveOrExpression() #void :
{ Token t ; }
{
    AndExpression()
    ( t="^" AndExpression()   
       {jjtThis.setInt( t.kind ); jjtThis.setString( idTable.inter( t.image ) );} #BinOp(2)
    )*
}

void AndExpression() #void :
{ Token t ; }
{
  EqualityExpression()
  ( t="&" EqualityExpression()    
    {jjtThis.setInt( t.kind ); jjtThis.setString( idTable.inter( t.image ) );} #BinOp(2)
  )*
}

void EqualityExpression() #void :
{ Token t ; }
{
  InstanceOfExpression()
  ( ( t="==" | t="!=" ) InstanceOfExpression()     
    {jjtThis.setInt( t.kind ); jjtThis.setString( idTable.inter( t.image ) );} #BinOp(2)
  )*
}

void InstanceOfExpression() #void :
{
    Java_SpecifierSet specSet = new Java_SpecifierSet() ;
}
{
  ( RelationalExpression()
    [ "instanceof" Type(specSet)
      { jjtThis.setSpecSet( specSet ) ; }
      #InstanceOf( 1 )
    ]
  ) 
}

void RelationalExpression() #void :
{ Token t ; }
{
  ShiftExpression()
  ( ( t="<" | t=">" | t="<=" | t=">=")
    ShiftExpression()      
    {jjtThis.setInt( t.kind ); jjtThis.setString( idTable.inter( t.image ) );} #BinOp(2)
  )*
}

void ShiftExpression() #void :
{ Token t ; }
{
  AdditiveExpression()
  (  ( t="<<" | t=">>" | t=">>>")
     AdditiveExpression()  
     {jjtThis.setInt( t.kind ); jjtThis.setString( idTable.inter( t.image ) );} #BinOp(2)
  )*
}

void AdditiveExpression() #void :
{ Token t ; }
{
  MultiplicativeExpression()
  (  ( t="+" | t="-")
     MultiplicativeExpression()  
     {jjtThis.setInt( t.kind ); jjtThis.setString( idTable.inter( t.image ) );} #BinOp(2)
  )*
}

void MultiplicativeExpression() #void :
{ Token t ; }
{
  UnaryExpression()
  (  ( t="*" | t="/" | t="%")
     UnaryExpression()  
     {jjtThis.setInt( t.kind ); jjtThis.setString( idTable.inter( t.image ) );} #BinOp(2)
  )*
}

void UnaryExpression() #void :
{ Token t ; }
{
  ( t="+" | t="-") UnaryExpression()
  {jjtThis.setInt( t.kind ); jjtThis.setString( idTable.inter( t.image ) );} #Unary_prefix( 1 )
|
  PreIncDecExpression()
|
  UnaryExpressionNotPlusMinus()
}

void PreIncDecExpression() #void :
{ Token t ; }
{
    t=IncDecOperator() UnaryExpression()
    {jjtThis.setInt( t.kind ); jjtThis.setString( idTable.inter( t.image ) );} #Unary_prefix( 1 )
}


Token IncDecOperator() #void :
{ Token t ; }
{
    ( t="++" | t="--")
    {return t ;}
}

void UnaryExpressionNotPlusMinus() #void :
{ Token t ; }
{
  ( t="~" | t="!") UnaryExpression()
  {jjtThis.setInt( t.kind ); jjtThis.setString( idTable.inter( t.image ) );} #Unary_prefix( 1 )
|
  LOOKAHEAD( CastLookahead() )
  CastExpression()
|
  PostfixExpression()
}

// This production is to determine lookahead only.  The LOOKAHEAD specifications
// below are not used, but they are there to suppress warnings.
void CastLookahead() #void :
{}
{
  LOOKAHEAD(2)
  "(" PrimitiveType( null )
|
  LOOKAHEAD("(" Name() "[")
  "(" Name() "[" "]"
|
  "(" Name() ")" ( "~" | "!" | "(" | <IDENTIFIER> | "this" | "super" | "new" | Literal() )
}

void CastExpression() :
{
    Java_SpecifierSet specSet = new Java_SpecifierSet() ;
}
{
    (   LOOKAHEAD("(" PrimitiveType())
        "(" Type(specSet) ")" UnaryExpression()
    |
        "(" Type(specSet) ")" UnaryExpressionNotPlusMinus()
    )
    { jjtThis.setSpecSet( specSet ) ; }
}

void PostfixExpression() #void :
{ Token t ; }
{
  ExpressionNameOrPrimary()
  [ t=IncDecOperator()
    {jjtThis.setInt( t.kind ); jjtThis.setString( idTable.inter( t.image ) );} #Unary_postfix( 1 )
  ]
}

void ExpressionNameOrPrimary() #void :
{}
{
  LOOKAHEAD( Name() ( "." "class" | "." "new" | "." "this" 
                    | "." "super" "." | "(" | "[" 
                    ) )
  Primary()
|
  LOOKAHEAD( Name() )
  ExpressionName()
| 
  Primary()
}

// An ExpressionName as an expression.
// See JLS chapters 6 and 15.
void ExpressionName() :
{ScopedName name ;}
{
    name = Name()
    { jjtThis.setName( name ) ; }
}
    
    
void Primary() #void :
{}
{
  PrimaryPrefix()
  ( 
    LOOKAHEAD( PrimarySuffixLookahead())
    PrimarySuffix()
  )*
}

void PrimaryPrefix() #void :
{ String id ;}
{
  Literal()
|
  ThisExp()
|
  AllocationExpression()
|
  "(" Expression() ")"             #Parens(1)
|
  SuperPrimaryPrefix() 
|   
  LOOKAHEAD( ResultType() "." "class" )
  ClassExp()
|
  LOOKAHEAD( Name() "[" ) 
  (ExpressionName() "[" Expression() "]") #Subscript(2)
|
  // This choice is not in the JLS 2nd ed. But I think it should be.
  // The situation is analogous to array access expression.
  // Without this choice "(k).new Foo()" is parsable, but not "k.new Foo()".
  LOOKAHEAD( Name() "." "new" )
  ( ExpressionName() "." "new" 
    id = Identifier() Arguments()
    [ ClassBody(CONCRETE_CLASS_MEMBER) ]
    { jjtThis.setString( id ) ; }
  ) #QualifiedAllocationExpression
| 
  NamePrimaryPrefix()
}

void ThisExp() :
{}
{
    "this"
}

// Primary prefixes starting with "super"
void SuperPrimaryPrefix() #void :
{}
{
    LOOKAHEAD( "super" "." <IDENTIFIER> "(" )
    SuperMethodCall()
|
    SuperExp()
}

void SuperMethodCall() :
{   String id ;
}
{
    "super" "." id = Identifier()
        { jjtThis.setString( id ) ; }
    Arguments()
}

void SuperExp() : // Do not change name
{   String id ;
}
{
    "super" "." id = Identifier()
        { jjtThis.setString( id ) ; }
}

void ClassExp() :
{
    Java_SpecifierSet specSet = new Java_SpecifierSet() ;
}
{
  ResultType(specSet) "." "class"
  { jjtThis.setSpecSet( specSet ) ; }
}

// Primary prefixes that start with a name other than subscripts
//  NamePrimaryPrefix --> Name . this
//                      | Name . super . Identifier
//                      | Name . super . Identifier ( ArgumentList_opt )
//                      | Name ( ArgumentList_opt )
void NamePrimaryPrefix() #void :
{ ScopedName name ;
  String id ;
}
{
    name = Name()
    (
        ( Arguments() { jjtThis.setName( name ) ; }        )#MethodNameCall( 1 )
    |
        "."
        (
            ("this" { jjtThis.setName( name ) ; }          ) #ThisExp( 0 )
        |
            "super" "." id = Identifier()
            (
                ( Arguments()
                  { jjtThis.setName( name ) ; }
                  { jjtThis.setString( id ) ; }
                ) #SuperMethodCall( 1 )
            |
                ( { jjtThis.setName( name ) ; }
                  { jjtThis.setString( id ) ; }
                ) #SuperExp(0)
            )
        )
    )
}

void PrimarySuffixLookahead() #void :
// Needed to cut off looping in Primary when parsing an
// explicit constructor invokation.
{}
{
    "[" | "." (<IDENTIFIER> | "new")
}

void PrimarySuffix() #void :
{
    String id ;
    int count =2 ;
}
{
    ("[" Expression() "]"  ) #Subscript(2)
|
    "." 
        (   
            ( "new" id = Identifier() Arguments()
               [ ClassBody(CONCRETE_CLASS_MEMBER) { count++ ; } ]
               { jjtThis.setString( id ) ; }
            ) #QualifiedAllocationExpression(count)
        |
            id = Identifier()
            (
                ( Arguments()
                  { jjtThis.setString( id ) ; }
                ) #MethodCall( 2 )
            |
                ( { jjtThis.setString( id ) ; }
                ) #FieldAccess( 1 )
            )
        )
}

void Literal() :
{
    Token t ;}
{
    (
      t=<DECIMAL_LITERAL>
    |
      t=<HEX_LITERAL>
    |
      t=<OCTAL_LITERAL>
    |
      t=<FLOATING_POINT_LITERAL>
    |
      t=<CHARACTER_LITERAL>
    |
      t=<STRING_LITERAL>
    |
      t="true"
    |
      t="false"
    |
      t="null"
    )
    { jjtThis.setInt( t.kind ) ; }
    { jjtThis.setString( idTable.inter( t.image ) ) ; }
}

void Arguments() :
{}
{
  "(" [ Expression() ( "," Expression() )* ] ")"
}

// AllocationExpression -->
//	new PrimitiveType DimExprs Dimsopt
//	new PrimitiveType Dims ArrayInitializer 
//	new TypeName DimExprs Dimsopt
//	new TypeName Dims ArrayInitializer
//	new ClassOrInterfaceType ( ArgumentListopt ) ClassBodyopt
void AllocationExpression() :
{
    Java_SpecifierSet specSet = new Java_SpecifierSet() ;
    ScopedName name ;
}
{
    (
      // Array ultimately of primitive type.
      LOOKAHEAD(2)
      "new" PrimitiveType(specSet) ArrayDimsAndInits()
    |
      "new" name=Name()
      { specSet.add_type_name( name ) ; }
        (
          // Array ultimately of nonprimitive type.
          ArrayDimsAndInits()
        |
          // Not an array.
          Arguments() [ ClassBody(CONCRETE_CLASS_MEMBER) ]
          {jjtThis.setBoolean( true ) ;}
        )
    )
    {jjtThis.setSpecSet( specSet );}
}

/*
 * The second LOOKAHEAD specification below is to parse to PrimarySuffix
 * if there is an expression between the "[...]".
 */
void ArrayDimsAndInits() :
{
    int arrayDimCount = 0 ;
}
//  If bool parameter is true, then there is an array initializer,
//  which is the only child.
//  For example  new A[][]{{1,2},{3,4}}.
//  If the bool parameter is false then there is no array initiailizer
//  and the children are the array dimensions.
//  For example  new A[3][4][][].
//  In either case the int parameter is the number of "extra"
//  dimensions.  I.e. dimensions in the type, but that are not
//  allocated along.
{
  LOOKAHEAD(2)
  ( LOOKAHEAD(2) "[" Expression() "]" )+
  ( LOOKAHEAD(2) "[" "]" {++arrayDimCount;} )*
  {jjtThis.setInt( arrayDimCount ) ; }
|
  ( "[" "]" {++arrayDimCount;} )+ ArrayInitializer()
  {jjtThis.setInt( arrayDimCount ) ; }
  { jjtThis.setBoolean( true ) ; }
}


/*
 * Statement syntax follows.
 */

void Statement() #void :
{}
{
  LOOKAHEAD(2)
  LabeledStatement()
|
  Block()
|
  EmptyStatement()
|
  ExpressionStatement()
|
  SwitchStatement()
|
  IfStatement()
|
  WhileStatement()
|
  DoStatement()
|
  ForStatement()
|
  BreakStatement()
|
  ContinueStatement()
|
  ReturnStatement()
|
  ThrowStatement()
|
  SynchronizedStatement()
|
  TryStatement()
}

void LabeledStatement() :
{ 
    String label ;
}
{
  label=Identifier() ":" Statement()
  { jjtThis.setString( label ) ; }
}

void Block() :
{}
{
  "{" ( BlockStatement() )* "}"
}

void BlockStatement() #void :
{}
{
  LOOKAHEAD( ( "abstract" | "final" | "public" | "strictfp" )* "class" )
  ClassDeclaration(LOCAL)
|
  LOOKAHEAD( ( "abstract" | "public" | "strictfp" )* "interface" )
  InterfaceDeclaration(LOCAL)
|
  LOOKAHEAD([ "final" ] Type() <IDENTIFIER>)
  LocalVariableDeclaration() ";"
|
  Statement()
}

void LocalVariableDeclaration() # void :
{
    Java_SpecifierSet specSet = new Java_SpecifierSet() ;
}
{
  [ Final( specSet, true ) ]
  Type( specSet ) 
  VariableDeclarator( specSet )
  ( "," VariableDeclarator( specSet ) )*
}

void EmptyStatement() :
{}
{
  ";"
}

void ExpressionStatement() :
{}
{
  StatementExpression() ";"
}


void StatementExpression() #void :
/*
 * This is far more liberal than the JLS. What is the down side?
 */
{ Token t ; }
{
  Expression()
}

void AssertStatement() :
{}
{
  "assert" Expression() 
  [ ":" Expression() { jjtThis.setBoolean( true );} ] ";"
}

void SwitchStatement() :
{}
{
  "switch" "(" Expression() ")" "{"
   ( Case() )*
  "}"
}

void Case() :
{}
{
    SwitchLabel() ( BlockStatement() )*
}

void SwitchLabel() :
{}
{
  "case" Expression() ":"
  { jjtThis.setBoolean( true ) ; }
|
  "default" ":"
}

void IfStatement() :
/*
 * The disambiguating algorithm of JavaCC automatically binds dangling
 * else's to the innermost if statement.  The LOOKAHEAD specification
 * is to tell JavaCC that we know what we are doing.
 */
{}
{
  "if" "(" Expression() ")" Statement() [ LOOKAHEAD(1) "else" Statement() ]
}

void WhileStatement() :
{}
{
  "while" "(" Expression() ")" Statement()
}

void DoStatement() :
{}
{
  "do" Statement() "while" "(" Expression() ")" ";"
}

void ForStatement() :
{}
{
  "for" "(" OptForInit() ";" OptExpression() ";" OptForUpdate() ")" Statement()
}

void OptForInit() :
{}
{
    [ ForInit() { jjtThis.setBoolean( true ) ; } ]
}

void ForInit() :
{}
{
  LOOKAHEAD( [ "final" ] Type() <IDENTIFIER> )
  LocalVariableDeclaration()
  {jjtThis.setBoolean( true ) ; }
|
  StatementExpressionList()
}

void StatementExpressionList() #void :
{}
{
  StatementExpression() ( "," StatementExpression() )*
}

void OptExpression() :
{}
{
    [ Expression() { jjtThis.setBoolean( true ) ; } ]
}

void OptForUpdate() :
{}
{
    [ StatementExpressionList() ]
}

void BreakStatement() :
{
    String label ;
}
{
  "break"
  [ label=Identifier()
    { jjtThis.setBoolean( true ) ; jjtThis.setString(label); }
  ]
  ";"
}

void ContinueStatement() :
{
    String label ;
}
{
  "continue"
  [ label=Identifier()
    { jjtThis.setBoolean( true ) ; jjtThis.setString(label); }
  ]
  ";"
}

void ReturnStatement() :
{}
{
  "return"
  [ Expression() { jjtThis.setBoolean( true );} ] ";"
}

void ThrowStatement() :
{}
{
  "throw" Expression() ";"
}

void SynchronizedStatement() :
{}
{
  "synchronized" "(" Expression() ")" Block()
}

void TryStatement() :
{}
{
  "try" Block()
  ( LOOKAHEAD( "catch" ) Catches() ["finally" Block() { jjtThis.setBoolean( true );}]
  | Catches() "finally" Block() { jjtThis.setBoolean( true );}
  )
}

void Catches() :
{}
{
    ( Catch() )*
}

void Catch() :
{}
{
    "catch" "(" FormalParameter() ")" Block()
}

ScopedName SimpleName() #void :
{
    String id ;
    ScopedName name ;
}
{
    id = Identifier()
        { name = new Java_ScopedName( id ) ; }
        { return name ; }
}

String Identifier() #void :
{
    Token t ;
}
{
    t = <IDENTIFIER>
        { return idTable.inter( t.image ) ; }
}

void Abstract(Java_SpecifierSet specSet, boolean cond) #void :
{}
{
    "abstract"
    { if( ! cond || specSet.contains( Java_Specifiers.SP_ABSTRACT ) )
        Assert.error( "abstract not allowed" ) ; }
    { specSet.add( Java_Specifiers.SP_ABSTRACT ) ; }
}

void Final(Java_SpecifierSet specSet, boolean cond) #void :
{}
{
    "final"
    { if( ! cond || specSet.contains( Java_Specifiers.SP_FINAL ) )
        Assert.error( "final not allowed" ) ; }
    { specSet.add( Java_Specifiers.SP_FINAL ) ; }
}

void Native(Java_SpecifierSet specSet, boolean cond) #void :
{}
{
    "native"
    { if( ! cond || specSet.contains( Java_Specifiers.SP_NATIVE ) )
        Assert.error( "native not allowed" ) ; }
    { specSet.add( Java_Specifiers.SP_NATIVE ) ; }
}

void Public(Java_SpecifierSet specSet, boolean cond) #void :
{}
{
    "public"
    { if( ! cond || specSet.contains( Java_Specifiers.SP_PUBLIC )
        || specSet.contains( Java_Specifiers.SP_PROTECTED ) 
        || specSet.contains( Java_Specifiers.SP_PRIVATE ) )
        Assert.error( "public not allowed" ) ; }
    { specSet.add( Java_Specifiers.SP_PUBLIC ) ; }
}

void Private(Java_SpecifierSet specSet, boolean cond) #void :
{}
{
    "private"
    { if( ! cond || specSet.contains( Java_Specifiers.SP_PUBLIC )
        || specSet.contains( Java_Specifiers.SP_PROTECTED ) 
        || specSet.contains( Java_Specifiers.SP_PRIVATE ) )
        Assert.error( "private not allowed" ) ; }
    { specSet.add( Java_Specifiers.SP_PRIVATE ) ; }
}

void Protected(Java_SpecifierSet specSet, boolean cond) #void :
{}
{
    "protected"
    { if( ! cond || specSet.contains( Java_Specifiers.SP_PUBLIC )
        || specSet.contains( Java_Specifiers.SP_PROTECTED ) 
        || specSet.contains( Java_Specifiers.SP_PRIVATE ) )
        Assert.error( "protected not allowed" ) ; }
    { specSet.add( Java_Specifiers.SP_PROTECTED ) ; }
}

void Static(Java_SpecifierSet specSet, boolean cond) #void :
{}
{
    "static"
    { if( ! cond || specSet.contains( Java_Specifiers.SP_STATIC ) )
        Assert.error( "static not allowed" ) ; }
    { specSet.add( Java_Specifiers.SP_STATIC ) ; }
}

void Strictfp(Java_SpecifierSet specSet, boolean cond) #void :
{}
{
    "strictfp"
    { if( ! cond || specSet.contains( Java_Specifiers.SP_STRICTFP ) )
        Assert.error( "strictfp not allowed" ) ; }
    { specSet.add( Java_Specifiers.SP_STRICTFP ) ; }
}

void Synchronized(Java_SpecifierSet specSet, boolean cond) #void :
{}
{
    "synchronized"
    { if( ! cond || specSet.contains( Java_Specifiers.SP_SYNCHRONIZED ) )
        Assert.error( "synchronized not allowed" ) ; }
    { specSet.add( Java_Specifiers.SP_SYNCHRONIZED ) ; }
}

void Transient(Java_SpecifierSet specSet, boolean cond) #void :
{}
{
    "transient"
    { if( ! cond || specSet.contains( Java_Specifiers.SP_TRANSIENT ) )
        Assert.error( "transient not allowed" ) ; }
    { specSet.add( Java_Specifiers.SP_TRANSIENT ) ; }
}

void Volatile(Java_SpecifierSet specSet, boolean cond) #void :
{}
{
    "volatile"
    { if( ! cond || specSet.contains( Java_Specifiers.SP_VOLATILE ) )
        Assert.error( "volatile not allowed" ) ; }
    { specSet.add( Java_Specifiers.SP_VOLATILE ) ; }
}