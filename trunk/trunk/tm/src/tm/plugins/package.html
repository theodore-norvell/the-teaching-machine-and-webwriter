<html>
<head>
<title>The Teaching Machine Plug-In System</title>
<style type="text/css">
<!--
.style1 {font-family: "Courier New", Courier, mono}
.style3 {font-size: x-small}
.underline {text-decoration: underline}
-->
</style>
</head>
<body>
<h1>The Teaching Machine Plug-In System: Package Overview.</h1>
<p>This document is intended to explain the how to use the Teaching Machine Plug-In System from a general point of view. That is, it does not explain the particular interfaces that represent the services provided to the Teaching Machine by its plug-ins, nor the particular interfaces that represent the services provided by the Teaching Machine to its plug-in. These interfaces are explained in the following companion documents:</p>
<ul>
  <li>TODO add link to document on display plug-ins.</li>
  <li>TODO? add link to document on editor plug-ins. </li>
  <li>TODO?? add link to document on language plug-ins.</li>
</ul>
<h2><a name="TOC"></a>Table of Contents</h2>
<ul>
  <li><a href="#overview">Overview</a></li>
  <li><a href="#multiple">Multiple Plug-Ins</a></li>
  <li><a href="#defining">Defining a Plug-In Category</a></li>
  <li><a href="#designing">Designing Plug-Ins</a> </li>
  <li><a href="#registering">Registering Plug-Ins</a></li>
  <li><a href="#creating">Creating a Plug-In or Two or More</a></li>
  <li><a href="#requirements">Expressing Requirements</a></li>
  <li><a href="#howto">How to ...
    </a>
    <ul>
      <li><a href="#howtohost">How to Write a Host Component</a></li>
      <li><a href="#howtoplugin">How to Write a Plug-in</a></li>
      <li><a href="#howtocombine">How to combine the factory class with the plug-in class</a></li>
      <li><a href="#howtosingleton">How to Write a Singleton Plug-In</a></li>
      <li><a href="#howtogui">How to use the GUI to configure an assemblage of plug-ins </a></li>
    </ul>
  </li>
  <li><a href="#references">References</a></li>
</ul>
<h2><a name="overview"></a>Overview</h2>
<p>A component is a &quot;modular part of a system design that hides its implementation behind a set of external interfaces. Within a system, components satisfying the same interfaces may be substituted freely&quot;. <a href="#r0">[0]</a> </p>
<p>The Teaching Machine is a component-based software system in which certain components, which we call hosts, are able to create and use other components, which we call plug-ins.</p>
<p>Here are two motivating examples:</p>
<ul>
  <li>The TM allows editing of source files. The editor is currently represented to the rest of the system by a class named &quot;PIEditor&quot; which implements an interface named &quot;EditorPIInterface&quot;. If there were another editor --perhaps a bridge to an IDE-- represented by a class that implements the same interface, we would like to be able to use that editor instead. In this case the editor is a plug-in and the &quot;TMBigApplet&quot; is the host.</li>
  <li>The various inner windows of the TM are called &quot;displays&quot; and are created and managed by a display manager. Each kind of display is represented by a class that implements an interface -- DisplayInterface. We would like it to be possible for new displays to be added to the system without having to rewrite the display manager. In this case the display manager is a host and the various displays are plug-ins.</li>
</ul>
<h3>Hosts, Plug-Ins, and Jacks </h3>
<p>Figures 0 and 1 illustrate the situation. They also show that host A0 has two &quot;jacks&quot;, which are named slots into which other components can be placed. We'd like to be able to configure A0 to use either plug-in B0 or plug-in B1 in it's A0:B &quot;jack&quot; and to use any number of plug-ins from the set {C0, C1, C2} in its A0:C jack. </p>
<p>The &quot;shape&quot; of each jack is defined by two interfaces. One interface, the &quot;plug-in interface&quot;, describes the services that the plug-in provides to its host. The second interface, the &quot;context interface&quot;, describes the services the host provides to its plug-in. We can imagine method invocations flowing into the plug-in through the top (plug-in) interface and flowing out of the plug-in through the bottom (context) interface. </p>
<table width="80%"  border="0" cellspacing="0" cellpadding="0">
  <caption align="bottom">
  Figure 0. The components
  </caption>
  <tr>
    <td><div align="center"><img src="doc-files/Plugin-0.png" width="587" height="296"> </div></td>
  </tr>
</table>
<table width="80%"  border="0" cellspacing="0" cellpadding="0">
  <caption align="bottom">
  Figure 1. The configured system 
  </caption>
  <tr>
    <td><div align="center"><img src="doc-files/Plugin-1.png" width="308" height="247"> </div></td>
  </tr>
</table>
<h3>Configuration times </h3>
<p>We can replace  plug-in B0 with plug-in B1 at various times.</p>
<ul>
  <li><strong>Coding Time.</strong> The most common approach used to replace one component with another is to replace at <em>coding time</em>. For simplicity let's suppose that component B0 is composed of a single class, <span class="style1">B0</span>, or at least represented to the rest of the system by that single class (see the Facade pattern <a href="#r1">[1]</a>). Then usually what we do to replace B0 with B1 is to find all mentions of class <span class="style1">B0</span> in component A0 and replace them with mentions of <span class="style1">B1</span>. If we were careful about writing A0, then <span class="style1">B0</span> and <span class="style1">B1</span> both implement a common Java interface, let's say <span class="style1">BInterface</span>, and the only place where we have to mention <span class="style1">B0</span> or <span class="style1">B1</span> is when we construct new <span class="style1">BInterface</span> objects.  I.e. we replace
    <div align="center">
      <pre>BInterface b = new <u>B0</u>() ;</pre>
    </div>
    with
    <div align="center">
      <pre>BInterface b = new <u>B1</u>() ;</pre>
    </div>
  everywhere a B0 is constructed. Java's interfaces are solve most of the problem of host components not needing to know the implementation of their plug-in components, but not the issue of constructing the component in the first place. If such objects are created in several places, then we might use a factory object (see the Factory Method pattern), which only needs to be created once. Let's suppose the factory class is called either <span class="style1">B0Factory</span> or <span class="style1">B1Factory</span>, depending on the component. There is still at least one line in the code that has to be edited and recompiled each time we decide to change the implementation of the B component. E.g. we might replace
      <pre>
  BFactoryInterface bFactory = <strong>new</strong> <u>B0Factory</u>() ;
  ...
  BInterface bx = <strong>new</strong> bFactory.createBComponent() ;
  ...
  
  BInterface by = <strong>new</strong> bFactory.createBComponent() ;
  ...
      </pre>
    with
    <pre>
  BFactoryInterface bFactory = <strong>new</strong> <u>B1Factory</u>() ;
  ...
  BInterface bx = <strong>new</strong> bFactory.createBComponent() ;
  ...
  
  BInterface by = <strong>new</strong> bFactory.createBComponent() ;
  ...</pre>
  The disadvantages of replacement at coding time are (a) that it can not be done by the end-user and (b) it disrupts the code base -- each configuration of the plug-ins requires a different version of the host.</li>
  <li><strong>Link Time.</strong> It is possible to replace B0 by B1 at <em>link time</em>. In Java this can be done by putting B1 in the jar file instead of B0, or by fiddling with the order of the entries on a class path. In this solution, both components should be represented by classes of the same name, so as to avoid the need to do any recoding and recompilation. This solution is not particularly satisfactory, as it requires us to maintain at least two classes with the same name and different implementations. Also, it is of no help when we want multiple components that fill the same role.</li>
  <li><strong>Run time.</strong> Java's reflection mechanism offers a way of deciding at <em>run time</em> which class to instantiate.  It allows us to turn a string, say <span class="style1">&quot;B0Factory&quot;</span> or <span class="style1">&quot;B1Factory&quot;</span> into an object of class <span class="style1">java.lang.Class</span> and then, from that, to create an object of type <span class="style1">B0Factory</span> or <span class="style1">B1Factory</span>. If that string is fetched from a configuration file, rather than being hard-coded into the program, then no recoding is needed to replace B0 by B1; it's just a change to a configuration file. However, digging class names out of files and using the reflection classes is a messy bit of coding that should be isolated in one place, rather than being duplicated everywhere that one component wants to create another component. So we put all that messy stuff in one place, which is the TM Plug-In System. </li>
</ul>
<h3>Anonymity, Factories, and the Teaching Machine Plug-in System </h3>
<p>If A can use B without mentioning (i.e., having hard-coded within it) the name of the classes that make up B, then A uses B &quot;anonymously&quot;. &quot;Use&quot; really means: creating the component, storing pointers to it, and/or invoking its methods. Thanks to Java's interface concept we can store pointers to an object without mentioning its class and we can invoke its methods without mentioning its class. However there is no simple way to create objects without depending on its class. Of course, we can replace a call</p>
<pre>    BInterface b = <strong>new</strong> B0( bContext ) ;</pre>
<p>with a call to a factory object </p>
<pre>    BFactoryInterface bFactory = <strong>new</strong> B0Factory() ;
    BInterface b = bFactory.create( bContext ) ;
</pre>
<p>However, this is just moving the problem back one step as we now have to mention the name of the appropriate factory. Our code no longer depends on <span class="style1">B0</span>, directly, but it still depends on <span class="style1">B0</span> indirectly via <span class="style1">B0Factory</span>, which presumably contains a call to <span class="style1">B0</span>'s constructor. </p>
<p>Nevertheless, using a factory is an improvement for three reasons. (a) It allows us to concentrate the dependence problem in one spot, even if BInterface objects are created in multiple places. (b) It also allows us to employ the Abstract Factory pattern <a href="#r1">[1]</a> when needed. The Abstract Factory pattern uses one factory to construct a suite of compatible objects. For example: </p>
<pre>    WindowFactoryInterface windowFactory = <strong>new</strong> XWinFactory() ;

    WindowInterface window = windowFactory.createWindow( windowContext ) ;
    ScrollBarInterface scrollBar = windowFactory.createScrollBar( window ) ;</pre>
<p>(c) Creation of factories is, in general, simpler than creation of plug-ins. The plug-in's constructor might take parameters of any number and type. We might even want to give a choice of variety of constructors for each plug-in class. Furthermore contructors can throw arbitrary exceptions. Usually factories don't need constructor parameters, and in the cases where they do, they can be fairly simple in nature.  Furthermore there is little reason to throw an exception while constructing a factory. Point (c) is not important if we use coding time replacement, but it <em>is</em> important if we use run-time replacement. It is advantageous if the things you create via reflection are simple and uniform to create.</p>
<p>Aside: Fans of the Gamma et al. <a href="http://www.awprofessional.com/title/0201633612">Design Patterns</a> book <a href="#r1">[1]</a> will recognize that we are using their Factory Method pattern. What I've been calling a &quot;plug-in&quot;, they call a &quot;product&quot;; and what I've been calling a &quot;factory&quot;, they call a &quot;creator&quot;.</p>
<p>The TM Plug-In System implements run-time replacement of components. We call these components &quot;plug-ins&quot;. The TM Plug-In System confines itself to problems of anonymous creation of plug-in factories, as Java's interface concept handles anonymous messaging of plug-ins and anonymous storage of pointers to plug-ins quite adequately.</p>
<p>As will be seen in detail below, we'll replace the lines</p>
<pre>    BFactoryInterface bFactory = <strong>new</strong> B0Factory() ;
    BInterface b = bFactory.create( bContext ) ;
</pre>
<p>of the coding-time solution with (roughly) the following code </p>
<pre>    BPIFactoryInterface bFactory = PlugInManager.getSingleton().getFactory( &quot;A0:B&quot; ) ;
    BPlugInInterface b = bFactory.createPlugIn( bContext ) ;
</pre>
<p>to get a run-time solution. The PlugInManager object is responsible for maintaining the mapping from strings, such as &quot;A0:B&quot;, to classes, such as B0Factory or B1Factory. The strings are called &quot;jack names&quot; and we say that the given factory is plugged into the jack. Initially the mapping is established by reading a configuration file; we also provide a GUI that lets the user interactively change the mapping.</p>
<p><span class="style3">(The fine print: In fact creating a factory is a bit more complex than the above single line suggests; there are more parameters to the getFactory method and there are exceptions to worry about; but, in essence, it is this simple. All the nasty details will be explained later)</span> </p>
<h2><a name="multiple"></a>Multiple Plug-Ins</h2>
<p>Another aspect of plug-ins, touched on in the previous section, is that we might want more than one plug-in to provide the same service at once. Suppose that component A0 uses other components to provide views (i.e. visual representation) of some data. Well we might want to show the user multiple views at once. A0 might use components C0, C1, C2 all at the same time. Furthermore, if each C2 object provides a view along a single 3-D axis, we might want 3 of them. If we used coding-time replacement, we might write part of A0 like this: </p>
<pre>       CInterface [] view = <strong>new</strong> CInterface[5] ;
       view[0] = <strong>new</strong> C0(context) ;
       view[1] = <strong>new</strong> C1(context) ;
       view[2] = <strong>new</strong> C2(&quot;x&quot;, cContext) ;
       view[3] = <strong>new</strong> C2(&quot;y&quot;, cContext) ;
       view[4] = <strong>new</strong> C2(&quot;z&quot;, cContext) ;
</pre>
<p>If we wanted to use factories, we could code it like this: </p>
<pre>       CPIFactoryInterface[] viewFactories = <strong>new</strong> CPIFactoryInterface[]{
           <strong>new</strong> C0Factory(),
           <strong>new</strong> C1Factory(),
           <strong>new</strong> C2Factory(&quot;x&quot;),
           <strong>new</strong> C2Factory(&quot;y&quot;),
           <strong>new</strong> C2Factory(&quot;z&quot;) } ;
       CInterface [] view = <strong>new</strong> CInterface[ viewFactories.length ] ;
       <strong>for</strong>( <strong>int</strong> i = 0 ; i &lt; view.length ; ++i )
           view[i] = viewFactory[i].createPlugIn( cContext ) ;</pre>
<p>Using the TM plug-in system, we can plug several components into the same &quot;jack&quot; to achieve this effect. A0 can be coded oblivious to the number of --and classes of-- factories that are plugged into its &quot;A0:C&quot; jack. Using the TM Plug-In System, <span class="style3">(and again ignoring some of the details)</span> the code we'll write in A0 will look roughly like this: </p>
<pre>         List&lt;CPIFactoryInterface&gt; viewFactories
             = PlugInManager.getSingleton().getFactoryList( &quot;A0:C&quot; ) ;
         CPlugInInterface [] view = <b>new</b> CPlugInInterface[ viewFactories.size() ] ;
         <b>for</b>( <b>int</b> i = 0 ; i &lt; fs.size() ; ++i ) {
             view[i] = viewFactories.get(i).createPlugIn( cContext ) ;
</pre>
<h2><a name="defining"></a>Defining a Plug-In Category </h2>
<p>Each category of plug-ins is typically defined by three interfaces. These are:</p>
<ul>
  <li><strong>The Plug-In  Interface</strong>: The plug-in interface describes the service that the plug-ins will provide to its host. By convention the plug-in interface is named <span class="style1">XPlugInInterface</span> or <span class="style1">XPIInterface</span>. Each plug-in object implements the plug-in interface. </li>
  <li><strong>The Context Interface</strong>: The context interface represents the services that the plug-in will require from its host. Say the plug-ins are going to display some data, then they will probably obtain that data via an object implementing the context interface. Say the plug-in is a UI object with buttons and text fields. Then notifications of clicks on buttons and changes to text fields would probably be sent to an object implementing the context interface. By convention the context interface is named <span class="style1">XContextInterface</span>. In some cases, we don't need this interface as the context is known to always be of a particular class; in that case we use that class instead. On occasion you know that the plug-ins will not need any context (now or in the future); in that case it is ok to have no context interface.</li>
  <li><strong>The Factory Interface</strong>: This is an interface for creating plug-in objects. The job of the factory interface is to declare the factory method. The factory objects must implement the factory interface. By convention the factory interface is named <span class="style1">XPlugInFactoryInterface</span> or <span class="style1">XPIFactoryInterface</span>. Factory interfaces must extend interface <span class="style1">tm.plugins.PlugInFactory</span>.</li>
</ul>
<p>If the factory implements the Abstract Factory pattern <a href="#r1">[1]</a> with <em>n</em> different kinds of products, then there would be one factory interface but (typically) <em>n</em> plug-in interfaces and up-to <em>n</em> context interfaces. (As the Window example shown earlier illustrates, the same interface might play more than one role; in that case a window object provides context to a scrollbar.) </p>
<p>When we don't have the Abstract Factory pattern (i.e. there is only one product type), the convention is to name the factory method <span class="style1">createPlugIn</span>. This is only a convention, you can call factory methods whatever you want. </p>
<p>Aside: As a result of the use of factories, instances of PlugInManager do not manage plug-ins at all, but rather factories. Thus the class is, perhaps, somewhat misnamed. [Perhaps some day we will rename is as PlugInFactoryManager.]</p>
<p>Let's look at an example. Recall that component A0 can host plug-ins of kind C. These are intended to represent some sort of view on some sort of data. The plug-in interface and  the context interface might be given as </p>
<pre>   <strong>public</strong> <strong>interface</strong> CPlugInInterface {
       <strong>public</strong> java.awt.Component getComponent() ;
	     ...
   }

   <strong>public</strong> <strong>interface</strong> CContextInterface {
       <strong>public</strong> SomeKindOfData getData() ;
	     ...
   }
</pre>
<p>Finally the factory interface declares the factory method</p>
<pre>   <strong>public</strong> <strong>interface</strong> CPIFactoryInterface <strong>extends</strong> tm.plugins.PlugInFactory {
      /** Factory method. */
      <strong>public</strong> CPlugInInterface createPlugIn( CPlugInContext theData ) ;
   }</pre>
<h2><a name="designing"></a>Designing Plug-Ins </h2>
<p>Let's continue the example of the previous section. We need three implementations of the plug-in interface. I'll assume that they are given by classes C0, C1, and C2. We also need 3 factory classes for constructing plug-ins of types C0, C1, and C2 respectfully. We can create three implementations of the factory interface, one for each of C0, C1, and C2. (We don't implement the context interface, of course; it is the job of the host designer to implement that.) Here is the first factory </p>
<pre>    <strong>public</strong> <strong>class</strong> C0Factory <strong>implements</strong> CPIFactoryInterface {
             <strong>private static</strong> C0Factory singleton = <strong>null</strong> ;
			 
             <strong>private</strong> C0Factory() {} 
    
             <strong>static</strong> <strong>public</strong> C0Factory createInstance( String ignored ) {
                  <strong>if</strong>( singleton == <strong>null</strong>) singleton = <strong>new</strong> C0Factory()
                  <strong>return</strong>  singleton;
             }
    
             <strong>public</strong> CPlugInInterface createPlugIn(CPlugInContext context) {
                 <strong>return</strong> <strong>new</strong> C0( context ) ;
             }

             <strong>public</strong> Requirement[] getRequirements() {
                 <strong>return</strong> <strong>new</strong> Requirement[0];
             }
    }
</pre>
<p>You can see that the <span class="style1">createPlugIn</span> method is implemented to create a <span class="style1">C0</span> object. You can also see that the factory must be created using a static method called <span class="style1">createInstance</span>. The plug-in system will call the <span class="style1">createInstance</span> method to create  the factory objects. (The rationale for using a static method in preference to a constructor is that it allows the factory objects to be singletons, if that is the wish of the designer.) The <span class="style1">createInstance</span> method takes a string parameter which, in this case is ignored. [To do: In the future, the parameter to <span class="style1">createInstance</span> may be more flexible, e.g. to allow 0 or more string parameters. Until then there has to be exactly one parameter and it must be of type string.] </p>
<p>The <span class="style1">getRequirements</span> method is used to indicate what kinds of plug-ins <span class="style1">C0</span> objects will need. It will be described later. In this case, C0 is not a host, so it has no requirements. </p>
<p>The <span class="style1">C0</span> class, although it is an actual plug-in class, is not particularly interesting for our purposes. Its interface depends on the needs of component A0 and its implementation depends on what it does. For the example, it is sufficient to assume <span class="style1">C0</span> is  some class that implements <span class="style1">CPlugInInterface</span> and <span class="style1">CPlugInInterface</span> represents some service that component A0 needs other components to do for it. The content of the <span class="style1">CPlugInInterface</span> and how <span class="style1">C0</span>, in particular, implements it are very important to the designers of the A0 and C0 components; but not to us. We are interested in how the C0 objects get created, but once they are created, the plug-in system has no further role. There are no particular constraints on the plug-in classes; in particular there is no single interface that all plug-in objects must implement. Looking just at a plug-in class you would never know that it is a plug-in class.</p>
<p><span class="style1">C1Factory</span> is similar to <span class="style1">C0Factory</span>, except it creates C1 objects rather than C0 objects. </p>
<p><span class="style1">C2Factory</span> is a bit different. Its constructor take a string parameter, and so it can not be a singleton. This string parameter's value is the same as the parameter passed into the <span class="style1">createInstance</span> method. Factory classes can use this string parameter for any purpose. In this particular example, it is simply passed on to the plug-in object. Ultimately this string parameter will be supplied by the user who is configuring the set of plug-ins for their system. This extra parameter allows the same factory class to be reused to create any number of different factory objects that can have slightly different behaviours.</p>
<pre>    <strong>public</strong> <strong>class</strong> C2Factory implements CPIFactoryInterface {

             <strong>private</strong> String parameter ; 
			 
             <strong>private</strong> C2Factory(String parameter) { <strong>this</strong>.parameter = parameter; } 
    
             <strong>static</strong> <strong>public</strong> C2Factory createInstance( String parameter ) {
                  <strong>return</strong> <strong>new</strong> C2Factory( parameter) ;
             }
    
             <strong>public</strong> CPlugInInterface createPlugIn(CPlugInContext context) {
                 <strong>return</strong> <strong>new</strong> C2( parameter, context ) ;
             }

             <strong>public</strong> Requirement[] getRequirements() {
                 <strong>return</strong> <strong>new</strong> Requirement[0];
             }
    }
</pre>
<h2><a name="registering"></a>Registering Plug-Ins</h2>
<p>Normally the registration of plug-ins is done initially via a GUI. For our example system, we will create the following registrations.</p>
<table width="80%"  border="1" cellspacing="0" cellpadding="0">
  <tr>
    <td><strong>Jack Name</strong></td>
    <td><strong>Class</strong></td>
    <td><strong>Parameter</strong></td>
  </tr>
  <tr>
    <td>Main:A</td>
    <td>A0Factory</td>
    <td>&quot;&quot;</td>
  </tr>
  <tr>
    <td>A0:B</td>
    <td>B0Factory</td>
    <td>&quot;&quot;</td>
  </tr>
  <tr>
    <td>A0:C</td>
    <td>C0Factory</td>
    <td>&quot;&quot;</td>
  </tr>
  <tr>
    <td>A0:C</td>
    <td>C1Factory</td>
    <td>&quot;&quot;</td>
  </tr>
  <tr>
    <td>A0:C</td>
    <td>C2Factory</td>
    <td>&quot;x&quot;</td>
  </tr>
  <tr>
    <td>A0:C</td>
    <td>C2Factory</td>
    <td>&quot;y&quot;</td>
  </tr>
  <tr>
    <td>A0:C</td>
    <td>C2Factory</td>
    <td>&quot;z&quot;</td>
  </tr>
</table>
<p>The convention for jack names is the name of the component that requires (creation of) the plug-in, a colon, and then the name of the role that the plug-in will play.</p>
<p>In the example, I've assumed that A0 is itself a plug-in to the Main component.</p>
<p>The registrations are recorded in a singleton object of class <span class="style1">PlugInManager</span>. The <span class="style1">PlugInManager</span> is responsible for creating the factory objects the first time they are needed. </p>
<h2><a name="creating"></a>Creating a Plug-In or Two or More</h2>
<p>What about the host A0? How do we code it? The whole point of this exercise is to create plug-in objects without using the &quot;<strong>new</strong>&quot; operation. Instead A0 asks the <span class="style1">PlugInManager</span> singleton object to return a plug-in factory. (I say &quot;return&quot; rather than &quot;create&quot;, as the manager creates factories only as needed and caches the factories.) </p>
<p>Now in component A0, we can create the B component with the following code, the purpose of which is to initialize variable <span class="style1">bPlugIn</span> of type <span class="style1">BPlugInInterface</span>:</p>
<pre>
 <b>try</b> {
     <i>// 0. Obtain the plug-in manager</i>
        PlugInManager thePlugInManager = PlugInManager.getSingleton() ;
    <i>// 1. Obtain a factory object from the plug-in manager</i>
        BPIFactoryInterface factory
           = <span class="underline">thePlugInManager.getFactory( &quot;A0:B&quot;, BPIFactoryInterface.<b>class, true</b> )</span> ;
    <i>// 2. Construct a new plug-in from the factory</i>
        bPlugIn = factory.createPlugIn( bContext ) ; }
 <b>catch</b>( PlugInNotFound ex ) {
    <i>...deal with it... </i> }
</pre>
<p>The key call here is to <span class="style1">PlugInManager.getFactory</span> (line 1.); it returns a factory capable of creating the plug-in.</p>
<ul>
  <li>The first parameter is the jack name under which the plug-in factory is expected to be registered</li>
  <li> The second parameter is the interface (represented by a <span class="style1">Class</span> object) which the plug-in factory is expected to implement; it must extend <span class="style1">PlugInFactory</span>. </li>
  <li>The third parameter indicates that the plug-in is mandatory. If that parameter is <strong>false</strong>, then getFactory will return <strong>null</strong>, should there be no plug-ins registered; if it is <strong>true</strong>, the method will not return <strong>null</strong>, but throws a PlugInNotFound exception, should there be no plug-in registered.</li>
  <li>The object returned from this method is guaranteed to implement the  interface passed as the second argument. No cast of the returned value is needed, as <span class="style1">getFactory</span> is a generic method whose return type is that same as its second argument. (Ain't generics fun!) </li>
</ul>
<p>The call to <span class="style1">getFactory</span> can fail in numerous ways.</p>
<ul>
  <li>There may be no factories registered under the given jack name. This is only a failure if the third (isMandatory) argument is <strong>true</strong>.</li>
  <li>There may be more than one factory registered under the given jack name.</li>
  <li>A factory class can not be loaded. E.g., the class is not on the classpath.</li>
  <li>A factory class does not have a static, public method called <span class="style1">createInstance</span> that takes a single <span class="style1">String</span> argument.</li>
  <li>A call to <span class="style1">createInstance</span> throws rather than returning.</li>
  <li>A call to <span class="style1">createInstance</span> returns an object that does not implement the expected interface (the second argument). </li>
</ul>
<p>In all cases the failure is reported with an exception of type <span class="style1">PlugInNotFound</span>.</p>
<p>The above sequence works fine when the host component expects there to be exactly one plug-in for the jack name. If zero or one plug-in factories are expected we can modify the sequence slightly: </p>
<pre>
 <b>try</b> {
     <i>// 0. Obtain the plug-in manager</i>
        PlugInManager thePlugInManager = PlugInManager.getSingleton() ;
    <i>// 1. Obtain a factory object from the plug-in manager</i>
        BPIFactoryInterface factory
           = thePlugInManager.getFactory( &quot;A0:B&quot;, BPIFactoryInterface.<b>class, <span class="underline">false</span></b> ) ;
    <i>// 2. Construct a new plug-in from the factory</i>
        bPlugIn = <span class="underline">factory==<strong>null</strong> ? <strong>null</strong> :</span> factory.createPlugIn( bContext ) ; }
 <b>catch</b>( PlugInNotFound ex ) {
    <i>...deal with it... </i> }
</pre>
<p>When more than one factory may be plugged-into the jack, we use a sequence like the following, the purpose of which is to initialize an array <span class="style1">cPlugIns</span>:</p>
<pre>
 <b>try</b> {
     <i>// 0. Obtain the plug-in manager</i>
         PlugInManager thePlugInManager = PlugInManager.getSingleton() ;
     <i>// 1. Obtain a list of factory objects from the plug-in manager</i>
         List&lt;CPIFactoryInterface&gt; factories
            = <span class="underline">thePlugInManager.getFactoryList( &quot;A0:C&quot;, CPIFactoryInterface.<b>class</b>, <strong>false</strong> )</span> ;
     <i>// 2. Construct new plug-ins from the factories</i>
         cPlugIns = <b>new</b> CPlugInInterface[ factories.size() ] ;
         <b>for</b>( <b>int</b> i = 0 ; i &lt; fs.size() ; ++i ) {
             cPlugIns[i] = factories.get(i).createPlugIn( cContext ) ;
 <b>catch</b>( PlugInNotFound ex ) {
     <i>...deal with it...</i> }
</pre>
<p>
The <span class="style1">getFactoryList</span> method is similar to <span class="style1">getFactory</span>, except it returns a list of factories.  Not surprisingly, it does not fail when there is more than one factory registered. Depending on its third parameter (isMandatory), it will either fail or return an empty list, should there be no factories registered. </p>

<h2><a name="requirements"></a>Expressing Requirements</h2>
<p>The existence of certain plug-ins in the system might place requirements on the existence of other plug-ins in the system. For example an &quot;executive&quot; plug-in might require exactly one &quot;model&quot; plug-in and 1 or more &quot;view&quot; plug-ins. Furthermore, the model plug-in factory must implement a particular interface (extending <span class="style1">PlugInFactory</span>) while the view plug-in factories must implement a different interface. In our running example, suppose that the A0 component is a plug-in created by a factory class <span class="style1">A0Factory</span>. Let's further suppose that the A0 plug-in requires there to be exactly 1 B components, whose factory must implement BPIFactoryInterface, and any number of C components, whose factories all must implement CPIFactoryInterface. It would be nice if these requirements could be stated and checked for fulfillment when the set of plug-ins is specified. This is done via the getRequirements method of the factory classes. We would write <span class="style1">A0Factory</span> as follows</p>
<pre>
<strong>public</strong> <strong>class</strong> A0Factory <strong>implements</strong> APIFactoryInterface {

    <strong>private</strong> Requirement[] requirements = <strong>new</strong> Requirement[] {
            <strong>new</strong> Requirement(&quot;A0:B&quot;, BPIFactoryInterface.<strong>class</strong>, <strong>true</strong>, <strong>false</strong> ),
            <strong>new</strong> Requirement(&quot;A0:C&quot;, CPIFactoryInterface.<strong>class</strong>, <strong>false</strong>, <strong>true</strong> ) } ;
    
    <strong>public</strong> APlugInInterface createPlugIn() {
        <strong>return</strong> new A0();
    }

    <strong>public</strong> Requirement[] getRequirements() {
        <strong>return</strong> requirements ;
    }
}
</pre>
<p>The <span class="style1">getRequirements</span> method returns an array of two <span class="style1">Requirement</span> objects. The first represents that A0 requires that a jack named &quot;A0:B&quot; be filled by exactly one plug-in and that its factory implements <span class="style1">BPIFactoryInterface</span>. The second represents that that A0 requires that a jack named &quot;A0.C&quot; be filled by any number of plug-ins, but that they all have factories that implement <span class="style1">CPIFactoryInterface</span>. The parameters to the constructor of Requirement are as follows:</p>
<ul>
  <li>Jack Name: A string. </li>
  <li>Interface Required. An interface that extends PlugInFactory.</li>
  <li>Is Mandatory. A boolean indicating whether at least 1 plug-in factory must be registered.</li>
  <li>Is Multiple. A boolean indicating whether more than 1 plug-in factory is allowed.</li>
</ul>
<p>That the requirements are fulfilled is checked by the GUI, so that violations can be reported to the user, as he or she specifies a set of plug-ins. For example, if you unplug the last factory from jack &quot;A0:B&quot;, you will be warned. If you plug a factory into the &quot;A0:C&quot; that does not implement CPIFactoryInterface, you will be warned. The GUI also checks that the factory classes actually exist and can be instantiated via <span class="style1">createInstance</span>.</p>
<p>The consistency of the requirements as stated in the factory vs the reality coded into the host is not checked. This is left to the programmer.  For example, the requirement for jack &quot;A0:C&quot; says that multiple factories can be plugged into that jack. But I could still make a call to getFactory with a first argument of &quot;A0:C&quot; instead of calling getFactoryList. Similarly, I could call getFactoryList and ask for a factory of the wrong type. In this case, though, there would almost certainly be a compile-time type error reported.</p>
<p>What about the requirements of the root component?. In every system of components, there has to be at least one component that is the root of the host/plug-in tree. It is not itself a plug-in, but it will have requirements. The trick is to create a factory class that represents this component. In the Teaching Machine, it is called <span class="style1">TMBigAppletPIFactory</span>. This root factory has requirements and should be registered, but it does not need a <span class="style1">createPlugIn</span> method as it is not actually used as a factory! [Todo. Consider an interface PlugInHost]</p>
<h2><a name="howto"></a>How To ... </h2>
<p>In this section, I'll quickly summarize the steps you need to take to accomplish various tasks. </p>
<h3><a name="howtohost" id="howtohost"></a>How to Write a Host Component </h3>
<h4>0. Create the interfaces.</h4>
<p>You need one interface for the factories and one for the plug-ins. E.g., </p>
<pre>
        <strong>import</strong> tm.plugins.PlugInFactory ;
        <strong>public interface</strong> MyPIFactoryIntf <strong>extends</strong> PlugInFactory {
            <strong>public</strong> MyPlugInInterface createPlugIn( <em>...parameters as needed...</em> ) ;
        }
</pre>
<p>and</p>
<pre>
        <strong>public interface</strong> MyPlugInInterface {
            <em>...methods and constants your component may use...</em>
        }
</pre>
<p> Note that the name &quot;createPlugIn&quot; can be changed to whatever you like, &quot;createView&quot;, &quot;createModel&quot;, &quot;createBob&quot;, ... . Actually you can have more than one create routine, in which case you are using the Abstract Factory pattern <a href="#r1">[1]</a>.</p>
<p>It is a good idea (considering software evolution) if the &quot;parameters needed&quot; for plugIn creation are limited to a single context object. Typically the context object will implement an interface called a &quot;ContextInterface&quot;. E.g. if the plug-in is expected to implement an interface called &quot;MyPlugInInterface&quot; then its context is expected to implement &quot;MyContextInterface&quot;. Thus we have three interfaces. </p>
<pre>
        <strong>import</strong> tm.plugins.PlugInFactory ;
        <strong>public interface</strong> MyPIFactoryIntf <strong>extends</strong> PlugInFactory {
            <strong>public</strong> MyPlugInInterface createPlugIn( MyContextInterface context ) ;
        }
</pre>
<pre>
        <strong>public interface</strong> MyPlugInInterface {
            <em>...methods and constants your component may use...</em>
        }
</pre>
<pre>		  <strong>public interface</strong> MyContextInterface {
            <em>...methods and constants your plug-in may use...</em>
        }</pre>
<h4>1. Write code to create the plug-in(s)</h4>
<p>Now where you need to create the plug-in. If you expect that exactly 1 plug-in factory will be registered, you can do the following:</p>
<pre>
        <strong>import</strong> tm.plugins.PlugInManager ;
        ...
        PlugInManager thePlugInManager = PlugInManager.getSingleton() ;
        MyPIFactoryIntf factory
           = thePlugInManager.getFactory( &quot;X:Y&quot;, MyPIFactoryIntf.class, <strong>true</strong> ) ;
        plugIn = factory.createPlugIn(<strong> this</strong> ) ;
</pre>
<p>If either zero or one plug-in factories is acceptable, do the following: </p>
<pre>
        <strong>import</strong> tm.plugins.PlugInManager ;
        ...
        PlugInManager thePlugInManager = PlugInManager.getSingleton() ;
        MyPIFactoryIntf factory
           = thePlugInManager.getFactory( &quot;X:Y&quot;, MyPIFactoryIntf.class, <strong>false</strong> ) ;
        plugIn = factory==<strong>null</strong> ? <strong>null</strong> : factory.createPlugIn( context ) ;
</pre>
<p>If you don't expect the number of plug-in factories to be less than two,  you should call <span class="style1">getFactoryList</span> instead, like this: </p>
<pre>
        <strong>import</strong> tm.plugins.PlugInManager ;
        ...
        PlugInManager thePlugInManager = PlugInManager.getSingleton( ;
        List&lt;MyPIFactoryIntf&gt; factories
           = thePlugInManager.getFactoryList( &quot;X:Y&quot;, MyPIFactoryIntf.class, <strong>false</strong> ) ;
        plugIns = <strong>new</strong> MyPlugInInterface[ factories.size() ] ;
        <strong>for</strong>( <strong>int</strong> i = 0 ; i &lt; factories.size() ; ++i ) {
            plugIns[i] = factories.get(i).createPlugIn( context ) ; }</pre>
<p>If you expect the number of plug-in factories to be one or more, do the above, but with <strong>true</strong> replacing <strong>false</strong>.</p>
<p>Be sure to catch the <span class="style1">PlugInNotFound</span> exception that might be thrown from <span class="style1">getFactory</span> or from <span class="style1">getFactoryList</span>.
</p>
<p> The use of &quot;factory objects&quot; to create other objects (&quot;plug-in objects&quot;), as illustrated above, is typical of how the Plug-In System is used in the Teaching Machine. However, the contract embodied by the &quot;factory interface&quot; doesn't have to involve creation at all; what the host component does with the &quot;factory&quot; objects it obtains from the plug-in manager is really up to the designer of that component. </p>
<h4>2. Add the requirement</h4>
<p>Add the requirement to host component's factory class's <span class="style1">getRequirements</span> method. See <a href="#requirements">Expressing Requirements</a>.</p>
<h3><a name="howtoplugin"></a>How to Write a Plug-in</h3>
<p>To write a new plug-in you write two classes. </p>
<h4>0. Write the factory class.</h4>
<pre>
        <strong>import</strong> tm.plugins.Requirement ;
        <strong>public class</strong> MyPIFactory <strong>implements</strong> MyPIFactoryIntf {

            <strong>private</strong> MyPIFactory() {} 
    
            <strong>static public</strong> MyPIFactory createInstance( String ignored ) {
                <strong>return new</strong> MyPIFactory() ;
            }
    
            <strong>public</strong> MyPlugInInterface createPlugIn( MyContextInterface context ) {
                <strong>return new</strong> MyPlugIn( context ) ;
            }
  
            <strong>public</strong> Requirement[] getRequirements() {
                <strong>return new</strong> Requirement[0];
            }
        }
</pre>
<h4>1. Write the plug-in.</h4>
<p>This should be in the same package as the factory and thus need not be public. If you want, you can put it in the same file as the factory class. </p>
<pre>
        <strong>class</strong> MyPlugIn <strong>implements</strong> MyPlugInInterface {
            MyPlugIn(MyContextInterface context) { ... }

            <em>...the implementation of MyPlugInInterface...</em>
        }</pre>
<h3><a name="howtocombine"></a>How to combine the factory class with the plug-in class</h3>
<p>Here are two methods.</p>
<h4>(a) Make the plug-in class local.</h4>
<p>The trick is to make the plug-in a local class of its factory.</p>
<p>The code looks for the factory like this</p>
<pre>
        <strong>import</strong> tm.plugins.Requirement ;
        <strong>public class</strong> MyPIFactory <strong>implements</strong> MyPIFactoryIntf {

            <strong>private</strong> MyPIFactory() {} 
    
            <strong>static public</strong> MyPIFactory createInstance( String ignored ) {
                <strong>return new</strong> MyPIFactory() ;
            }
    
            <strong>public</strong> MyPlugInInterface createPlugIn( MyContextInterface context ) {
                <strong>return new</strong> MyPlugIn( <em>...arguments as needed...</em> ) ;
            }<strong>

            public</strong> Requirement[] getRequirements() {
                <strong>return new</strong> Requirement[0];
            }

            <strong>private static class</strong> MyPlugIn <strong>implements</strong> MyPlugInInterface {
                MyPlugIn( MyContextInterface context ) { ... }

                <em>...the implementation of MyPlugInInterface...</em>
            }
        }</pre>
<p>The plug-in class need not be static; i.e., it can be an inner class of the factory.</p>
<h4>  (b) Make the factory class local.</h4>
<p>Here we make the Factory class local to the plug-in.</p>
<pre>
        <strong>public class</strong> MyPlugIn <strong>implements</strong> MyPlugInInterface {
            <strong>private</strong> MyPlugIn( MyContextInterface context ) { ... }

            <em>...the implementation of MyPlugInInterface...</em>

            <strong>public static class</strong> MyPIFactory <strong>implements</strong> MyPIFactoryIntf {

                <strong>private</strong> MyPIFactory() {} 
    
                <strong>static public</strong> MyPIFactory createInstance( String ignored ) {
                    <strong>return new</strong> MyPIFactory() ;
                }
    
                <strong>public</strong> MyPlugInInterface createPlugIn( MyContextInterface context ) {
                    <strong>return new</strong> MyPlugIn( <em>...arguments as needed...</em> ) ;
                }
  
                <strong>public</strong> Requirement[] getRequirements() {
                    <strong>return new</strong> Requirement[0];
                }
            }
        }
</pre>
<p>There are at least 3 reasons to prefer (a) to (b)</p>
<ul>
  <li>In (a) we actually reduce the visibility of the plug-in class. Its existence becomes an implementation detail of the factory class.</li>
  <li>In (b) we actually increase the visibility of the plug-in class. In order for the factory to by publicly accessible outside the package, the plug-in class must be public. Compare this to the solution in the previous section where the plug-in class need only be visible within its package.</li>
  <li>If the same factory is capable of producing more than one plug-in (the Abstract Factory pattern of Gamma et al. <a href="#r1">[1]</a>), then (b) awkwardly forces you to pick one of the plug-in classes to contain the factory, whereas with (a) all the plug-in classes can be nested within one factory class. However, in this case may be looking at a large file (it is one thing to put a large class inside an otherwise small class, quite another when there are two or more large nested classes) and you might consider creating a new package to hold the factory class and its various product classes. </li>
</ul>
<h3><a name="howtosingleton"></a>How to Write a Singleton Plug-In</h3>
<p>When the plug-in is a singleton, you can combine the factory  and the plug-in in one class as follows.</p>
<pre>
        <strong>import</strong> tm.plugins.Requirement ;
        <strong>public class</strong> MyPIFactory <strong>implements</strong> MyPIFactoryIntf, MyPlugInInterface {
  
            <strong>private static</strong> MyPIFactory theSingleton = <strong>null</strong>;
	
            <strong>private</strong> MyPIFactory() {} 
    
            <strong>static public</strong> MyPIFactory createInstance( String ignored ) {
                <strong>if</strong>( theSingleton == <strong>null</strong> ) theSingleton = <strong>new</strong> MyPIFactory() ;
                <strong>return</strong> theSingleton ;
            }    

            <strong>public</strong> MyPlugInInterface createPlugIn( ) {
                <strong>return this</strong> ;
            }

            <strong>public</strong> Requirement[] getRequirements() {
                <strong>return new</strong> Requirement[0];
            }

            <em>...the implementation of the MyPlugInInterface...</em>
        }</pre>
<p>However, the previous section shows an arguably better way of reducing the number of (visible) classes to 1.</p>
<p>In this example, I assumed there is no context. It does not make as much sense for a singleton instance to have a context object. </p>
<h3><a name="howtogui"></a>How to use the GUI to configure an assemblage of plug-ins </h3>
<p>The GUI allows the set of plug-in registrations to be altered. The user can</p>
<ul>
  <li>Add a new registration.</li>
  <li>Delete an existing registration.</li>
  <li>Change a registration.</li>
</ul>
<p>Each registration associates a factory class name and a string parameter (used to create the factory) with a jack name.</p>
<p>For example, we might add a registration consisting of</p>
<ul>
  <li>&quot;X:Y&quot; as jack name.</li>
  <li>&quot;MyPIFactory&quot; as class name.</li>
  <li>&quot;&quot; as parameter. </li>
</ul>
<p>Note that the set of registrations is recorded as part of the TM's &quot;configuration&quot;, thus you must save the configuration to record any changes to the set of registrations.</p>
<h2><a name="references"></a>References</h2>
<p><a name="r0"></a>[0] J. Rumbaugh, I Jacobson, and G. Booch, <em>The Unified Modeling Language Reference Manual</em>, 2nd ed., Addison-Wesley, 2005. </p>
<p><a name="r1"></a>[1] E. Gamma, R. Helm, R. Johnson, J. Vlissides, <em>Design Patterns: Elements of Reusable Object-Oriented Software</em>, Addison-Wesley, 1995. </p>
</body>
</html>