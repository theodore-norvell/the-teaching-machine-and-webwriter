/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. JavaParser.jj */
/*@egen*//* The Teaching Machine - Java Parser
 * JJTree Source
 * 
 * Copyright (C) 2002--2005 Theodore S. Norvell
 * Permission is granted to use this file
 * provided you respect the Sun copyright below
 * and that you understand that there may be
 * errors in this file. 
 * Based on Java1.2-b.jjt (original header follows)
 */

/**
 * Copyright (C) 1996, 1997 Sun Microsystems Inc.
 *
 * Use of this file and the system it is part of is constrained by the
 * file COPYRIGHT in the root directory of this system.  You may, however,
 * make any modifications you wish to this file.
 *
 * Java files generated by running JavaCC on this file (or modified versions
 * of this file) may be used in exactly the same manner as Java files
 * generated from any grammar developed by you.
 *
 * Author: Sriram Sankar
 * Date: 3/5/97
 *
 * This file contains a Java grammar and actions that implement a front-end.
 */


options {
  JAVA_UNICODE_ESCAPE = true;

  STATIC=false;
              
               
                       
                        
  COMMON_TOKEN_ACTION = true ;
  //OUTPUT_DIRECTORY = "src/tm/javaLang/parser" ;
  
  //DEBUG_PARSER=true ;
  //DEBUG_TOKEN_MANAGER=true;
}

PARSER_BEGIN(JavaParser)

package tm.javaLang.parser;

import java.util.* ;
import java.io.Reader ;

import tm.clc.analysis.IdTable ;
import tm.clc.analysis.ScopedName ;
import tm.clc.parser.* ;
import tm.javaLang.analysis.Java_SpecifierSet ;
import tm.javaLang.analysis.Java_Specifiers ;
import tm.javaLang.analysis.Java_ScopedName ;
import tm.virtualMachine.CodeStore ;
import tm.interfaces.SourceCoords ;
import tm.utilities.Assert ;
import tm.utilities.Debug ;
import tm.utilities.TMException ;
import tm.utilities.TMFile ;

public class JavaParser/*@bgen(jjtree)*/implements JavaParserTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected JJTJavaParserState jjtree = new JJTJavaParserState();

/*@egen*/ 
        
    IdTable idTable = new IdTable() ;
    
    TMFile file ;
    
    public JavaParser( Reader reader, CodeStore codeStore, TMFile file ) {
        this( reader ) ;
        this.file = file ;
        codeStore.startNewFile( file ) ;
        token_source.setCodeStore( codeStore, file ) ; }
    
    void jjtreeOpenNodeScope(Node n) {
        ((SimpleNode)n).setCoords( new SourceCoords( file, getToken(1).beginLine ) ) ;
    }
    void jjtreeCloseNodeScope(Node n) {
    }
    
    // These flags describe the syntactic context
    // of declarations.
    static final int TOP_LEVEL = 1 ;   
    static final int CONCRETE_CLASS_MEMBER = 2 ;
    static final int ABSTRACT_CLASS_MEMBER = 4 ;
    static final int INTERFACE_MEMBER = 8 ;
    static final int LOCAL = 16 ;

}


PARSER_END(JavaParser)

TOKEN_MGR_DECLS : {
    Colourizer colourizer  ;
    
    void setCodeStore( CodeStore codeStore, TMFile tmFile ) {
        colourizer = new Colourizer( codeStore, tmFile ) ; }
    
    final static int PLAIN = Colourizer.PLAIN,
                     KEYWORD = Colourizer.KEYWORD,
                     COMMENT = Colourizer.COMMENT,
                     CONSTANT = Colourizer.CONSTANT,
                     PREPROCESSOR = Colourizer.PREPROCESSOR,
                     MARKUP = Colourizer.MARKUP ;
    
    private int colourClass = PLAIN ;  // Used to communicate from lex actions
    
    private boolean invisible = false ; // This is true when we are within invisible code. I.e. between /*#I and */
    
    void CommonTokenAction(Token token) {
        colourizer.addToken( token.image, colourClass ) ;
        colourClass = PLAIN ;
    }        
}

////////////
// STATES //
////////////
//       /---------------------------------------------------\
//       |                                                   |
//       V        /*#                               */       |
//    DEFAULT   ---------> IN_PEDAGOGICAL_COMMENT -----------+
//    |                                                      |
//    |           //                                 newline |
//    +------------------> IN_SINGLE_LINE_COMMENT -----------+
//    |                                                      |
//    |      /*                                      */      |
//    +-------------------> IN_MULTI_LINE_COMMENT -----------+
//    |                                                      |
//    |        /**                                  */       |
//    \--------------------> IN_FORMAL_COMMENT --------------/


/////////////////
// PRODUCTIONS //
/////////////////

// END OF FILE
<*> TOKEN: // Ensure the file ends with a newline. The colourizer demands this.
{
      < EOF > { matchedToken.image = "\n" ; } : DEFAULT
}

// The following set of productions is duplicated in cplusplusp.jj,
// Except for the first line
<DEFAULT> SPECIAL_TOKEN :
{
//    <PEDAGOGICALMARKUP_DISPLAY_ALL: "/*#D*/" | "/*#/H*/" >
//                        { colourClass = MARKUP ;
//                          colourizer.startAllSelections() ; }
//|   <PEDAGOGICALMARKUP_HIDE_ALL: "/*#H*/"| "/*#/D*/" >
//                        { colourClass = MARKUP ;
//                         colourizer.endAllSelections() ; }
//|
   <PEDAGOGICALMARKUP_DISPLAY_SPECIFIC : "/*#T" (" ")* (["a"-"z","A"-"Z","0"-"9"])+ (" ")* "*/" >
                        { //colourClass = MARKUP ;
                          colourizer.startSelection(
                              CommonParserHelper.extractTagName( matchedToken.image ) ) ; }
|   <PEDAGOGICALMARKUP_HIDE_SPECIFIC: "/*#/T" (" ")* (["a"-"z","A"-"Z","0"-"9"])+ (" ")* "*/" >
                        { //colourClass = MARKUP ;
                          colourizer.endSelection(
                              CommonParserHelper.extractTagName( matchedToken.image ) ) ; }
|   <PEDAGOGICALMARKUP_OTHER: "/*#" >
                        // { colourClass = MARKUP ; }
                        : IN_PEDAGOGICAL_COMMENT
}

<DEFAULT> SKIP  :
{
    <PEDAGOGICALMARKUP_INVISIBLE_ALL: "/*#I" >
    { colourizer.startSelection("s") ;
      invisible = true ; }
}


// Catch the end of an invisible section.
<DEFAULT>SKIP :
{
  "*/" { if( invisible ) { colourizer.endSelection( "s" ) ; invisible = false ; }
         else { throw new ParseException( "Stray */ in code." ) ; } }
}

// Newlines in Pedagogical comments are a bit special. To keep
// The lines in the CodeStore and the lines output by the preprocessor
// synchronized, we send these to the CodeStore.
// This means that pedagogical comments can not be used to hide newlines.
<IN_PEDAGOGICAL_COMMENT> SPECIAL_TOKEN:
{
  "\n"
  {colourClass = PLAIN; CommonTokenAction( matchedToken ) ; } 
}

<IN_PEDAGOGICAL_COMMENT> SKIP:
{
  < ~[] >
}
/* WHITE SPACE */

<DEFAULT> SPECIAL_TOKEN :
{
  " "   {CommonTokenAction( matchedToken );}
| "\t"  {CommonTokenAction( matchedToken );}
| "\n"  {CommonTokenAction( matchedToken );}
| "\r"  {CommonTokenAction( matchedToken );}
| "\f"  {CommonTokenAction( matchedToken );}
}

/* COMMENTS */

<DEFAULT> MORE :
{
  "//" : IN_SINGLE_LINE_COMMENT
|
  <"/**" ~["/"]> { input_stream.backup(1); } : IN_FORMAL_COMMENT
|
  "/*" : IN_MULTI_LINE_COMMENT
}

<IN_SINGLE_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <SINGLE_LINE_COMMENT: "\n" | "\r" | "\r\n" > 
  {colourClass = COMMENT; CommonTokenAction( matchedToken );}
  : DEFAULT
}

<IN_FORMAL_COMMENT>
SPECIAL_TOKEN :
{
  <FORMAL_COMMENT: "*/" > 
  {colourClass = COMMENT; CommonTokenAction( matchedToken );}
  : DEFAULT
}

<IN_MULTI_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <MULTI_LINE_COMMENT: "*/" >
  {colourClass = COMMENT; CommonTokenAction( matchedToken );}
  : DEFAULT
}

<IN_SINGLE_LINE_COMMENT,IN_FORMAL_COMMENT,IN_MULTI_LINE_COMMENT>
MORE :
{
  < ~[] >
}

/* RESERVED WORDS AND LITERALS */

<DEFAULT> TOKEN :
{
  < ABSTRACT: "abstract" >  { colourClass = KEYWORD ; }
| < ASSERT: "assert" >  { colourClass = KEYWORD ; }
| < BOOLEAN: "boolean" >  { colourClass = KEYWORD ; }
| < BREAK: "break" >  { colourClass = KEYWORD ; }
| < BYTE: "byte" >  { colourClass = KEYWORD ; }
| < CASE: "case" >  { colourClass = KEYWORD ; }
| < CATCH: "catch" >  { colourClass = KEYWORD ; }
| < CHAR: "char" >  { colourClass = KEYWORD ; }
| < CLASS: "class" >  { colourClass = KEYWORD ; }
| < CONST: "const" >  { colourClass = KEYWORD ; }
| < CONTINUE: "continue" >  { colourClass = KEYWORD ; }
| < _DEFAULT: "default" >  { colourClass = KEYWORD ; }
| < DO: "do" >  { colourClass = KEYWORD ; }
| < DOUBLE: "double" >  { colourClass = KEYWORD ; }
| < ELSE: "else" >  { colourClass = KEYWORD ; }
| < EXTENDS: "extends" >  { colourClass = KEYWORD ; }
| < FALSE: "false" >  { colourClass = KEYWORD ; }
| < FINAL: "final" >  { colourClass = KEYWORD ; }
| < FINALLY: "finally" >  { colourClass = KEYWORD ; }
| < FLOAT: "float" >  { colourClass = KEYWORD ; }
| < FOR: "for" >  { colourClass = KEYWORD ; }
| < GOTO: "goto" >  { colourClass = KEYWORD ; }
| < IF: "if" >  { colourClass = KEYWORD ; }
| < IMPLEMENTS: "implements" >  { colourClass = KEYWORD ; }
| < IMPORT: "import" >  { colourClass = KEYWORD ; }
| < INSTANCEOF: "instanceof" >  { colourClass = KEYWORD ; }
| < INT: "int" >  { colourClass = KEYWORD ; }
| < INTERFACE: "interface" >  { colourClass = KEYWORD ; }
| < LONG: "long" >  { colourClass = KEYWORD ; }
| < NATIVE: "native" >  { colourClass = KEYWORD ; }
| < NEW: "new" >  { colourClass = KEYWORD ; }
| < NULL: "null" >  { colourClass = KEYWORD ; }
| < PACKAGE: "package">  { colourClass = KEYWORD ; }
| < PRIVATE: "private" >   { colourClass = KEYWORD ; }
| < PROTECTED: "protected" >  { colourClass = KEYWORD ; }
| < PUBLIC: "public" >  { colourClass = KEYWORD ; }
| < RETURN: "return" >  { colourClass = KEYWORD ; }
| < SHORT: "short" >  { colourClass = KEYWORD ; }
| < STATIC: "static" >  { colourClass = KEYWORD ; }
| < SUPER: "super" >  { colourClass = KEYWORD ; }
| < SWITCH: "switch" >  { colourClass = KEYWORD ; }
| < SYNCHRONIZED: "synchronized" >  { colourClass = KEYWORD ; }
| < THIS: "this" >  { colourClass = KEYWORD ; }
| < THROW: "throw" >  { colourClass = KEYWORD ; }
| < THROWS: "throws" >  { colourClass = KEYWORD ; }
| < TRANSIENT: "transient" >  { colourClass = KEYWORD ; }
| < TRUE: "true" >  { colourClass = KEYWORD ; }
| < TRY: "try" >  { colourClass = KEYWORD ; }
| < VOID: "void" >  { colourClass = KEYWORD ; }
| < VOLATILE: "volatile" >  { colourClass = KEYWORD ; }
| < WHILE: "while" >  { colourClass = KEYWORD ; }
| < STRICTFP: "strictfp" >  { colourClass = KEYWORD ; }
} 

/* LITERALS */

<DEFAULT> TOKEN :
{
  < DECIMAL_LITERAL: (["1"-"9"] (["0"-"9"])* | "0") (["l","L"])? >
  { colourClass = CONSTANT ; } 
|
  < HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ (["l","L"])? >
  { colourClass = CONSTANT ; }
|
  < OCTAL_LITERAL: "0" (["0"-"7"])+ (["l","L"])? >
  { colourClass = CONSTANT ; }
|
  < FLOATING_POINT_LITERAL:
        (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["f","F","d","D"])?
      | "." (["0"-"9"])+ (<EXPONENT>)? (["f","F","d","D"])?
      | (["0"-"9"])+ <EXPONENT> (["f","F","d","D"])?
      | (["0"-"9"])+ (<EXPONENT>)? ["f","F","d","D"]
  >
  { colourClass = CONSTANT ; }
|
  < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
|
  < CHARACTER_LITERAL:
      "'"
      (   (~["'","\\","\n","\r"])
        | <ESCAPESEQ>
      )
      "'"
  >
  { colourClass = CONSTANT ; }
|
  < STRING_LITERAL:
      "\""
      (   (~["\"","\\","\n","\r"])
        | <ESCAPESEQ>
      )*
      "\""
  >
  { colourClass = CONSTANT ; }
|
  < #ESCAPESEQ: "\\" ( ["n","t","b","r","f","\\","'","\""]
                     | ["0"-"7"] ( ["0"-"7"] )?
                     | ["0"-"3"] ["0"-"7"] ["0"-"7"] ) >
}

/* IDENTIFIERS */

<DEFAULT> TOKEN :
{
  < IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>)* >
|
  < #LETTER:
      [
       "$",
       "A"-"Z",
       "_",
       "a"-"z",
       "\u00c0"-"\u00d6",
       "\u00d8"-"\u00f6",
       "\u00f8"-"\u00ff",
       "\u0100"-"\u1fff",
       "\u3040"-"\u318f",
       "\u3300"-"\u337f",
       "\u3400"-"\u3d2d",
       "\u4e00"-"\u9fff",
       "\uf900"-"\ufaff"
      ]
  >
|
  < #DIGIT:
      [
       "0"-"9",
       "\u0660"-"\u0669",
       "\u06f0"-"\u06f9",
       "\u0966"-"\u096f",
       "\u09e6"-"\u09ef",
       "\u0a66"-"\u0a6f",
       "\u0ae6"-"\u0aef",
       "\u0b66"-"\u0b6f",
       "\u0be7"-"\u0bef",
       "\u0c66"-"\u0c6f",
       "\u0ce6"-"\u0cef",
       "\u0d66"-"\u0d6f",
       "\u0e50"-"\u0e59",
       "\u0ed0"-"\u0ed9",
       "\u1040"-"\u1049"
      ]
  >
}

/* SEPARATORS */

<DEFAULT> TOKEN :
{
  < LPAREN: "(" >
| < RPAREN: ")" >
| < LBRACE: "{" >
| < RBRACE: "}" >
| < LBRACKET: "[" >
| < RBRACKET: "]" >
| < SEMICOLON: ";" >
| < COMMA: "," >
| < DOT: "." >
}

/* OPERATORS */

<DEFAULT> TOKEN :
{
  < ASSIGN: "=" >
| < GT: ">" >
| < LT: "<" >
| < BANG: "!" >
| < TILDE: "~" >
| < HOOK: "?" >
| < COLON: ":" >
| < EQ: "==" >
| < LE: "<=" >
| < GE: ">=" >
| < NE: "!=" >
| < SC_OR: "||" >
| < SC_AND: "&&" >
| < INCR: "++" >
| < DECR: "--" >
| < PLUS: "+" >
| < MINUS: "-" >
| < STAR: "*" >
| < SLASH: "/" >
| < BIT_AND: "&" >
| < BIT_OR: "|" >
| < XOR: "^" >
| < REM: "%" >
| < LSHIFT: "<<" >
| < RSIGNEDSHIFT: ">>" >
| < RUNSIGNEDSHIFT: ">>>" >
| < PLUSASSIGN: "+=" >
| < MINUSASSIGN: "-=" >
| < STARASSIGN: "*=" >
| < SLASHASSIGN: "/=" >
| < ANDASSIGN: "&=" >
| < ORASSIGN: "|=" >
| < XORASSIGN: "^=" >
| < REMASSIGN: "%=" >
| < LSHIFTASSIGN: "<<=" >
| < RSIGNEDSHIFTASSIGN: ">>=" >
| < RUNSIGNEDSHIFTASSIGN: ">>>=" >
}


/*****************************************
 * THE JAVA LANGUAGE GRAMMAR STARTS HERE *
 *****************************************/

/*
 * Program structuring syntax follows.
 */

SimpleNode CompilationUnit() :
{/*@bgen(jjtree) CompilationUnit */
  SimpleNode jjtn000 = new SimpleNode(this, JJTCOMPILATIONUNIT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) CompilationUnit */
  try {
/*@egen*/
  try {
      OptPackageDeclaration()
      ImportDeclarations()
      ( TypeDeclaration() )*
      <EOF>
                    {
                      jjtn000.setString( file.getFileName() ) ;
    		      return jjtn000;
    		    }
  }
  catch( TMException e ) {
        int lineNumber ;
        if( e instanceof ParseException && ((ParseException)e).currentToken != null) {
            lineNumber = ((ParseException)e).currentToken.next.beginLine ; }
        else {
            lineNumber = getToken(0).beginLine ; }
      e.setSourceCoords( new SourceCoords( file, lineNumber ) ) ;
      throw e ; }
  catch( RuntimeException e ) {
       Debug.getInstance().msg(Debug.COMPILE, "Exception thrown while parsing line "+getToken(0).beginLine+" of file "+file.getFileName());
       throw e ; }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
  
}

void OptPackageDeclaration() :
{/*@bgen(jjtree) OptPackageDeclaration */
    SimpleNode jjtn000 = new SimpleNode(this, JJTOPTPACKAGEDECLARATION);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtreeOpenNodeScope(jjtn000);
/*@egen*/
    ScopedName name ;
}
{/*@bgen(jjtree) OptPackageDeclaration */
    try {
/*@egen*/
    [
       "package" name = Name() ";"
            { jjtn000.setName( name ) ; }
            { jjtn000.setBoolean( true ) ; }
    ]/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/
}

void ImportDeclarations() :
{/*@bgen(jjtree) ImportDeclarations */
  SimpleNode jjtn000 = new SimpleNode(this, JJTIMPORTDECLARATIONS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ImportDeclarations */
   try {
/*@egen*/
   ( ImportDeclaration() )*/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
       jjtreeCloseNodeScope(jjtn000);
     }
   }
/*@egen*/
}

void ImportDeclaration() :
{/*@bgen(jjtree) ImportDeclaration */
    SimpleNode jjtn000 = new SimpleNode(this, JJTIMPORTDECLARATION);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtreeOpenNodeScope(jjtn000);
/*@egen*/
    ScopedName name ;
}
{/*@bgen(jjtree) ImportDeclaration */
  try {
/*@egen*/
  "import" name = Name()
       { jjtn000.setName( name ) ; }
  [ "." "*" {jjtn000.setBoolean( true );} ] ";"/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}

void TypeDeclaration()       :
{}
{
  LOOKAHEAD( ( "abstract" | "final" | "public" | "strictfp" )* "class" )
  ClassDeclaration(TOP_LEVEL)
|
  InterfaceDeclaration(TOP_LEVEL)
|
  ";"
}


/*
 * Declaration syntax follows.
 */

void ClassDeclaration( int context )       :
{
    Java_SpecifierSet specSet = new Java_SpecifierSet() ;
}
{
  ( Static( specSet, context==CONCRETE_CLASS_MEMBER || context==ABSTRACT_CLASS_MEMBER || context==INTERFACE_MEMBER )
  | Abstract( specSet, true )
  | Final( specSet, true )
  | Public( specSet, context==CONCRETE_CLASS_MEMBER || context==ABSTRACT_CLASS_MEMBER || context==INTERFACE_MEMBER || context==TOP_LEVEL ) 
  | Protected( specSet, context==CONCRETE_CLASS_MEMBER || context==ABSTRACT_CLASS_MEMBER ) 
  | Private( specSet, context==CONCRETE_CLASS_MEMBER || context==ABSTRACT_CLASS_MEMBER )
  | Strictfp( specSet, true )
  )*
  { 
    // Add implicit modifiers
    if( context==INTERFACE_MEMBER ) {
        specSet.add( Java_Specifiers.SP_PUBLIC ) ; }
  }
  UnmodifiedClassDeclaration( specSet )
}

void UnmodifiedClassDeclaration( Java_SpecifierSet specSet ) :
{/*@bgen(jjtree) UnmodifiedClassDeclaration */
    SimpleNode jjtn000 = new SimpleNode(this, JJTUNMODIFIEDCLASSDECLARATION);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtreeOpenNodeScope(jjtn000);
/*@egen*/
    ScopedName name ;
}
{/*@bgen(jjtree) UnmodifiedClassDeclaration */
  try {
/*@egen*/
  { jjtn000.setSpecSet( specSet ) ; }
  "class" name=SimpleName()
  { jjtn000.setName( name ) ; }
  OptClassExtendsClause()
  OptImplementsClause()
  ClassBody( specSet.contains( Java_Specifiers.SP_ABSTRACT )
           ? ABSTRACT_CLASS_MEMBER
           : CONCRETE_CLASS_MEMBER )/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}

void OptClassExtendsClause() :
{/*@bgen(jjtree) OptClassExtendsClause */
    SimpleNode jjtn000 = new SimpleNode(this, JJTOPTCLASSEXTENDSCLAUSE);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtreeOpenNodeScope(jjtn000);
/*@egen*/
    ScopedName name ;
}
{/*@bgen(jjtree) OptClassExtendsClause */
  try {
/*@egen*/
  [ "extends" name=Name() 
    { jjtn000.setName( name ) ; }
    { jjtn000.setBoolean( true ) ; }
  ]/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}

void OptImplementsClause() :
{/*@bgen(jjtree) OptImplementsClause */
  SimpleNode jjtn000 = new SimpleNode(this, JJTOPTIMPLEMENTSCLAUSE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) OptImplementsClause */
  try {
/*@egen*/
  [ "implements" NameList()
    { jjtn000.setBoolean( true ) ; }
  ]/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}
    

void ClassBody(int context) :
{/*@bgen(jjtree) ClassBody */
  SimpleNode jjtn000 = new SimpleNode(this, JJTCLASSBODY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/
  boolean hasConstructor = false ;
  boolean isConstructor ;
}
{/*@bgen(jjtree) ClassBody */
  try {
/*@egen*/
  "{" ( isConstructor = ClassBodyDeclaration(context)
        { hasConstructor = hasConstructor || isConstructor ; }
      )*
  "}"/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtreeCloseNodeScope(jjtn000);
  }
/*@egen*/
  { jjtn000.setBoolean( hasConstructor ) ; }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}

boolean ClassBodyDeclaration(int context)       :
// Returns true iff the declaration is a constructor declaration.
{}
{
  LOOKAHEAD( ["static" ] "{")
  InitializerBlock()
  { return false ; }
|
  LOOKAHEAD( ( "static" | "abstract" | "final" | "public" | "protected" | "private" | "strictfp")* "class" )
  ClassDeclaration( context )
  { return false ; }
|
  LOOKAHEAD( ( "static" | "abstract" | "final" | "public" | "protected" | "private" | "strictfp")* "interface" )
  InterfaceDeclaration(context)
  { return false ; }
|
  LOOKAHEAD( [ "public" | "protected" | "private" ] <IDENTIFIER> "(" )
  ConstructorDeclaration()
  { return true ; }
|
  LOOKAHEAD( MethodDeclarationLookahead() )
  MethodDeclaration( context )
  { return false ; }
|
  FieldDeclaration( context )
  { return false ; }
|
  ";"
  { return false ; }
}

// This production is to determine lookahead only.
void MethodDeclarationLookahead()       :
{}
{
  ( "public" | "protected" | "private" | "static" | "abstract" | "final" | "native" | "synchronized" | "strictfp")*
  ResultType(null) <IDENTIFIER> "("
}

void InterfaceDeclaration(int context)       :
{
    Java_SpecifierSet specSet = new Java_SpecifierSet() ;
}
{
  ( Static( specSet, context==CONCRETE_CLASS_MEMBER || context==ABSTRACT_CLASS_MEMBER ||  context==INTERFACE_MEMBER)
  | Abstract( specSet, true )
  | Public( specSet, true )
  | Protected( specSet, context==CONCRETE_CLASS_MEMBER || context==ABSTRACT_CLASS_MEMBER )
  | Private( specSet, context==CONCRETE_CLASS_MEMBER || context==ABSTRACT_CLASS_MEMBER )
  | Strictfp( specSet, true ) )*
  { 
    // Add implicit modifiers
    specSet.add( Java_Specifiers.SP_ABSTRACT ) ;
    if( context==INTERFACE_MEMBER ) {
        specSet.add( Java_Specifiers.SP_PUBLIC ) ; }
  }
  UnmodifiedInterfaceDeclaration( specSet )
}

void UnmodifiedInterfaceDeclaration( Java_SpecifierSet specSet ) :
{/*@bgen(jjtree) UnmodifiedInterfaceDeclaration */
    SimpleNode jjtn000 = new SimpleNode(this, JJTUNMODIFIEDINTERFACEDECLARATION);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtreeOpenNodeScope(jjtn000);
/*@egen*/
    ScopedName name ;
}
{/*@bgen(jjtree) UnmodifiedInterfaceDeclaration */
  try {
/*@egen*/
  { jjtn000.setSpecSet( specSet ) ; }
  "interface" name=SimpleName()
  { jjtn000.setName( name ) ; }
  OptInterfaceExtendsClause()
  InterfaceBody()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}

void InterfaceBody() :
{/*@bgen(jjtree) InterfaceBody */
  SimpleNode jjtn000 = new SimpleNode(this, JJTINTERFACEBODY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) InterfaceBody */
  try {
/*@egen*/
  "{" ( InterfaceMemberDeclaration() )* "}"/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}

void OptInterfaceExtendsClause() :
{/*@bgen(jjtree) OptInterfaceExtendsClause */
  SimpleNode jjtn000 = new SimpleNode(this, JJTOPTINTERFACEEXTENDSCLAUSE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) OptInterfaceExtendsClause */
  try {
/*@egen*/
  [ "extends" NameList()
    { jjtn000.setBoolean( true ) ; }
  ]/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}

void InterfaceMemberDeclaration()        :
{}
{
  LOOKAHEAD( ( "static" | "abstract" | "final" | "public" | "protected" | "private" | "strictfp")* "class" )
  ClassDeclaration( INTERFACE_MEMBER )
|
  LOOKAHEAD( ( "static" | "abstract" | "final" | "public" | "protected" | "private" | "strictfp")* "interface" )
  InterfaceDeclaration( INTERFACE_MEMBER )
|
  LOOKAHEAD( MethodDeclarationLookahead() )
  MethodDeclaration( INTERFACE_MEMBER )
|
  FieldDeclaration( INTERFACE_MEMBER )
|
  ";"
}

void FieldDeclaration(int context )       :
{
    Java_SpecifierSet specSet = new Java_SpecifierSet() ;
}
{
  ( Public( specSet, true )
  | Protected( specSet, context==CONCRETE_CLASS_MEMBER || context==ABSTRACT_CLASS_MEMBER  )
  | Private( specSet, context==CONCRETE_CLASS_MEMBER || context==ABSTRACT_CLASS_MEMBER )
  | Static( specSet, true )
  | Final( specSet, true )
  | Transient( specSet, context==CONCRETE_CLASS_MEMBER || context==ABSTRACT_CLASS_MEMBER )
  | Volatile( specSet, context==CONCRETE_CLASS_MEMBER || context==ABSTRACT_CLASS_MEMBER ) )*
  { 
    // Add implicit modifiers
    if( context==INTERFACE_MEMBER ) {
        specSet.add( Java_Specifiers.SP_PUBLIC ) ;
        specSet.add( Java_Specifiers.SP_FINAL ) ;
        specSet.add( Java_Specifiers.SP_STATIC ) ; }
  }
  Type( specSet ) VariableDeclarator( specSet ) ( "," VariableDeclarator( specSet ) )* ";"
}

void VariableDeclarator( Java_SpecifierSet specSet ) :
{/*@bgen(jjtree) VariableDeclarator */
    SimpleNode jjtn000 = new SimpleNode(this, JJTVARIABLEDECLARATOR);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtreeOpenNodeScope(jjtn000);
/*@egen*/  
    ScopedName name ;
    int arrayDimCount = 0 ; 
}
{/*@bgen(jjtree) VariableDeclarator */
  try {
/*@egen*/
  { jjtn000.setSpecSet( specSet ) ; }
  name = SimpleName()
  { jjtn000.setName( name ) ; }
  ( "[" "]" { arrayDimCount++ ;} )*
  { jjtn000.setInt( arrayDimCount ) ; }
  ( 
    "=" VariableInitializer()
  |/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtreeCloseNodeScope(jjtn000);
    }
/*@egen*/
    { if( specSet.contains( Java_Specifiers.SP_FINAL )
       && specSet.contains( Java_Specifiers.SP_STATIC ) ) {
        Assert.error( "static final fields must have initializers" ) ; }
    }
  )/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}

void VariableInitializer() :
{/*@bgen(jjtree) VariableInitializer */
  SimpleNode jjtn000 = new SimpleNode(this, JJTVARIABLEINITIALIZER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) VariableInitializer */
        try {
/*@egen*/
	VariableInitializerVoid()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
        }
/*@egen*/
}

void VariableInitializerVoid()       :
{}
{
  ArrayInitializer()
|
  Expression()
}

void ArrayInitializer() :
{/*@bgen(jjtree) ArrayInitializer */
  SimpleNode jjtn000 = new SimpleNode(this, JJTARRAYINITIALIZER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ArrayInitializer */
  try {
/*@egen*/
  "{" [ VariableInitializerVoid() ( LOOKAHEAD(2) "," VariableInitializerVoid() )* ] [ "," ] "}"/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}

void ConstructorDeclaration() :
{/*@bgen(jjtree) ConstructorDeclaration */
    SimpleNode jjtn000 = new SimpleNode(this, JJTCONSTRUCTORDECLARATION);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtreeOpenNodeScope(jjtn000);
/*@egen*/
    Java_SpecifierSet specSet = new Java_SpecifierSet() ;
}
{/*@bgen(jjtree) ConstructorDeclaration */
  try {
/*@egen*/
  [ Public( specSet, true ) | Protected( specSet, true ) | Private( specSet, true ) ]
  ConstructorDeclarator( specSet )
  OptThrowsClause()
  ConstructorBody()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}

void ConstructorDeclarator( Java_SpecifierSet specSet ) :
{/*@bgen(jjtree) ConstructorDeclarator */
    SimpleNode jjtn000 = new SimpleNode(this, JJTCONSTRUCTORDECLARATOR);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtreeOpenNodeScope(jjtn000);
/*@egen*/ 
    ScopedName name ;
    int arrayDimCount = 0 ; }
{/*@bgen(jjtree) ConstructorDeclarator */
  try {
/*@egen*/
  { jjtn000.setSpecSet( specSet ) ; }
  name=SimpleName()
  { jjtn000.setName( name ) ; }
  FormalParameters()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}

void OptThrowsClause() :
{/*@bgen(jjtree) OptThrowsClause */
  SimpleNode jjtn000 = new SimpleNode(this, JJTOPTTHROWSCLAUSE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) OptThrowsClause */
  try {
/*@egen*/
  [ "throws" NameList()
    { jjtn000.setBoolean( true ) ; }
  ]/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}   

void MethodDeclaration(int context ) :
{/*@bgen(jjtree) MethodDeclaration */
    SimpleNode jjtn000 = new SimpleNode(this, JJTMETHODDECLARATION);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtreeOpenNodeScope(jjtn000);
/*@egen*/
    Java_SpecifierSet specSet = new Java_SpecifierSet() ;
}
{/*@bgen(jjtree) MethodDeclaration */
  try {
/*@egen*/
  ( Public( specSet, true )
  | Protected( specSet, context==CONCRETE_CLASS_MEMBER || context==ABSTRACT_CLASS_MEMBER )
  | Private( specSet, context==CONCRETE_CLASS_MEMBER || context==ABSTRACT_CLASS_MEMBER )
  | Static( specSet, context==CONCRETE_CLASS_MEMBER || context==ABSTRACT_CLASS_MEMBER )
  | Abstract( specSet, context==ABSTRACT_CLASS_MEMBER || context==INTERFACE_MEMBER )
  | Final( specSet, context==CONCRETE_CLASS_MEMBER || context==ABSTRACT_CLASS_MEMBER )
  | Native( specSet, context==CONCRETE_CLASS_MEMBER || context==ABSTRACT_CLASS_MEMBER )
  | Synchronized( specSet, context==CONCRETE_CLASS_MEMBER || context==ABSTRACT_CLASS_MEMBER )
  | Strictfp( specSet, context==CONCRETE_CLASS_MEMBER || context==ABSTRACT_CLASS_MEMBER )
  )*
  { if(  specSet.contains( Java_Specifiers.SP_ABSTRACT )
      && (  specSet.contains( Java_Specifiers.SP_PRIVATE )
         || specSet.contains( Java_Specifiers.SP_STATIC )
         || specSet.contains( Java_Specifiers.SP_FINAL )
         || specSet.contains( Java_Specifiers.SP_NATIVE )
         || specSet.contains( Java_Specifiers.SP_STRICTFP )
         || specSet.contains( Java_Specifiers.SP_SYNCHRONIZED ) ) ) {
            Assert.error( "abstract method can not be private, static, final, native, strictfp, or synchronized" ) ; }
            
    if(   specSet.contains( Java_Specifiers.SP_NATIVE )
       && specSet.contains( Java_Specifiers.SP_STRICTFP ) ) {
            Assert.error( "native method can not be strictfp" ) ; }
    // Add implicit modifiers
    if( context==INTERFACE_MEMBER ) {
        specSet.add( Java_Specifiers.SP_PUBLIC ) ;
        specSet.add( Java_Specifiers.SP_ABSTRACT ) ; }
  }
  ResultType( specSet )
  MethodDeclarator( specSet )
  OptThrowsClause()
  ( MethodBody()/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtreeCloseNodeScope(jjtn000);
    }
/*@egen*/
    { if( specSet.contains( Java_Specifiers.SP_ABSTRACT ) ) {
        Assert.error( "Abstract method has body" ) ; }
      else if( specSet.contains( Java_Specifiers.SP_NATIVE ) ) {
        Assert.error( "Native method has body" ) ; }
    }
  |
    ";"/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtreeCloseNodeScope(jjtn000);
    }
/*@egen*/
    { if( ! specSet.contains( Java_Specifiers.SP_NATIVE )
       && ! specSet.contains( Java_Specifiers.SP_ABSTRACT ) ) {
        Assert.error( "Method must have a body unless abstact or native" ) ; }
    }
  )/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}

void MethodDeclarator( Java_SpecifierSet specSet ) :
{/*@bgen(jjtree) MethodDeclarator */
    SimpleNode jjtn000 = new SimpleNode(this, JJTMETHODDECLARATOR);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtreeOpenNodeScope(jjtn000);
/*@egen*/ 
    ScopedName name ;
    int arrayDimCount = 0 ; }
{/*@bgen(jjtree) MethodDeclarator */
  try {
/*@egen*/
  { jjtn000.setSpecSet( specSet ) ; }
  name=SimpleName()
  { jjtn000.setName( name ) ; }
  FormalParameters()
  ( "[" "]"  {arrayDimCount++;} )*/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtreeCloseNodeScope(jjtn000);
  }
/*@egen*/
  { jjtn000.setInt( arrayDimCount ) ; }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}

void FormalParameters() :
{/*@bgen(jjtree) FormalParameters */
  SimpleNode jjtn000 = new SimpleNode(this, JJTFORMALPARAMETERS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) FormalParameters */
  try {
/*@egen*/
  "(" [ FormalParameter() ( "," FormalParameter() )* ] ")"/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}

void FormalParameter() :
{/*@bgen(jjtree) FormalParameter */
    SimpleNode jjtn000 = new SimpleNode(this, JJTFORMALPARAMETER);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtreeOpenNodeScope(jjtn000);
/*@egen*/
    Java_SpecifierSet specSet = new Java_SpecifierSet() ;
    ScopedName name ;
    int arrayDimCount = 0 ;
}
{/*@bgen(jjtree) FormalParameter */
  try {
/*@egen*/
  [ Final( specSet, true) ]
  Type( specSet ) 
  { jjtn000.setSpecSet( specSet ) ; }
  name = SimpleName()
  { jjtn000.setName( name ) ; }
  ( "[" "]" { arrayDimCount++ ;} )*/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtreeCloseNodeScope(jjtn000);
  }
/*@egen*/
  { jjtn000.setInt( arrayDimCount ) ; }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}

void ConstructorBody() :
{/*@bgen(jjtree) ConstructorBody */
  SimpleNode jjtn000 = new SimpleNode(this, JJTCONSTRUCTORBODY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ConstructorBody */
  try {
/*@egen*/
  "{"
    [ LOOKAHEAD(ExplicitConstructorInvocation()) ExplicitConstructorInvocation() 
      { jjtn000.setBoolean( true ) ; }
    ]
    ( BlockStatement() )*
  "}"/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}

void ExplicitConstructorInvocation()       :
{}
  // TSN 16 Aug 2002.  We could make the two cases easier to distinguish.
{
  LOOKAHEAD("this" Arguments() ";")
  ThisExplicitConstructorInvocation()
|
  SuperExplicitConstructorInvocation()
}

void ThisExplicitConstructorInvocation() :
{/*@bgen(jjtree) ThisExplicitConstructorInvocation */
  SimpleNode jjtn000 = new SimpleNode(this, JJTTHISEXPLICITCONSTRUCTORINVOCATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ThisExplicitConstructorInvocation */
    try {
/*@egen*/
    "this" Arguments() ";"/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/
}

void SuperExplicitConstructorInvocation() :
{/*@bgen(jjtree) SuperExplicitConstructorInvocation */
  SimpleNode jjtn000 = new SimpleNode(this, JJTSUPEREXPLICITCONSTRUCTORINVOCATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) SuperExplicitConstructorInvocation */
    try {
/*@egen*/
    [ LOOKAHEAD((ExpressionName() | Primary()) ".")  // THINK ABOUT THIS ONE!
      ExpressionNameOrPrimary() "." 
      { jjtn000.setBoolean( true ) ; }
    ] 
    "super" Arguments() ";"/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/
}

void MethodBody() :
{/*@bgen(jjtree) MethodBody */
  SimpleNode jjtn000 = new SimpleNode(this, JJTMETHODBODY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) MethodBody */
  try {
/*@egen*/
  "{" ( BlockStatement() )* "}"/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}

void InitializerBlock() :
{/*@bgen(jjtree) InitializerBlock */
  SimpleNode jjtn000 = new SimpleNode(this, JJTINITIALIZERBLOCK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) InitializerBlock */
  try {
/*@egen*/
  [ "static" {jjtn000.setBoolean( true ) ; } ]
  Block()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}


/*
 * Type, name and expression syntax follows.
 */

void Type( Java_SpecifierSet specSet )       :
{
    int arrayDimCount = 0 ;
    ScopedName name ;
}
{
  ( PrimitiveType( specSet )
    | name=Name()  { specSet.add_type_name( name ) ; }
  )
  ( "[" "]" {arrayDimCount++;} )*
  { specSet.setArrayDimCount( arrayDimCount ) ; }
}

void PrimitiveType( Java_SpecifierSet specSet )      :
{}
  // TSN 16 Aug 2002.  We could note the token.
{
  "boolean"   { specSet.add( Java_Specifiers.SP_BOOLEAN ) ; }
|
  "char"      { specSet.add( Java_Specifiers.SP_CHAR ) ; }
|
  "byte"      { specSet.add( Java_Specifiers.SP_BYTE ) ; }
|
  "short"     { specSet.add( Java_Specifiers.SP_SHORT ) ; }
|
  "int"       { specSet.add( Java_Specifiers.SP_INT ) ; }
|
  "long"      { specSet.add( Java_Specifiers.SP_LONG ) ; }
|
  "float"     { specSet.add( Java_Specifiers.SP_FLOAT ) ; }
|
  "double"    { specSet.add( Java_Specifiers.SP_DOUBLE ) ; }
}

void ResultType( Java_SpecifierSet specSet )       :
{}
{
  "void"   { specSet.add( Java_Specifiers.SP_VOID ) ; }
|
  Type( specSet )
}

ScopedName Name()       :
/*
 * A lookahead of 2 is required below since "Name" can be followed
 * by a ".*" when used in the context of an "ImportDeclaration"
 * and by a .new or .super or .class in expressions
 */
{
    ScopedName name ; 
    String id ;
}
{
  id=Identifier()
  { name = new Java_ScopedName( id ) ; }
  ( LOOKAHEAD(2) "." id=Identifier()
    { name.append( id ) ; }
  )*
  { return name ; }
}

void NameList()       :
{}
{
  NameNode()
  ( "," NameNode()
  )*
}


void NameNode() :
{/*@bgen(jjtree) NameNode */
    SimpleNode jjtn000 = new SimpleNode(this, JJTNAMENODE);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtreeOpenNodeScope(jjtn000);
/*@egen*/
    ScopedName name ;
}
{/*@bgen(jjtree) NameNode */
    try {
/*@egen*/
    name=Name()/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtreeCloseNodeScope(jjtn000);
    }
/*@egen*/
    { jjtn000.setName( name ) ; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/
}

/*
 * Expression syntax follows.
 */

void Expression()       :
/*
 * This expansion has been written this way instead of:
 *   Assignment() | ConditionalExpression()
 * for performance reasons.
 * However, it is a weakening of the grammar for it allows the LHS of
 * assignments to be any conditional expression whereas it can only be
 * a primary expression.  Consider adding a semantic predicate to work
 * around this.
 */
{ Token t ; }
{
  ConditionalExpression()
  [ 
    t=AssignmentOperator()
    Expression()/*@bgen(jjtree) #BinOp( 2) */
    {
      SimpleNode jjtn001 = new SimpleNode(this, JJTBINOP);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      jjtreeOpenNodeScope(jjtn001);
    }
    try {
/*@egen*//*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn001,  2);
      jjtc001 = false;
      jjtreeCloseNodeScope(jjtn001);
    }
/*@egen*/
    {jjtn001.setInt( t.kind ); jjtn001.setString( idTable.inter( t.image ) );}/*@bgen(jjtree)*/
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  2);
        jjtreeCloseNodeScope(jjtn001);
      }
    }
/*@egen*/          
  ] 
}

Token AssignmentOperator()       :
{ Token t ; }
{
    ( t="=" | t="*=" | t="/=" | t="%=" | t="+=" | t="-=" | t="<<=" | t=">>="
    | t=">>>=" | t="&=" | t="^=" | t="|=" )
    {return t ;}
}

void ConditionalExpression()       :
{}
{
  (
     ConditionalOrExpression()
     [ "?" Expression() ":"/*@bgen(jjtree) #Conditional( 3) */
                            {
                              SimpleNode jjtn001 = new SimpleNode(this, JJTCONDITIONAL);
                              boolean jjtc001 = true;
                              jjtree.openNodeScope(jjtn001);
                              jjtreeOpenNodeScope(jjtn001);
                            }
                            try {
/*@egen*/ ConditionalExpression()/*@bgen(jjtree)*/
                            } catch (Throwable jjte001) {
                              if (jjtc001) {
                                jjtree.clearNodeScope(jjtn001);
                                jjtc001 = false;
                              } else {
                                jjtree.popNode();
                              }
                              if (jjte001 instanceof RuntimeException) {
                                throw (RuntimeException)jjte001;
                              }
                              if (jjte001 instanceof ParseException) {
                                throw (ParseException)jjte001;
                              }
                              throw (Error)jjte001;
                            } finally {
                              if (jjtc001) {
                                jjtree.closeNodeScope(jjtn001,  3);
                                jjtreeCloseNodeScope(jjtn001);
                              }
                            }
/*@egen*/                   ]
  )
}

void ConditionalOrExpression()       :
{ Token t; }
{
  ConditionalAndExpression()
  ( t="||" ConditionalAndExpression()/*@bgen(jjtree) #BinOp( 2) */
    {
      SimpleNode jjtn001 = new SimpleNode(this, JJTBINOP);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      jjtreeOpenNodeScope(jjtn001);
    }
    try {
/*@egen*//*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn001,  2);
      jjtc001 = false;
      jjtreeCloseNodeScope(jjtn001);
    }
/*@egen*/ 
    {jjtn001.setInt( t.kind ); jjtn001.setString( idTable.inter( t.image ) );}/*@bgen(jjtree)*/
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  2);
        jjtreeCloseNodeScope(jjtn001);
      }
    }
/*@egen*/          
  )*
}

void ConditionalAndExpression()       :
{ Token t; }
{
  InclusiveOrExpression()
  ( t="&&" InclusiveOrExpression()/*@bgen(jjtree) #BinOp( 2) */
    {
      SimpleNode jjtn001 = new SimpleNode(this, JJTBINOP);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      jjtreeOpenNodeScope(jjtn001);
    }
    try {
/*@egen*//*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn001,  2);
      jjtc001 = false;
      jjtreeCloseNodeScope(jjtn001);
    }
/*@egen*/  
    {jjtn001.setInt( t.kind ); jjtn001.setString( idTable.inter( t.image ) );}/*@bgen(jjtree)*/
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  2);
        jjtreeCloseNodeScope(jjtn001);
      }
    }
/*@egen*/          
  )*
}

void InclusiveOrExpression()       :
{ Token t ; }
{
  ExclusiveOrExpression()
  ( t="|" ExclusiveOrExpression()/*@bgen(jjtree) #BinOp( 2) */
    {
      SimpleNode jjtn001 = new SimpleNode(this, JJTBINOP);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      jjtreeOpenNodeScope(jjtn001);
    }
    try {
/*@egen*//*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn001,  2);
      jjtc001 = false;
      jjtreeCloseNodeScope(jjtn001);
    }
/*@egen*/  
    {jjtn001.setInt( t.kind ); jjtn001.setString( idTable.inter( t.image ) );}/*@bgen(jjtree)*/
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  2);
        jjtreeCloseNodeScope(jjtn001);
      }
    }
/*@egen*/          
  )*
}

void ExclusiveOrExpression()       :
{ Token t ; }
{
    AndExpression()
    ( t="^" AndExpression()/*@bgen(jjtree) #BinOp( 2) */
       {
         SimpleNode jjtn001 = new SimpleNode(this, JJTBINOP);
         boolean jjtc001 = true;
         jjtree.openNodeScope(jjtn001);
         jjtreeOpenNodeScope(jjtn001);
       }
       try {
/*@egen*//*@bgen(jjtree)*/
       {
         jjtree.closeNodeScope(jjtn001,  2);
         jjtc001 = false;
         jjtreeCloseNodeScope(jjtn001);
       }
/*@egen*/   
       {jjtn001.setInt( t.kind ); jjtn001.setString( idTable.inter( t.image ) );}/*@bgen(jjtree)*/
       } finally {
         if (jjtc001) {
           jjtree.closeNodeScope(jjtn001,  2);
           jjtreeCloseNodeScope(jjtn001);
         }
       }
/*@egen*/          
    )*
}

void AndExpression()       :
{ Token t ; }
{
  EqualityExpression()
  ( t="&" EqualityExpression()/*@bgen(jjtree) #BinOp( 2) */
    {
      SimpleNode jjtn001 = new SimpleNode(this, JJTBINOP);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      jjtreeOpenNodeScope(jjtn001);
    }
    try {
/*@egen*//*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn001,  2);
      jjtc001 = false;
      jjtreeCloseNodeScope(jjtn001);
    }
/*@egen*/    
    {jjtn001.setInt( t.kind ); jjtn001.setString( idTable.inter( t.image ) );}/*@bgen(jjtree)*/
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  2);
        jjtreeCloseNodeScope(jjtn001);
      }
    }
/*@egen*/          
  )*
}

void EqualityExpression()       :
{ Token t ; }
{
  InstanceOfExpression()
  ( ( t="==" | t="!=" ) InstanceOfExpression()/*@bgen(jjtree) #BinOp( 2) */
    {
      SimpleNode jjtn001 = new SimpleNode(this, JJTBINOP);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      jjtreeOpenNodeScope(jjtn001);
    }
    try {
/*@egen*//*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn001,  2);
      jjtc001 = false;
      jjtreeCloseNodeScope(jjtn001);
    }
/*@egen*/     
    {jjtn001.setInt( t.kind ); jjtn001.setString( idTable.inter( t.image ) );}/*@bgen(jjtree)*/
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  2);
        jjtreeCloseNodeScope(jjtn001);
      }
    }
/*@egen*/          
  )*
}

void InstanceOfExpression()       :
{
    Java_SpecifierSet specSet = new Java_SpecifierSet() ;
}
{
  ( RelationalExpression()
    [ "instanceof" Type(specSet)/*@bgen(jjtree) #InstanceOf( 1) */
      {
        SimpleNode jjtn001 = new SimpleNode(this, JJTINSTANCEOF);
        boolean jjtc001 = true;
        jjtree.openNodeScope(jjtn001);
        jjtreeOpenNodeScope(jjtn001);
      }
      try {
/*@egen*//*@bgen(jjtree)*/
      {
        jjtree.closeNodeScope(jjtn001,  1);
        jjtc001 = false;
        jjtreeCloseNodeScope(jjtn001);
      }
/*@egen*/
      { jjtn001.setSpecSet( specSet ) ; }/*@bgen(jjtree)*/
      } finally {
        if (jjtc001) {
          jjtree.closeNodeScope(jjtn001,  1);
          jjtreeCloseNodeScope(jjtn001);
        }
      }
/*@egen*/
                      
    ]
  ) 
}

void RelationalExpression()       :
{ Token t ; }
{
  ShiftExpression()
  ( ( t="<" | t=">" | t="<=" | t=">=")
    ShiftExpression()/*@bgen(jjtree) #BinOp( 2) */
    {
      SimpleNode jjtn001 = new SimpleNode(this, JJTBINOP);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      jjtreeOpenNodeScope(jjtn001);
    }
    try {
/*@egen*//*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn001,  2);
      jjtc001 = false;
      jjtreeCloseNodeScope(jjtn001);
    }
/*@egen*/      
    {jjtn001.setInt( t.kind ); jjtn001.setString( idTable.inter( t.image ) );}/*@bgen(jjtree)*/
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  2);
        jjtreeCloseNodeScope(jjtn001);
      }
    }
/*@egen*/          
  )*
}

void ShiftExpression()       :
{ Token t ; }
{
  AdditiveExpression()
  (  ( t="<<" | t=">>" | t=">>>")
     AdditiveExpression()/*@bgen(jjtree) #BinOp( 2) */
     {
       SimpleNode jjtn001 = new SimpleNode(this, JJTBINOP);
       boolean jjtc001 = true;
       jjtree.openNodeScope(jjtn001);
       jjtreeOpenNodeScope(jjtn001);
     }
     try {
/*@egen*//*@bgen(jjtree)*/
     {
       jjtree.closeNodeScope(jjtn001,  2);
       jjtc001 = false;
       jjtreeCloseNodeScope(jjtn001);
     }
/*@egen*/  
     {jjtn001.setInt( t.kind ); jjtn001.setString( idTable.inter( t.image ) );}/*@bgen(jjtree)*/
     } finally {
       if (jjtc001) {
         jjtree.closeNodeScope(jjtn001,  2);
         jjtreeCloseNodeScope(jjtn001);
       }
     }
/*@egen*/          
  )*
}

void AdditiveExpression()       :
{ Token t ; }
{
  MultiplicativeExpression()
  (  ( t="+" | t="-")
     MultiplicativeExpression()/*@bgen(jjtree) #BinOp( 2) */
     {
       SimpleNode jjtn001 = new SimpleNode(this, JJTBINOP);
       boolean jjtc001 = true;
       jjtree.openNodeScope(jjtn001);
       jjtreeOpenNodeScope(jjtn001);
     }
     try {
/*@egen*//*@bgen(jjtree)*/
     {
       jjtree.closeNodeScope(jjtn001,  2);
       jjtc001 = false;
       jjtreeCloseNodeScope(jjtn001);
     }
/*@egen*/  
     {jjtn001.setInt( t.kind ); jjtn001.setString( idTable.inter( t.image ) );}/*@bgen(jjtree)*/
     } finally {
       if (jjtc001) {
         jjtree.closeNodeScope(jjtn001,  2);
         jjtreeCloseNodeScope(jjtn001);
       }
     }
/*@egen*/          
  )*
}

void MultiplicativeExpression()       :
{ Token t ; }
{
  UnaryExpression()
  (  ( t="*" | t="/" | t="%")
     UnaryExpression()/*@bgen(jjtree) #BinOp( 2) */
     {
       SimpleNode jjtn001 = new SimpleNode(this, JJTBINOP);
       boolean jjtc001 = true;
       jjtree.openNodeScope(jjtn001);
       jjtreeOpenNodeScope(jjtn001);
     }
     try {
/*@egen*//*@bgen(jjtree)*/
     {
       jjtree.closeNodeScope(jjtn001,  2);
       jjtc001 = false;
       jjtreeCloseNodeScope(jjtn001);
     }
/*@egen*/  
     {jjtn001.setInt( t.kind ); jjtn001.setString( idTable.inter( t.image ) );}/*@bgen(jjtree)*/
     } finally {
       if (jjtc001) {
         jjtree.closeNodeScope(jjtn001,  2);
         jjtreeCloseNodeScope(jjtn001);
       }
     }
/*@egen*/          
  )*
}

void UnaryExpression()       :
{ Token t ; }
{
  ( t="+" | t="-") UnaryExpression()/*@bgen(jjtree) #Unary_prefix( 1) */
  {
    SimpleNode jjtn001 = new SimpleNode(this, JJTUNARY_PREFIX);
    boolean jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
    jjtreeOpenNodeScope(jjtn001);
  }
  try {
/*@egen*//*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn001,  1);
    jjtc001 = false;
    jjtreeCloseNodeScope(jjtn001);
  }
/*@egen*/
  {jjtn001.setInt( t.kind ); jjtn001.setString( idTable.inter( t.image ) );}/*@bgen(jjtree)*/
  } finally {
    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001,  1);
      jjtreeCloseNodeScope(jjtn001);
    }
  }
/*@egen*/                   
|
  PreIncDecExpression()
|
  UnaryExpressionNotPlusMinus()
}

void PreIncDecExpression()       :
{ Token t ; }
{
    t=IncDecOperator() UnaryExpression()/*@bgen(jjtree) #Unary_prefix( 1) */
    {
      SimpleNode jjtn001 = new SimpleNode(this, JJTUNARY_PREFIX);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      jjtreeOpenNodeScope(jjtn001);
    }
    try {
/*@egen*//*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn001,  1);
      jjtc001 = false;
      jjtreeCloseNodeScope(jjtn001);
    }
/*@egen*/
    {jjtn001.setInt( t.kind ); jjtn001.setString( idTable.inter( t.image ) );}/*@bgen(jjtree)*/
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  1);
        jjtreeCloseNodeScope(jjtn001);
      }
    }
/*@egen*/                   
}


Token IncDecOperator()       :
{ Token t ; }
{
    ( t="++" | t="--")
    {return t ;}
}

void UnaryExpressionNotPlusMinus()       :
{ Token t ; }
{
  ( t="~" | t="!") UnaryExpression()/*@bgen(jjtree) #Unary_prefix( 1) */
  {
    SimpleNode jjtn001 = new SimpleNode(this, JJTUNARY_PREFIX);
    boolean jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
    jjtreeOpenNodeScope(jjtn001);
  }
  try {
/*@egen*//*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn001,  1);
    jjtc001 = false;
    jjtreeCloseNodeScope(jjtn001);
  }
/*@egen*/
  {jjtn001.setInt( t.kind ); jjtn001.setString( idTable.inter( t.image ) );}/*@bgen(jjtree)*/
  } finally {
    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001,  1);
      jjtreeCloseNodeScope(jjtn001);
    }
  }
/*@egen*/                   
|
  LOOKAHEAD( CastLookahead() )
  CastExpression()
|
  PostfixExpression()
}

// This production is to determine lookahead only.  The LOOKAHEAD specifications
// below are not used, but they are there to suppress warnings.
void CastLookahead()       :
{}
{
  LOOKAHEAD(2)
  "(" PrimitiveType( null )
|
  LOOKAHEAD("(" Name() "[")
  "(" Name() "[" "]"
|
  "(" Name() ")" ( "~" | "!" | "(" | <IDENTIFIER> | "this" | "super" | "new" | Literal() )
}

void CastExpression() :
{/*@bgen(jjtree) CastExpression */
    SimpleNode jjtn000 = new SimpleNode(this, JJTCASTEXPRESSION);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtreeOpenNodeScope(jjtn000);
/*@egen*/
    Java_SpecifierSet specSet = new Java_SpecifierSet() ;
}
{/*@bgen(jjtree) CastExpression */
    try {
/*@egen*/
    (   LOOKAHEAD("(" PrimitiveType())
        "(" Type(specSet) ")" UnaryExpression()
    |
        "(" Type(specSet) ")" UnaryExpressionNotPlusMinus()
    )/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtreeCloseNodeScope(jjtn000);
    }
/*@egen*/
    { jjtn000.setSpecSet( specSet ) ; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/
}

void PostfixExpression()       :
{ Token t ; }
{
  ExpressionNameOrPrimary()
  [ t=IncDecOperator()/*@bgen(jjtree) #Unary_postfix( 1) */
    {
      SimpleNode jjtn001 = new SimpleNode(this, JJTUNARY_POSTFIX);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      jjtreeOpenNodeScope(jjtn001);
    }
    try {
/*@egen*//*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn001,  1);
      jjtc001 = false;
      jjtreeCloseNodeScope(jjtn001);
    }
/*@egen*/
    {jjtn001.setInt( t.kind ); jjtn001.setString( idTable.inter( t.image ) );}/*@bgen(jjtree)*/
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  1);
        jjtreeCloseNodeScope(jjtn001);
      }
    }
/*@egen*/                    
  ]
}

void ExpressionNameOrPrimary()       :
{}
{
  LOOKAHEAD( Name() ( "." "class" | "." "new" | "." "this" 
                    | "." "super" "." | "(" | "[" 
                    ) )
  Primary()
|
  LOOKAHEAD( Name() )
  ExpressionName()
| 
  Primary()
}

// An ExpressionName as an expression.
// See JLS chapters 6 and 15.
void ExpressionName() :
{/*@bgen(jjtree) ExpressionName */
 SimpleNode jjtn000 = new SimpleNode(this, JJTEXPRESSIONNAME);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtreeOpenNodeScope(jjtn000);
/*@egen*/ScopedName name ;}
{/*@bgen(jjtree) ExpressionName */
    try {
/*@egen*/
    name = Name()/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtreeCloseNodeScope(jjtn000);
    }
/*@egen*/
    { jjtn000.setName( name ) ; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/
}
    
    
void Primary()       :
{}
{
  PrimaryPrefix()
  ( 
    LOOKAHEAD( PrimarySuffixLookahead())
    PrimarySuffix()
  )*
}

void PrimaryPrefix()       :
{ String id ;}
{
  Literal()
|
  ThisExp()
|
  AllocationExpression()
|
  "(" Expression()/*@bgen(jjtree) #Parens( 1) */
                   {
                     SimpleNode jjtn001 = new SimpleNode(this, JJTPARENS);
                     boolean jjtc001 = true;
                     jjtree.openNodeScope(jjtn001);
                     jjtreeOpenNodeScope(jjtn001);
                   }
                   try {
/*@egen*/ ")"/*@bgen(jjtree)*/
                   } finally {
                     if (jjtc001) {
                       jjtree.closeNodeScope(jjtn001,  1);
                       jjtreeCloseNodeScope(jjtn001);
                     }
                   }
/*@egen*/                       
|
  SuperPrimaryPrefix() 
|   
  LOOKAHEAD( ResultType() "." "class" )
  ClassExp()
|
  LOOKAHEAD( Name() "[" )/*@bgen(jjtree) #Subscript( 2) */
  {
    SimpleNode jjtn002 = new SimpleNode(this, JJTSUBSCRIPT);
    boolean jjtc002 = true;
    jjtree.openNodeScope(jjtn002);
    jjtreeOpenNodeScope(jjtn002);
  }
  try {
/*@egen*/ 
  (ExpressionName() "[" Expression() "]")/*@bgen(jjtree)*/
  } catch (Throwable jjte002) {
    if (jjtc002) {
      jjtree.clearNodeScope(jjtn002);
      jjtc002 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte002 instanceof RuntimeException) {
      throw (RuntimeException)jjte002;
    }
    if (jjte002 instanceof ParseException) {
      throw (ParseException)jjte002;
    }
    throw (Error)jjte002;
  } finally {
    if (jjtc002) {
      jjtree.closeNodeScope(jjtn002,  2);
      jjtreeCloseNodeScope(jjtn002);
    }
  }
/*@egen*/              
|
  // This choice is not in the JLS 2nd ed. But I think it should be.
  // The situation is analogous to array access expression.
  // Without this choice "(k).new Foo()" is parsable, but not "k.new Foo()".
  LOOKAHEAD( Name() "." "new" )/*@bgen(jjtree) QualifiedAllocationExpression */
  {
    SimpleNode jjtn003 = new SimpleNode(this, JJTQUALIFIEDALLOCATIONEXPRESSION);
    boolean jjtc003 = true;
    jjtree.openNodeScope(jjtn003);
    jjtreeOpenNodeScope(jjtn003);
  }
  try {
/*@egen*/
  ( ExpressionName() "." "new" 
    id = Identifier() Arguments()
    [ ClassBody(CONCRETE_CLASS_MEMBER) ]/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn003, true);
      jjtc003 = false;
      jjtreeCloseNodeScope(jjtn003);
    }
/*@egen*/
    { jjtn003.setString( id ) ; }
  )/*@bgen(jjtree)*/
  } catch (Throwable jjte003) {
    if (jjtc003) {
      jjtree.clearNodeScope(jjtn003);
      jjtc003 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte003 instanceof RuntimeException) {
      throw (RuntimeException)jjte003;
    }
    if (jjte003 instanceof ParseException) {
      throw (ParseException)jjte003;
    }
    throw (Error)jjte003;
  } finally {
    if (jjtc003) {
      jjtree.closeNodeScope(jjtn003, true);
      jjtreeCloseNodeScope(jjtn003);
    }
  }
/*@egen*/                               
| 
  NamePrimaryPrefix()
}

void ThisExp() :
{/*@bgen(jjtree) ThisExp */
  SimpleNode jjtn000 = new SimpleNode(this, JJTTHISEXP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ThisExp */
    try {
/*@egen*/
    "this"/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/
}

// Primary prefixes starting with "super"
void SuperPrimaryPrefix()       :
{}
{
    LOOKAHEAD( "super" "." <IDENTIFIER> "(" )
    SuperMethodCall()
|
    SuperExp()
}

void SuperMethodCall() :
{/*@bgen(jjtree) SuperMethodCall */
    SimpleNode jjtn000 = new SimpleNode(this, JJTSUPERMETHODCALL);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtreeOpenNodeScope(jjtn000);
/*@egen*/   String id ;
}
{/*@bgen(jjtree) SuperMethodCall */
    try {
/*@egen*/
    "super" "." id = Identifier()
        { jjtn000.setString( id ) ; }
    Arguments()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/
}

void SuperExp() : // Do not change name
{/*@bgen(jjtree) SuperExp */
    SimpleNode jjtn000 = new SimpleNode(this, JJTSUPEREXP);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtreeOpenNodeScope(jjtn000);
/*@egen*/   String id ;
}
{/*@bgen(jjtree) SuperExp */
    try {
/*@egen*/
    "super" "." id = Identifier()/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
        }
/*@egen*/
        { jjtn000.setString( id ) ; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/
}

void ClassExp() :
{/*@bgen(jjtree) ClassExp */
    SimpleNode jjtn000 = new SimpleNode(this, JJTCLASSEXP);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtreeOpenNodeScope(jjtn000);
/*@egen*/
    Java_SpecifierSet specSet = new Java_SpecifierSet() ;
}
{/*@bgen(jjtree) ClassExp */
  try {
/*@egen*/
  ResultType(specSet) "." "class"/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtreeCloseNodeScope(jjtn000);
  }
/*@egen*/
  { jjtn000.setSpecSet( specSet ) ; }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}

// Primary prefixes that start with a name other than subscripts
//  NamePrimaryPrefix --> Name . this
//                      | Name . super . Identifier
//                      | Name . super . Identifier ( ArgumentList_opt )
//                      | Name ( ArgumentList_opt )
void NamePrimaryPrefix()       :
{ ScopedName name ;
  String id ;
}
{
    name = Name()
    (/*@bgen(jjtree) #MethodNameCall( 1) */
        {
          SimpleNode jjtn001 = new SimpleNode(this, JJTMETHODNAMECALL);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
          jjtreeOpenNodeScope(jjtn001);
        }
        try {
/*@egen*/
        ( Arguments()/*@bgen(jjtree)*/
                      {
                        jjtree.closeNodeScope(jjtn001,  1);
                        jjtc001 = false;
                        jjtreeCloseNodeScope(jjtn001);
                      }
/*@egen*/ { jjtn001.setName( name ) ; }        )/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  1);
            jjtreeCloseNodeScope(jjtn001);
          }
        }
/*@egen*/                    
    |
        "."
        (/*@bgen(jjtree) #ThisExp( 0) */
            {
              SimpleNode jjtn002 = new SimpleNode(this, JJTTHISEXP);
              boolean jjtc002 = true;
              jjtree.openNodeScope(jjtn002);
              jjtreeOpenNodeScope(jjtn002);
            }
            try {
/*@egen*/
            ("this"/*@bgen(jjtree)*/
                    {
                      jjtree.closeNodeScope(jjtn002,  0);
                      jjtc002 = false;
                      jjtreeCloseNodeScope(jjtn002);
                    }
/*@egen*/ { jjtn002.setName( name ) ; }          )/*@bgen(jjtree)*/
            } finally {
              if (jjtc002) {
                jjtree.closeNodeScope(jjtn002,  0);
                jjtreeCloseNodeScope(jjtn002);
              }
            }
/*@egen*/              
        |
            "super" "." id = Identifier()
            (/*@bgen(jjtree) #SuperMethodCall( 1) */
                {
                  SimpleNode jjtn003 = new SimpleNode(this, JJTSUPERMETHODCALL);
                  boolean jjtc003 = true;
                  jjtree.openNodeScope(jjtn003);
                  jjtreeOpenNodeScope(jjtn003);
                }
                try {
/*@egen*/
                ( Arguments()
                  { jjtn003.setName( name ) ; }/*@bgen(jjtree)*/
                  {
                    jjtree.closeNodeScope(jjtn003,  1);
                    jjtc003 = false;
                    jjtreeCloseNodeScope(jjtn003);
                  }
/*@egen*/
                  { jjtn003.setString( id ) ; }
                )/*@bgen(jjtree)*/
                } catch (Throwable jjte003) {
                  if (jjtc003) {
                    jjtree.clearNodeScope(jjtn003);
                    jjtc003 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte003 instanceof RuntimeException) {
                    throw (RuntimeException)jjte003;
                  }
                  if (jjte003 instanceof ParseException) {
                    throw (ParseException)jjte003;
                  }
                  throw (Error)jjte003;
                } finally {
                  if (jjtc003) {
                    jjtree.closeNodeScope(jjtn003,  1);
                    jjtreeCloseNodeScope(jjtn003);
                  }
                }
/*@egen*/                      
            |/*@bgen(jjtree) #SuperExp( 0) */
                {
                  SimpleNode jjtn004 = new SimpleNode(this, JJTSUPEREXP);
                  boolean jjtc004 = true;
                  jjtree.openNodeScope(jjtn004);
                  jjtreeOpenNodeScope(jjtn004);
                }
                try {
/*@egen*/
                ( { jjtn004.setName( name ) ; }/*@bgen(jjtree)*/
                  {
                    jjtree.closeNodeScope(jjtn004,  0);
                    jjtc004 = false;
                    jjtreeCloseNodeScope(jjtn004);
                  }
/*@egen*/
                  { jjtn004.setString( id ) ; }
                )/*@bgen(jjtree)*/
                } finally {
                  if (jjtc004) {
                    jjtree.closeNodeScope(jjtn004,  0);
                    jjtreeCloseNodeScope(jjtn004);
                  }
                }
/*@egen*/             
            )
        )
    )
}

void PrimarySuffixLookahead()       :
// Needed to cut off looping in Primary when parsing an
// explicit constructor invokation.
{}
{
    "[" | "." (<IDENTIFIER> | "new")
}

void PrimarySuffix()       :
{
    String id ;
    int count =2 ;
}
{/*@bgen(jjtree) #Subscript( 2) */
    {
      SimpleNode jjtn001 = new SimpleNode(this, JJTSUBSCRIPT);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      jjtreeOpenNodeScope(jjtn001);
    }
    try {
/*@egen*/
    ("[" Expression() "]"  )/*@bgen(jjtree)*/
    } catch (Throwable jjte001) {
      if (jjtc001) {
        jjtree.clearNodeScope(jjtn001);
        jjtc001 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte001 instanceof RuntimeException) {
        throw (RuntimeException)jjte001;
      }
      if (jjte001 instanceof ParseException) {
        throw (ParseException)jjte001;
      }
      throw (Error)jjte001;
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  2);
        jjtreeCloseNodeScope(jjtn001);
      }
    }
/*@egen*/              
|
    "." 
        (/*@bgen(jjtree) #QualifiedAllocationExpression( count) */
            {
              SimpleNode jjtn002 = new SimpleNode(this, JJTQUALIFIEDALLOCATIONEXPRESSION);
              boolean jjtc002 = true;
              jjtree.openNodeScope(jjtn002);
              jjtreeOpenNodeScope(jjtn002);
            }
            try {
/*@egen*/   
            ( "new" id = Identifier() Arguments()
               [ ClassBody(CONCRETE_CLASS_MEMBER) { count++ ; } ]/*@bgen(jjtree)*/
               {
                 jjtree.closeNodeScope(jjtn002,  count);
                 jjtc002 = false;
                 jjtreeCloseNodeScope(jjtn002);
               }
/*@egen*/
               { jjtn002.setString( id ) ; }
            )/*@bgen(jjtree)*/
            } catch (Throwable jjte002) {
              if (jjtc002) {
                jjtree.clearNodeScope(jjtn002);
                jjtc002 = false;
              } else {
                jjtree.popNode();
              }
              if (jjte002 instanceof RuntimeException) {
                throw (RuntimeException)jjte002;
              }
              if (jjte002 instanceof ParseException) {
                throw (ParseException)jjte002;
              }
              throw (Error)jjte002;
            } finally {
              if (jjtc002) {
                jjtree.closeNodeScope(jjtn002,  count);
                jjtreeCloseNodeScope(jjtn002);
              }
            }
/*@egen*/                                      
        |
            id = Identifier()
            (/*@bgen(jjtree) #MethodCall( 2) */
                {
                  SimpleNode jjtn003 = new SimpleNode(this, JJTMETHODCALL);
                  boolean jjtc003 = true;
                  jjtree.openNodeScope(jjtn003);
                  jjtreeOpenNodeScope(jjtn003);
                }
                try {
/*@egen*/
                ( Arguments()/*@bgen(jjtree)*/
                  {
                    jjtree.closeNodeScope(jjtn003,  2);
                    jjtc003 = false;
                    jjtreeCloseNodeScope(jjtn003);
                  }
/*@egen*/
                  { jjtn003.setString( id ) ; }
                )/*@bgen(jjtree)*/
                } catch (Throwable jjte003) {
                  if (jjtc003) {
                    jjtree.clearNodeScope(jjtn003);
                    jjtc003 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte003 instanceof RuntimeException) {
                    throw (RuntimeException)jjte003;
                  }
                  if (jjte003 instanceof ParseException) {
                    throw (ParseException)jjte003;
                  }
                  throw (Error)jjte003;
                } finally {
                  if (jjtc003) {
                    jjtree.closeNodeScope(jjtn003,  2);
                    jjtreeCloseNodeScope(jjtn003);
                  }
                }
/*@egen*/                 
            |/*@bgen(jjtree) #FieldAccess( 1) */
                {
                  SimpleNode jjtn004 = new SimpleNode(this, JJTFIELDACCESS);
                  boolean jjtc004 = true;
                  jjtree.openNodeScope(jjtn004);
                  jjtreeOpenNodeScope(jjtn004);
                }
                try {
/*@egen*/
                (/*@bgen(jjtree)*/
                  {
                    jjtree.closeNodeScope(jjtn004,  1);
                    jjtc004 = false;
                    jjtreeCloseNodeScope(jjtn004);
                  }
/*@egen*/ { jjtn004.setString( id ) ; }
                )/*@bgen(jjtree)*/
                } finally {
                  if (jjtc004) {
                    jjtree.closeNodeScope(jjtn004,  1);
                    jjtreeCloseNodeScope(jjtn004);
                  }
                }
/*@egen*/                  
            )
        )
}

void Literal() :
{/*@bgen(jjtree) Literal */
    SimpleNode jjtn000 = new SimpleNode(this, JJTLITERAL);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtreeOpenNodeScope(jjtn000);
/*@egen*/
    Token t ;}
{/*@bgen(jjtree) Literal */
    try {
/*@egen*/
    (
      t=<DECIMAL_LITERAL>
    |
      t=<HEX_LITERAL>
    |
      t=<OCTAL_LITERAL>
    |
      t=<FLOATING_POINT_LITERAL>
    |
      t=<CHARACTER_LITERAL>
    |
      t=<STRING_LITERAL>
    |
      t="true"
    |
      t="false"
    |
      t="null"
    )
    { jjtn000.setInt( t.kind ) ; }/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtreeCloseNodeScope(jjtn000);
    }
/*@egen*/
    { jjtn000.setString( idTable.inter( t.image ) ) ; }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/
}

void Arguments() :
{/*@bgen(jjtree) Arguments */
  SimpleNode jjtn000 = new SimpleNode(this, JJTARGUMENTS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Arguments */
  try {
/*@egen*/
  "(" [ Expression() ( "," Expression() )* ] ")"/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}

// AllocationExpression -->
//	new PrimitiveType DimExprs Dimsopt
//	new PrimitiveType Dims ArrayInitializer 
//	new TypeName DimExprs Dimsopt
//	new TypeName Dims ArrayInitializer
//	new ClassOrInterfaceType ( ArgumentListopt ) ClassBodyopt
void AllocationExpression() :
{/*@bgen(jjtree) AllocationExpression */
    SimpleNode jjtn000 = new SimpleNode(this, JJTALLOCATIONEXPRESSION);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtreeOpenNodeScope(jjtn000);
/*@egen*/
    Java_SpecifierSet specSet = new Java_SpecifierSet() ;
    ScopedName name ;
}
{/*@bgen(jjtree) AllocationExpression */
    try {
/*@egen*/
    (
      // Array ultimately of primitive type.
      LOOKAHEAD(2)
      "new" PrimitiveType(specSet) ArrayDimsAndInits()
    |
      "new" name=Name()
      { specSet.add_type_name( name ) ; }
        (
          // Array ultimately of nonprimitive type.
          ArrayDimsAndInits()
        |
          // Not an array.
          Arguments() [ ClassBody(CONCRETE_CLASS_MEMBER) ]
          {jjtn000.setBoolean( true ) ;}
        )
    )/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtreeCloseNodeScope(jjtn000);
    }
/*@egen*/
    {jjtn000.setSpecSet( specSet );}/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/
}

/*
 * The second LOOKAHEAD specification below is to parse to PrimarySuffix
 * if there is an expression between the "[...]".
 */
void ArrayDimsAndInits() :
{/*@bgen(jjtree) ArrayDimsAndInits */
    SimpleNode jjtn000 = new SimpleNode(this, JJTARRAYDIMSANDINITS);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtreeOpenNodeScope(jjtn000);
/*@egen*/
    int arrayDimCount = 0 ;
}
//  If bool parameter is true, then there is an array initializer,
//  which is the only child.
//  For example  new A[][]{{1,2},{3,4}}.
//  If the bool parameter is false then there is no array initiailizer
//  and the children are the array dimensions.
//  For example  new A[3][4][][].
//  In either case the int parameter is the number of "extra"
//  dimensions.  I.e. dimensions in the type, but that are not
//  allocated along.
{/*@bgen(jjtree) ArrayDimsAndInits */
  try {
/*@egen*/
  LOOKAHEAD(2)
  ( LOOKAHEAD(2) "[" Expression() "]" )+
  ( LOOKAHEAD(2) "[" "]" {++arrayDimCount;} )*/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtreeCloseNodeScope(jjtn000);
  }
/*@egen*/
  {jjtn000.setInt( arrayDimCount ) ; }
|
  ( "[" "]" {++arrayDimCount;} )+ ArrayInitializer()
  {jjtn000.setInt( arrayDimCount ) ; }/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtreeCloseNodeScope(jjtn000);
  }
/*@egen*/
  { jjtn000.setBoolean( true ) ; }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}


/*
 * Statement syntax follows.
 */

void Statement()       :
{}
{
  LOOKAHEAD(2)
  LabeledStatement()
|
  Block()
|
  EmptyStatement()
|
  ExpressionStatement()
|
  SwitchStatement()
|
  IfStatement()
|
  WhileStatement()
|
  DoStatement()
|
  ForStatement()
|
  BreakStatement()
|
  ContinueStatement()
|
  ReturnStatement()
|
  ThrowStatement()
|
  SynchronizedStatement()
|
  TryStatement()
}

void LabeledStatement() :
{/*@bgen(jjtree) LabeledStatement */
    SimpleNode jjtn000 = new SimpleNode(this, JJTLABELEDSTATEMENT);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtreeOpenNodeScope(jjtn000);
/*@egen*/ 
    String label ;
}
{/*@bgen(jjtree) LabeledStatement */
  try {
/*@egen*/
  label=Identifier() ":" Statement()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtreeCloseNodeScope(jjtn000);
  }
/*@egen*/
  { jjtn000.setString( label ) ; }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}

void Block() :
{/*@bgen(jjtree) Block */
  SimpleNode jjtn000 = new SimpleNode(this, JJTBLOCK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Block */
  try {
/*@egen*/
  "{" ( BlockStatement() )* "}"/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}

void BlockStatement()       :
{}
{
  LOOKAHEAD( ( "abstract" | "final" | "public" | "strictfp" )* "class" )
  ClassDeclaration(LOCAL)
|
  LOOKAHEAD( ( "abstract" | "public" | "strictfp" )* "interface" )
  InterfaceDeclaration(LOCAL)
|
  LOOKAHEAD([ "final" ] Type() <IDENTIFIER>)
  LocalVariableDeclaration() ";"
|
  Statement()
}

void LocalVariableDeclaration()        :
{
    Java_SpecifierSet specSet = new Java_SpecifierSet() ;
}
{
  [ Final( specSet, true ) ]
  Type( specSet ) 
  VariableDeclarator( specSet )
  ( "," VariableDeclarator( specSet ) )*
}

void EmptyStatement() :
{/*@bgen(jjtree) EmptyStatement */
  SimpleNode jjtn000 = new SimpleNode(this, JJTEMPTYSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) EmptyStatement */
  try {
/*@egen*/
  ";"/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}

void ExpressionStatement() :
{/*@bgen(jjtree) ExpressionStatement */
  SimpleNode jjtn000 = new SimpleNode(this, JJTEXPRESSIONSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ExpressionStatement */
  try {
/*@egen*/
  StatementExpression() ";"/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}


void StatementExpression()       :
/*
 * This is far more liberal than the JLS. What is the down side?
 */
{ Token t ; }
{
  Expression()
}

void AssertStatement() :
{/*@bgen(jjtree) AssertStatement */
  SimpleNode jjtn000 = new SimpleNode(this, JJTASSERTSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) AssertStatement */
  try {
/*@egen*/
  "assert" Expression() 
  [ ":" Expression() { jjtn000.setBoolean( true );} ] ";"/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}

void SwitchStatement() :
{/*@bgen(jjtree) SwitchStatement */
  SimpleNode jjtn000 = new SimpleNode(this, JJTSWITCHSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) SwitchStatement */
  try {
/*@egen*/
  "switch" "(" Expression() ")" "{"
   ( Case() )*
  "}"/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}

void Case() :
{/*@bgen(jjtree) Case */
  SimpleNode jjtn000 = new SimpleNode(this, JJTCASE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Case */
    try {
/*@egen*/
    SwitchLabel() ( BlockStatement() )*/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/
}

void SwitchLabel() :
{/*@bgen(jjtree) SwitchLabel */
  SimpleNode jjtn000 = new SimpleNode(this, JJTSWITCHLABEL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) SwitchLabel */
  try {
/*@egen*/
  "case" Expression() ":"/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtreeCloseNodeScope(jjtn000);
  }
/*@egen*/
  { jjtn000.setBoolean( true ) ; }
|
  "default" ":"/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}

void IfStatement() :
/*
 * The disambiguating algorithm of JavaCC automatically binds dangling
 * else's to the innermost if statement.  The LOOKAHEAD specification
 * is to tell JavaCC that we know what we are doing.
 */
{/*@bgen(jjtree) IfStatement */
  SimpleNode jjtn000 = new SimpleNode(this, JJTIFSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) IfStatement */
  try {
/*@egen*/
  "if" "(" Expression() ")" Statement() [ LOOKAHEAD(1) "else" Statement() ]/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}

void WhileStatement() :
{/*@bgen(jjtree) WhileStatement */
  SimpleNode jjtn000 = new SimpleNode(this, JJTWHILESTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) WhileStatement */
  try {
/*@egen*/
  "while" "(" Expression() ")" Statement()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}

void DoStatement() :
{/*@bgen(jjtree) DoStatement */
  SimpleNode jjtn000 = new SimpleNode(this, JJTDOSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) DoStatement */
  try {
/*@egen*/
  "do" Statement() "while" "(" Expression() ")" ";"/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}

void ForStatement() :
{/*@bgen(jjtree) ForStatement */
  SimpleNode jjtn000 = new SimpleNode(this, JJTFORSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ForStatement */
  try {
/*@egen*/
  "for" "(" OptForInit() ";" OptExpression() ";" OptForUpdate() ")" Statement()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}

void OptForInit() :
{/*@bgen(jjtree) OptForInit */
  SimpleNode jjtn000 = new SimpleNode(this, JJTOPTFORINIT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) OptForInit */
    try {
/*@egen*/
    [ ForInit() { jjtn000.setBoolean( true ) ; } ]/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/
}

void ForInit() :
{/*@bgen(jjtree) ForInit */
  SimpleNode jjtn000 = new SimpleNode(this, JJTFORINIT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ForInit */
  try {
/*@egen*/
  LOOKAHEAD( [ "final" ] Type() <IDENTIFIER> )
  LocalVariableDeclaration()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtreeCloseNodeScope(jjtn000);
  }
/*@egen*/
  {jjtn000.setBoolean( true ) ; }
|
  StatementExpressionList()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}

void StatementExpressionList()       :
{}
{
  StatementExpression() ( "," StatementExpression() )*
}

void OptExpression() :
{/*@bgen(jjtree) OptExpression */
  SimpleNode jjtn000 = new SimpleNode(this, JJTOPTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) OptExpression */
    try {
/*@egen*/
    [ Expression() { jjtn000.setBoolean( true ) ; } ]/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/
}

void OptForUpdate() :
{/*@bgen(jjtree) OptForUpdate */
  SimpleNode jjtn000 = new SimpleNode(this, JJTOPTFORUPDATE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) OptForUpdate */
    try {
/*@egen*/
    [ StatementExpressionList() ]/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/
}

void BreakStatement() :
{/*@bgen(jjtree) BreakStatement */
    SimpleNode jjtn000 = new SimpleNode(this, JJTBREAKSTATEMENT);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtreeOpenNodeScope(jjtn000);
/*@egen*/
    String label ;
}
{/*@bgen(jjtree) BreakStatement */
  try {
/*@egen*/
  "break"
  [ label=Identifier()
    { jjtn000.setBoolean( true ) ; jjtn000.setString(label); }
  ]
  ";"/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}

void ContinueStatement() :
{/*@bgen(jjtree) ContinueStatement */
    SimpleNode jjtn000 = new SimpleNode(this, JJTCONTINUESTATEMENT);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtreeOpenNodeScope(jjtn000);
/*@egen*/
    String label ;
}
{/*@bgen(jjtree) ContinueStatement */
  try {
/*@egen*/
  "continue"
  [ label=Identifier()
    { jjtn000.setBoolean( true ) ; jjtn000.setString(label); }
  ]
  ";"/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}

void ReturnStatement() :
{/*@bgen(jjtree) ReturnStatement */
  SimpleNode jjtn000 = new SimpleNode(this, JJTRETURNSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ReturnStatement */
  try {
/*@egen*/
  "return"
  [ Expression() { jjtn000.setBoolean( true );} ] ";"/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}

void ThrowStatement() :
{/*@bgen(jjtree) ThrowStatement */
  SimpleNode jjtn000 = new SimpleNode(this, JJTTHROWSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ThrowStatement */
  try {
/*@egen*/
  "throw" Expression() ";"/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}

void SynchronizedStatement() :
{/*@bgen(jjtree) SynchronizedStatement */
  SimpleNode jjtn000 = new SimpleNode(this, JJTSYNCHRONIZEDSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) SynchronizedStatement */
  try {
/*@egen*/
  "synchronized" "(" Expression() ")" Block()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}

void TryStatement() :
{/*@bgen(jjtree) TryStatement */
  SimpleNode jjtn000 = new SimpleNode(this, JJTTRYSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) TryStatement */
  try {
/*@egen*/
  "try" Block()
  ( LOOKAHEAD( "catch" ) Catches() ["finally" Block() { jjtn000.setBoolean( true );}]
  | Catches() "finally" Block()/*@bgen(jjtree)*/
                                {
                                  jjtree.closeNodeScope(jjtn000, true);
                                  jjtc000 = false;
                                  jjtreeCloseNodeScope(jjtn000);
                                }
/*@egen*/ { jjtn000.setBoolean( true );}
  )/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}

void Catches() :
{/*@bgen(jjtree) Catches */
  SimpleNode jjtn000 = new SimpleNode(this, JJTCATCHES);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Catches */
    try {
/*@egen*/
    ( Catch() )*/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/
}

void Catch() :
{/*@bgen(jjtree) Catch */
  SimpleNode jjtn000 = new SimpleNode(this, JJTCATCH);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Catch */
    try {
/*@egen*/
    "catch" "(" FormalParameter() ")" Block()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/
}

ScopedName SimpleName()       :
{
    String id ;
    ScopedName name ;
}
{
    id = Identifier()
        { name = new Java_ScopedName( id ) ; }
        { return name ; }
}

String Identifier()       :
{
    Token t ;
}
{
    t = <IDENTIFIER>
        { return idTable.inter( t.image ) ; }
}

void Abstract(Java_SpecifierSet specSet, boolean cond)       :
{}
{
    "abstract"
    { if( ! cond || specSet.contains( Java_Specifiers.SP_ABSTRACT ) )
        Assert.error( "abstract not allowed" ) ; }
    { specSet.add( Java_Specifiers.SP_ABSTRACT ) ; }
}

void Final(Java_SpecifierSet specSet, boolean cond)       :
{}
{
    "final"
    { if( ! cond || specSet.contains( Java_Specifiers.SP_FINAL ) )
        Assert.error( "final not allowed" ) ; }
    { specSet.add( Java_Specifiers.SP_FINAL ) ; }
}

void Native(Java_SpecifierSet specSet, boolean cond)       :
{}
{
    "native"
    { if( ! cond || specSet.contains( Java_Specifiers.SP_NATIVE ) )
        Assert.error( "native not allowed" ) ; }
    { specSet.add( Java_Specifiers.SP_NATIVE ) ; }
}

void Public(Java_SpecifierSet specSet, boolean cond)       :
{}
{
    "public"
    { if( ! cond || specSet.contains( Java_Specifiers.SP_PUBLIC )
        || specSet.contains( Java_Specifiers.SP_PROTECTED ) 
        || specSet.contains( Java_Specifiers.SP_PRIVATE ) )
        Assert.error( "public not allowed" ) ; }
    { specSet.add( Java_Specifiers.SP_PUBLIC ) ; }
}

void Private(Java_SpecifierSet specSet, boolean cond)       :
{}
{
    "private"
    { if( ! cond || specSet.contains( Java_Specifiers.SP_PUBLIC )
        || specSet.contains( Java_Specifiers.SP_PROTECTED ) 
        || specSet.contains( Java_Specifiers.SP_PRIVATE ) )
        Assert.error( "private not allowed" ) ; }
    { specSet.add( Java_Specifiers.SP_PRIVATE ) ; }
}

void Protected(Java_SpecifierSet specSet, boolean cond)       :
{}
{
    "protected"
    { if( ! cond || specSet.contains( Java_Specifiers.SP_PUBLIC )
        || specSet.contains( Java_Specifiers.SP_PROTECTED ) 
        || specSet.contains( Java_Specifiers.SP_PRIVATE ) )
        Assert.error( "protected not allowed" ) ; }
    { specSet.add( Java_Specifiers.SP_PROTECTED ) ; }
}

void Static(Java_SpecifierSet specSet, boolean cond)       :
{}
{
    "static"
    { if( ! cond || specSet.contains( Java_Specifiers.SP_STATIC ) )
        Assert.error( "static not allowed" ) ; }
    { specSet.add( Java_Specifiers.SP_STATIC ) ; }
}

void Strictfp(Java_SpecifierSet specSet, boolean cond)       :
{}
{
    "strictfp"
    { if( ! cond || specSet.contains( Java_Specifiers.SP_STRICTFP ) )
        Assert.error( "strictfp not allowed" ) ; }
    { specSet.add( Java_Specifiers.SP_STRICTFP ) ; }
}

void Synchronized(Java_SpecifierSet specSet, boolean cond)       :
{}
{
    "synchronized"
    { if( ! cond || specSet.contains( Java_Specifiers.SP_SYNCHRONIZED ) )
        Assert.error( "synchronized not allowed" ) ; }
    { specSet.add( Java_Specifiers.SP_SYNCHRONIZED ) ; }
}

void Transient(Java_SpecifierSet specSet, boolean cond)       :
{}
{
    "transient"
    { if( ! cond || specSet.contains( Java_Specifiers.SP_TRANSIENT ) )
        Assert.error( "transient not allowed" ) ; }
    { specSet.add( Java_Specifiers.SP_TRANSIENT ) ; }
}

void Volatile(Java_SpecifierSet specSet, boolean cond)       :
{}
{
    "volatile"
    { if( ! cond || specSet.contains( Java_Specifiers.SP_VOLATILE ) )
        Assert.error( "volatile not allowed" ) ; }
    { specSet.add( Java_Specifiers.SP_VOLATILE ) ; }
}