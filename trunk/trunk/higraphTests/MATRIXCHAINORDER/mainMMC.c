#include <stdio.h>#define N 4unsigned long p[N+1] = { 100, 20, 1000, 2, 50 };/*void newInstance() {	int i;	int w =20;	int h = 20;	for (i=0; i<N; i++) {		sm::assertNode(i, p[i]);		sm::assertNodeRectangle(i,i*w, h,w,h);	}}*/unsigned long m[N][N];/*void initCosts() {	int i, j;	int w =20;	int h = 20;	int y0 = 60;	for (i=0; i<N; i++) {		sm::assertNode(m[i], "0");        		sm::assertNode(N+i*N+i, "0");		sm::rectangle(N+i*N+i, w, i*h,w,h);		for (j = i+1; j< N; j++) {			sm::assertNode(m[i][j], "");			sm::assertNode(N+i*N+j, "");			sm::rectangle(N+i*N+j, j*w, i*h,w,h);		}	}}*/unsigned long s[N][N];/*void initSplitIndices() {	int i, j;	int w =20;	int h = 20;	int y0 = 160;	for (i=0; i<N; i++) {		sm::assertNode(N+N*N+i*N+i, "0");		sm::assertNodeRectangle(N+N*N+i*N+i, w, i*h,w,h);		for (j = i+1; j< N; j++) {			sm::assertNode(N+N*N+i*N+j, " ");			sm::assertNodeRectangle(N+N*N+i*N+j, j*w, i*h,w,h);		}	}}*//*void newCostFound(int i, int j) {	if (j > i) {		setNodeColor(N+i*N+j, "RED");		setNodeColor(N+N*N+i*N+j, "RED");		setNodeColor(N+i*N+s[i][j], "GREEN");		setNodeColor(N+(s[i][j]+1)*N+j, "AZURE");		setNodeColor(i, "YELLOW");		setNodeColor(s[i][j]+1, "YELLOW");		setNodeColor(j+1, "YELLOW");		createPartialExpressioneTree(i, j, s[i][j]);		wayPoint() ;	}}void createPartialExpressionTree(i, j, r) {	int leftRoot = createTree(i, r, N+2*N*N);	int rightRoot = createTree(r + 1, j, leftRoot+1);	int root = rightRoot+1;	sm::assertNode(root, itoa(d[i]*d[r+1]*d[j+1]));	sm::assertBTNode(root, itoa(d[i]*d[r+1]*d[j+1]));	sm::assertNodeLabel(leftRoot, itoa(m[i][r]));	sm::assertNodeLabel(rightRoot, itoa(m[r+1][j]));	sm::assertBTLeftEdge(root, leftRoot);	sm::assertBTRightEdge(root, rightRoot);	sm::setNodeColor(root, "YELLOW");	sm::setNodeColor(leftRoot, "GREEN");	sm::setNodeColor(rightRoot, "AZURE");}int createTree(int i, int j, int id) {	if (i == j) {		sm::assertBTNode(id, strcat("A", itoa(i));		return id;	} else {		int leftRoot = createTree(i, r, id);		int rightRoot = createTree(r + 1, j, leftRoot+1);		int root = rightRoot+1;		sm::assertBTNode(root, "x");		sm::assertBTLeftEdge(root, leftRoot);		sm::assertBTRightEdge(rot, rightRoot);		return root;	}}*//*void newCostStored(int i, int j) {	if (m[i][j] > 0) {		sm::retractNodeColor(N+i*N+s[i][j]);		sm::retractNodeColor(N+(s[i][j]+1)*N+j);		sm::retractNodeColor(i);		sm::retractNodeColor(s[i][j]+1);		sm::retractNodeColor(j+1);		createExpressioneTree(i, j, s[i][j]);	}}void createExpressionTree(i, j, r) {	int leftRoot = createTree(i, r, N+2*N*N);	int rightRoot = createTree(r + 1, j, leftRoot+1);	int root = rightRoot+1;	sm::assertBTNode(root, "x");	sm::assertBTEdge(0, root, leftRoot);	sm::assertBTEdge(1, root, rightRoot);	sm::assertNodeColor(root, "RED");}int createTree(int i, int j, int id) {	if (i == j) {		sm::assertBTNode(id, strcat("A", itoa(i));		return id;	} else {		int leftRoot = createTree(i, r, id);		int rightRoot = createTree(r + 1, j, leftRoot+1);		int root = rightRoot+1;		sm::assertBTNode(root, "x");		sm::assertBTLeftEdge(root, leftRoot);		sm::assertBTRightEdge(rot, rightRoot);		return root;	}}*/void compute_cost() {	int d, i, j, r;	unsigned long c;    for (i = 0; i < N; i++) {       m[i][i] = 0;       s[i][i] = i;    }    for (d=1; d<N; d++) {        for (i=0; i<N-d; i++) {            j = i + d;            m[i][j] = -1;			for (r=i; r<j; r++) {				c = m[i][r] + m[r+1][j];				c = c + p[i]*p[r+1]*p[j+1]; //breakPoint();				if (m[i][j] < 0 || c < m[i][j]) {					s[i][j] = r;					m[i][j] = c;				}			}        }    }}int main() {    /*onCreateArray(p, 5, "newInstance");    onCreateArray(m, 4, 4, "initCosts");    onCreateArray(s, 4, 4, "initSplitIndices");    onChangeArray(s, N, N, "newCostFound");    onChangeArray(m, N, N, "newCostStored");*/	compute_cost();	printf("%d\n",m[0][N-1]) ;}